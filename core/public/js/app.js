/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.5.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-04-10T15:07Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = Object.create( null );

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./flipbook/jquery.js */ "./resources/js/flipbook/jquery.js");

__webpack_require__(/*! ./flipbook/jquery-ui.min.js */ "./resources/js/flipbook/jquery-ui.min.js");

__webpack_require__(/*! ./flipbook/flipbook.min.js */ "./resources/js/flipbook/flipbook.min.js");

$(document).ready(function () {
  $("#xem-pdf").flipBook({
    pdfUrl: "/uploads/topics/{{ $Topic->attach_file }}"
  });
});

/***/ }),

/***/ "./resources/js/flipbook/flipbook.min.js":
/*!***********************************************!*\
  !*** ./resources/js/flipbook/flipbook.min.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* v 3.12.1
author http://codecanyon.net/user/creativeinteractivemedia/portfolio?ref=creativeinteractivemedia
*/
var FLIPBOOK = FLIPBOOK || {};
!function (O, T, y, a) {
  O.fn.flipBook = function (e) {
    return new FLIPBOOK.Main(e, this);
  }, O.fn.swipeBook = function (e) {
    return e.viewMode = "swipe", new FLIPBOOK.Main(e, this);
  }, O.fn.flipBook.options = {
    name: "",
    pages: [],
    tableOfContent: [],
    tableOfContentCloseOnClick: !0,
    thumbsCloseOnClick: !0,
    deeplinkingEnabled: !1,
    deeplinkingPrefix: "",
    assets: {
      preloader: "images/preloader.jpg",
      overlay: "images/overlay.png",
      flipMp3: "mp3/turnPage.mp3",
      spinner: "images/spinner.gif"
    },
    pdfUrl: null,
    pdfBrowserViewerIfMobile: !1,
    pdfBrowserViewerIfIE: !1,
    pdfBrowserViewerFullscreen: !0,
    pdfBrowserViewerFullscreenTarget: "_blank",
    pdfPageScale: 1,
    pdfOutline: !0,
    rangeChunkSize: 64,
    htmlLayer: !0,
    rightToLeft: !1,
    startPage: 0,
    sound: !0,
    backgroundColor: "rgb(81, 85, 88)",
    backgroundImage: "",
    backgroundPattern: "",
    backgroundTransparent: !1,
    thumbSize: 130,
    loadAllPages: !1,
    loadPagesF: 2,
    loadPagesB: 1,
    autoplayOnStart: !1,
    autoplayInterval: 3e3,
    autoplayLoop: !0,
    skin: "light",
    layout: "1",
    menuOverBook: !1,
    menuFloating: !1,
    menuBackground: "",
    menuShadow: "",
    menuMargin: 0,
    menuPadding: 0,
    menuTransparent: !1,
    menu2OverBook: !0,
    menu2Floating: !1,
    menu2Background: "",
    menu2Shadow: "",
    menu2Margin: 0,
    menu2Padding: 0,
    menu2Transparent: !0,
    skinColor: "",
    skinBackground: "",
    btnColor: "",
    btnBackground: "none",
    btnSize: 14,
    btnRadius: 2,
    btnMargin: 2,
    btnShadow: "",
    btnTextShadow: "",
    btnBorder: "",
    btnColorHover: "",
    btnBackgroundHover: "",
    sideBtnColor: "#FFF",
    sideBtnBackground: "#00000033",
    sideBtnSize: 30,
    sideBtnRadius: 0,
    sideBtnMargin: 0,
    sideBtnPaddingV: 5,
    sideBtnPaddingH: 0,
    sideBtnShadow: "",
    sideBtnTextShadow: "",
    sideBtnBorder: "",
    sideBtnColorHover: "#FFF",
    sideBtnBackgroundHover: "#00000066",
    floatingBtnColor: "#EEE",
    floatingBtnBackground: "#00000044",
    floatingBtnSize: null,
    floatingBtnRadius: null,
    floatingBtnMargin: null,
    floatingBtnShadow: "",
    floatingBtnTextShadow: "",
    floatingBtnBorder: "",
    floatingBtnColorHover: "",
    floatingBtnBackgroundHover: "",
    btnOrder: ["currentPage", "btnFirst", "btnPrev", "btnNext", "btnLast", "btnZoomIn", "btnZoomOut", "btnRotateLeft", "btnRotateRight", "btnAutoplay", "btnSearch", "btnSelect", "btnBookmark", "btnToc", "btnThumbs", "btnShare", "btnPrint", "btnDownloadPages", "btnDownloadPdf", "btnSound", "btnExpand", "btnClose"],
    currentPage: {
      enabled: !0,
      title: "Current page",
      vAlign: "top",
      hAlign: "left",
      marginH: 0,
      marginV: 0,
      color: "",
      background: ""
    },
    btnFirst: {
      enabled: !1,
      title: "First page",
      icon: "fa-angle-double-left",
      icon2: "first_page"
    },
    btnPrev: {
      enabled: !0,
      title: "Previous page",
      icon: "fa-angle-left",
      icon2: "chevron_left"
    },
    btnNext: {
      enabled: !0,
      title: "Next page",
      icon: "fa-angle-right",
      icon2: "chevron_right"
    },
    btnLast: {
      enabled: !1,
      title: "Last page",
      icon: "fa-angle-double-right",
      icon2: "last_page"
    },
    btnZoomIn: {
      enabled: !0,
      title: "Zoom in",
      icon: "fa-plus",
      icon2: "zoom_in"
    },
    btnZoomOut: {
      enabled: !0,
      title: "Zoom out",
      icon: "fa-minus",
      icon2: "zoom_out"
    },
    btnRotateLeft: {
      enabled: !1,
      title: "Rotate left",
      icon: "fas fa-undo"
    },
    btnRotateRight: {
      enabled: !1,
      title: "Rotate right",
      icon: "fas fa-redo"
    },
    btnAutoplay: {
      enabled: !0,
      title: "Autoplay",
      icon: "fa-play",
      icon2: "play_arrow",
      iconAlt: "fa-pause",
      iconAlt2: "pause"
    },
    btnSearch: {
      enabled: !1,
      title: "Search",
      icon: "fas fa-search",
      icon2: "search"
    },
    btnSelect: {
      enabled: !0,
      title: "Select tool",
      icon: "fas fa-i-cursor",
      icon2: "text_format"
    },
    btnBookmark: {
      enabled: !0,
      title: "Bookmark",
      icon: "fas fa-bookmark",
      icon2: "bookmark"
    },
    btnToc: {
      enabled: !0,
      title: "Table of Contents",
      icon: "fa-list-ol",
      icon2: "toc"
    },
    btnThumbs: {
      enabled: !0,
      title: "Pages",
      icon: "fa-th-large",
      icon2: "view_module"
    },
    btnShare: {
      enabled: !0,
      title: "Share",
      icon: "fa-link",
      icon2: "share",
      hideOnMobile: !0
    },
    btnPrint: {
      enabled: !0,
      title: "Print",
      icon: "fa-print",
      icon2: "print",
      hideOnMobile: !0
    },
    btnDownloadPages: {
      enabled: !0,
      title: "Download pages",
      icon: "fa-download",
      icon2: "file_download",
      url: "images/pages.zip",
      name: "allPages.zip"
    },
    btnDownloadPdf: {
      forceDownload: !1,
      enabled: !0,
      title: "Download PDF",
      icon: "fa-file",
      icon2: "picture_as_pdf",
      url: null,
      openInNewWindow: !0,
      name: "allPages.pdf"
    },
    btnSound: {
      enabled: !0,
      title: "Volume",
      icon: "fa-volume-up",
      iconAlt: "fa-volume-off",
      icon2: "volume_up",
      iconAlt2: "volume_mute",
      hideOnMobile: !0
    },
    btnExpand: {
      enabled: !0,
      title: "Toggle fullscreen",
      icon: "fa-expand",
      icon2: "fullscreen",
      iconAlt: "fa-compress",
      iconAlt2: "fullscreen_exit"
    },
    btnClose: {
      title: "Close",
      icon: "fa-times",
      icon2: "close",
      hAlign: "right",
      vAlign: "top",
      size: 20
    },
    btnShareIfMobile: !1,
    btnSoundIfMobile: !1,
    btnPrintIfMobile: !1,
    sideNavigationButtons: !0,
    hideMenu: !1,
    twitter: {
      enabled: !0,
      url: null,
      description: null
    },
    facebook: {
      enabled: !0,
      load_sdk: !0,
      url: null,
      app_id: null,
      title: null,
      caption: null,
      description: null,
      image: null
    },
    pinterest: {
      enabled: !0,
      url: null,
      image: null,
      description: null
    },
    email: {
      enabled: !0,
      title: null,
      description: null,
      url: null
    },
    pdf: {
      annotationLayer: !1
    },
    pageTextureSize: 2048,
    pageTextureSizeSmall: 1500,
    pageTextureSizeMobile: null,
    pageTextureSizeMobileSmall: 1024,
    viewMode: "webgl",
    singlePageMode: !1,
    singlePageModeIfMobile: !1,
    zoomMin: .95,
    zoomMax2: null,
    zoomSize: null,
    zoomStep: 2,
    zoomTime: 300,
    zoomReset: !1,
    zoomResetTime: 300,
    wheelDisabledNotFullscreen: !1,
    arrowsDisabledNotFullscreen: !1,
    arrowsAlwaysEnabledForNavigation: !1,
    responsiveView: !0,
    responsiveViewTreshold: 768,
    minPixelRatio: 1,
    pageFlipDuration: 1,
    contentOnStart: !1,
    thumbnailsOnStart: !1,
    searchOnStart: !1,
    sideMenuOverBook: !0,
    sideMenuOverMenu: !1,
    sideMenuOverMenu2: !0,
    lightBox: !1,
    lightBoxOpened: !1,
    lightBoxFullscreen: !1,
    lightboxCloseOnClick: !1,
    lightboxResetOnOpen: !0,
    lightboxBackground: null,
    lightboxBackgroundColor: null,
    lightboxBackgroundPattern: null,
    lightboxBackgroundImage: null,
    lightboxStartPage: null,
    lightboxMarginV: "0",
    lightboxMarginH: "0",
    lightboxCSS: "",
    lightboxPreload: !1,
    lightboxShowMenu: !1,
    disableImageResize: !0,
    pan: 0,
    panMax: 10,
    panMax2: 2,
    panMin: -10,
    panMin2: -2,
    tilt: 0,
    tiltMax: 0,
    tiltMax2: 0,
    tiltMin: -20,
    tiltMin2: -5,
    rotateCameraOnMouseMove: !1,
    rotateCameraOnMouseDrag: !0,
    lights: !0,
    lightColor: 16777215,
    lightPositionX: 0,
    lightPositionZ: 1400,
    lightPositionY: 350,
    lightIntensity: .6,
    shadows: !0,
    shadowMapSize: 1024,
    shadowOpacity: .2,
    shadowDistance: 15,
    pageRoughness: 1,
    pageMetalness: 0,
    pageHardness: 2,
    coverHardness: 2,
    pageSegmentsW: 5,
    pageSegmentsH: 1,
    pageMiddleShadowSize: 2,
    pageMiddleShadowColorL: "#999999",
    pageMiddleShadowColorR: "#777777",
    antialias: !1,
    preloaderText: "",
    fillPreloader: {
      enabled: !1,
      imgEmpty: "images/logo_light.png",
      imgFull: "images/logo_dark.png"
    },
    logoImg: "",
    logoUrl: "",
    logoCSS: "position:absolute;",
    logoHideOnMobile: !1,
    printMenu: !0,
    downloadMenu: !0,
    cover: !0,
    backCover: !0,
    textLayer: !1,
    googleAnalyticsTrackingCode: null,
    minimumAndroidVersion: 6,
    linkColor: "rgba(255, 255, 0, .05)",
    linkColorHover: "rgba(255, 255, 0, .2)",
    strings: {
      print: "Print",
      printLeftPage: "Print left page",
      printRightPage: "Print right page",
      printCurrentPage: "Print current page",
      printAllPages: "Print all pages",
      download: "Download",
      downloadLeftPage: "Download left page",
      downloadRightPage: "Download right page",
      downloadCurrentPage: "Download current page",
      downloadAllPages: "Download all pages",
      bookmarks: "Bookmarks",
      bookmarkLeftPage: "Bookmark left page",
      bookmarkRightPage: "Bookmark right page",
      bookmarkCurrentPage: "Bookmark current page",
      search: "Search",
      findInDocument: "Find in document",
      pagesFoundContaining: "pages found containing",
      thumbnails: "Thumbnails",
      tableOfContent: "Table of Contents",
      share: "Share",
      pressEscToClose: "Press ESC to close"
    },
    mobile: {}
  }, FLIPBOOK.Main = function (e, t) {
    var n = this;
    this.elem = t, this.$elem = O(t), this.$body = O("body"), this.body = this.$body[0], this.$window = O(T), this.bodyHasVerticalScrollbar = function () {
      return n.body.scrollHeight > T.innerHeight;
    }, this.isZoomed = function () {
      return 1 < n.zoom;
    }, this.options = {};

    var o,
        i = y.createElement("div").style,
        s = function () {
      for (var e = "t,webkitT,MozT,msT,OT".split(","), t = 0, o = e.length; t < o; t++) {
        if (e[t] + "ransform" in i) return e[t].substr(0, e[t].length - 1);
      }

      return !1;
    }(),
        a = /android/gi.test(navigator.appVersion),
        r = (/iphone|ipad/gi.test(navigator.appVersion), o = "perspective", ("" === s ? o : (o = o.charAt(0).toUpperCase() + o.substr(1), s + o)) in i);

    this.msie = T.navigator.userAgent.indexOf("MSIE "), this.isAndroid = a, this.has3d = r, void 0 === FLIPBOOK.hasWebGl && function (e) {
      if (T.WebGLRenderingContext) {
        for (var t = y.createElement("canvas"), o = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"], i = !1, n = 0; n < 4; n++) {
          try {
            if ((i = t.getContext(o[n])) && "function" == typeof i.getParameter) return e || (FLIPBOOK.hasWebGl = !0);
          } catch (e) {}
        }

        FLIPBOOK.hasWebGl = !1;
      } else FLIPBOOK.hasWebGl = !1;
    }(), this.hasWebGl = FLIPBOOK.hasWebGl, 0 < function () {
      var e = -1;

      if ("Microsoft Internet Explorer" == navigator.appName) {
        var t = navigator.userAgent;
        null != new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})").exec(t) && (e = parseFloat(RegExp.$1));
      } else if ("Netscape" == navigator.appName) {
        t = navigator.userAgent;
        null != new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})").exec(t) && (e = parseFloat(RegExp.$1));
      }

      return e;
    }() && (this.hasWebGl = !1, this.options.isIE = !0), this.thumbsShowing = !1, this.bookmarkShowing = !1, this.searchingString = !1, this.tocShowing = !1, this.menuShowing = !0;
    var l = {
      2: {
        currentPage: {
          vAlign: "bottom",
          hAlign: "center"
        },
        btnAutoplay: {
          hAlign: "left"
        },
        btnSound: {
          hAlign: "left"
        },
        btnExpand: {
          hAlign: "right"
        },
        btnZoomIn: {
          hAlign: "right"
        },
        btnZoomOut: {
          hAlign: "right"
        },
        btnSearch: {
          hAlign: "left"
        },
        btnBookmark: {
          hAlign: "left"
        },
        btnToc: {
          hAlign: "left"
        },
        btnThumbs: {
          hAlign: "left"
        },
        btnShare: {
          hAlign: "right"
        },
        btnPrint: {
          hAlign: "right"
        },
        btnDownloadPages: {
          hAlign: "right"
        },
        btnDownloadPdf: {
          hAlign: "right"
        },
        btnSelect: {
          hAlign: "right"
        }
      },
      3: {
        menuTransparent: !(this.fullscreenActive = !1),
        menu2Transparent: !1,
        menu2OverBook: !1,
        menu2Padding: 5,
        btnMargin: 5,
        currentPage: {
          vAlign: "top",
          hAlign: "center"
        },
        btnPrint: {
          vAlign: "top",
          hAlign: "right"
        },
        btnDownloadPdf: {
          vAlign: "top",
          hAlign: "right"
        },
        btnDownloadPages: {
          vAlign: "top",
          hAlign: "right"
        },
        btnThumbs: {
          vAlign: "top",
          hAlign: "left"
        },
        btnToc: {
          vAlign: "top",
          hAlign: "left"
        },
        btnBookmark: {
          vAlign: "top",
          hAlign: "left"
        },
        btnSearch: {
          vAlign: "top",
          hAlign: "left"
        },
        btnSelect: {
          vAlign: "top",
          hAlign: "right"
        },
        btnShare: {
          vAlign: "top",
          hAlign: "right"
        },
        btnAutoplay: {
          hAlign: "right"
        },
        btnExpand: {
          hAlign: "right"
        },
        btnZoomIn: {
          hAlign: "right"
        },
        btnZoomOut: {
          hAlign: "right"
        },
        btnSound: {
          hAlign: "right"
        },
        menuPadding: 5
      },
      4: {
        menu2Transparent: !1,
        menu2OverBook: !1,
        sideMenuOverMenu2: !1,
        currentPage: {
          vAlign: "top",
          hAlign: "center"
        },
        btnAutoplay: {
          vAlign: "top",
          hAlign: "left"
        },
        btnSound: {
          vAlign: "top",
          hAlign: "left"
        },
        btnExpand: {
          vAlign: "top",
          hAlign: "right"
        },
        btnZoomIn: {
          vAlign: "top",
          hAlign: "right"
        },
        btnZoomOut: {
          vAlign: "top",
          hAlign: "right"
        },
        btnSearch: {
          vAlign: "top",
          hAlign: "left"
        },
        btnBookmark: {
          vAlign: "top",
          hAlign: "left"
        },
        btnToc: {
          vAlign: "top",
          hAlign: "left"
        },
        btnThumbs: {
          vAlign: "top",
          hAlign: "left"
        },
        btnShare: {
          vAlign: "top",
          hAlign: "right"
        },
        btnPrint: {
          vAlign: "top",
          hAlign: "right"
        },
        btnDownloadPages: {
          vAlign: "top",
          hAlign: "right"
        },
        btnDownloadPdf: {
          vAlign: "top",
          hAlign: "right"
        },
        btnSelect: {
          vAlign: "top",
          hAlign: "right"
        }
      }
    },
        d = {
      dark: {
        skinColor: "#EEE",
        btnColorHover: "#FFF",
        skinBackground: "#313538"
      },
      light: {
        skinColor: "#222",
        btnColorHover: "#000",
        skinBackground: "#FFF",
        floatingBtnColor: "#FFF",
        floatingBtnBackground: "#00000055"
      },
      gradient: {
        skinColor: "#EEE",
        btnColor: "#EEE",
        btnColorHover: "#FFF",
        skinBackground: "#313538DD",
        zoomMin: .85,
        menuOverBook: !0,
        menu2OverBook: !0,
        sideMenuOverMenu: !0,
        sideMenuOverMenu2: !0,
        menuBackground: "linear-gradient(to top, rgba(0, 0, 0, 0.65) 0%, transparent 100%)",
        menu2Background: "linear-gradient(to bottom, rgba(0, 0, 0, 0.65) 0%, transparent 100%)"
      }
    };

    for (var h in d) {
      e.skin == h && (e = O.extend(!0, {}, d[h], e));
    }

    for (var h in l) {
      String(e.layout) === h && (e = O.extend(!0, {}, l[h], e));
    }

    this.options = O.extend(!0, {}, O.fn.flipBook.options, e);
    var p,
        c,
        u,
        g,
        f,
        b,
        m,
        k,
        v = this.options;
    if (v.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent), v.isMobile) for (var h in v.mobile) {
      v[h] = v.mobile[h];
    }
    if (this.strings = v.strings, v.pageShininess = v.pageShininess / 2, this.s = 0, v.googleAnalyticsTrackingCode && (this.gaCode = v.googleAnalyticsTrackingCode, T.ga || (c = y, u = "script", g = "ga", (p = T).GoogleAnalyticsObject = g, p.ga = p.ga || function () {
      (p.ga.q = p.ga.q || []).push(arguments);
    }, p.ga.l = +new Date(), f = c.createElement(u), b = c.getElementsByTagName(u)[0], f.async = 1, f.src = "https://www.google-analytics.com/analytics.js", b.parentNode.insertBefore(f, b)), ga("create", this.gaCode, "auto")), v.isMobile && (v.singlePageMode = !!v.singlePageModeIfMobile || v.singlePageMode, v.viewModeMobile && (v.viewMode = v.viewModeMobile), v.pageTextureSizeMobile && (v.pageTextureSize = v.pageTextureSizeMobile), v.pageTextureSizeMobileSmall && (v.pageTextureSizeSmall = v.pageTextureSizeMobileSmall)), "3dSinglePage" == v.viewMode && (v.singlePageMode = !0), "2dSinglePage" == v.viewMode && (v.singlePageMode = !0, v.viewMode = "2d"), v.singlePageMode && ("2d" != v.viewMode && "swipe" != v.viewMode && (v.viewMode = "3d"), v.rightToLeft && (v.viewMode = "swipe")), v.singlePageMode && "3d" == v.viewMode && (v.rightToLeft = !1), "simple" == v.viewMode && (v.viewMode = "3d", v.instantFlip = !0), "webgl" == v.viewMode && (!this.hasWebGl || parseFloat(!!(k = (m = (m || navigator.userAgent).toLowerCase()).match(/android\s([0-9\.]*)/)) && k[1]) < v.minimumAndroidVersion && this.isAndroid) && (v.viewMode = "3d"), "3d" != v.viewMode || n.has3d || (v.viewMode = "2d"), this.webgl = "webgl" == v.viewMode, v.menuFloating && (v.menuOverBook = !0, v.sideMenuOverMenu = !0), v.menu2Floating && (v.menu2OverBook = !0, v.sideMenuOverMenu2 = !0), v.menuTransparent && (v.menuOverBook = !0, v.sideMenuOverMenu = !0, v.menuBackground = "none"), v.menu2Transparent ? (v.menu2OverBook = !0, v.sideMenuOverMenu2 = !0, v.menu2Background = "none") : v.sideMenuOverMenu2 = !1, v.menuOverBook && (v.sideMenuOverMenu = !0), v.menu2OverBook && (v.sideMenuOverMenu2 = !0), v.isMobile && v.pdfBrowserViewerIfMobile && v.pdfUrl) v.lightBox && !v.lightBoxOpened ? this.$elem.on("touched click", function () {
      P();
    }).css("cursor", "pointer") : P();else if (v.isIE && v.pdfBrowserViewerIfIE && v.pdfUrl) v.lightBox && !v.lightBoxOpened ? this.$elem.on("touched click", function () {
      P();
    }).css("cursor", "pointer") : P();else {
      v.pdfMode = Boolean(v.pdfUrl && "" != v.pdfUrl), v.backgroundTransparent && (v.backgroundColor = "none"), this.wrapper = O(y.createElement("div")).addClass("flipbook-main-wrapper"), "" != v.backgroundColor && this.wrapper.css("background", v.backgroundColor), "" != v.backgroundPattern && this.wrapper.css("background", "url(" + v.backgroundPattern + ") repeat"), "" != v.backgroundImage && (this.wrapper.css("background", "url(" + v.backgroundImage + ") no-repeat"), this.wrapper.css("background-size", "cover"), this.wrapper.css("background-position", "center center")), this.bookLayer = O(y.createElement("div")).addClass("flipbook-bookLayer").appendTo(n.wrapper), v.hideMenu && (this.bookLayer.css("bottom", "0"), v.menuOverBook = !0), this.book = O(y.createElement("div")).addClass("book").appendTo(n.bookLayer), v.preloader ? this.preloader = v.preloader : !O(".flipbook-preloader").length && v.lightBox ? this.preloader = O('<div class="flipbook-preloader cssload-container"><div class="cssload-speeding-wheel"/><div class="flipbook-loading-text"></div><div class="flipbook-loading-bg"></div></div>') : v.lightBox ? this.preloader = O(".flipbook-preloader") : this.preloader = O('<div class="flipbook-preloader-2 cssload-container"><div class="cssload-speeding-wheel"/><div class="flipbook-loading-text"></div><div class="flipbook-loading-bg"></div></div>'), O(".flipbook-loading-text").text(v.preloaderText), this.setLoadingProgress(0), !v.deeplinkingPrefix && v.deeplinking && v.deeplinking.prefix && (v.deeplinkingPrefix = v.deeplinking.prefix), v.deeplinkingEnabled = v.deeplinkingPrefix || v.deeplinkingEnabled || v.deeplinking && v.deeplinking.enabled, v.deeplinkingEnabled && (S(), O(T).bind("hashchange", function (e) {
        S();
      })), this.dispose = function () {
        this.disposed = !0;
      }, v.main = this;
      var w = {
        _events: {},
        on: function on(e, t) {
          this._events[e] || (this._events[e] = []), this._events[e].push(t);
        },
        off: function off(e, t) {
          if (this._events[e]) {
            var o = this._events[e].indexOf(t);

            -1 < o && this._events[e].splice(o, 1);
          }
        },
        trigger: function trigger(e) {
          if (this._events[e]) {
            var t = 0,
                o = this._events[e].length;
            if (o) for (; t < o; t++) {
              this._events[e][t].apply(this, [].slice.call(arguments, 1));
            }
          }
        }
      };
      w.on("pageLoaded", function (e) {
        v.pages[e.index] = v.pages[e.index] || {}, v.pages[e.index].canvas = v.pages[e.index].canvas || {}, v.pages[e.index].canvas[e.size] = e.canvas, n.searchingString && n.mark(n.searchingString);
      }), w.on("pageUnloaded", function (e) {
        e.unloadedPages.forEach(function (e) {
          n.Book.onPageUnloaded && n.Book.onPageUnloaded(e.index, e.size);
        });
      }), w.on("pdfinit", function () {
        v.tableOfContent = n.pdfService.outline || v.tableOfContent, v.doublePage = n.pdfService["double"], n.viewportOriginal = n.pdfService.viewports[0], v.firstPage = {
          width: n.pdfService.viewports[0].width,
          height: n.pdfService.viewports[0].height,
          ratio: n.pdfService.viewports[0].width / n.pdfService.viewports[0].height
        }, 1 < n.pdfService.numPages && (v.secondPage = {
          width: n.pdfService.viewports[1].width,
          height: n.pdfService.viewports[1].height,
          ratio: n.pdfService.viewports[1].width / n.pdfService.viewports[1].height
        }), v.numPages = n.pdfService.numPages, 1 == v.numPages && (v.viewMode = "swipe", v.singlePageMode = !0, v.btnNext.enabled = !1, v.btnPrev.enabled = !1, v.btnFirst.enabled = !1, v.btnLast.enabled = !1, v.sideNavigationButtons = !1, v.btnAutoplay.enabled = !1, v.printMenu = !1, v.downloadMenu = !1, n.webgl = !1);

        for (var e = [], t = 0; t < v.numPages; t++) {
          var o = {
            canvas: {}
          };
          v.pages && v.pages[t] ? O.extend(o, v.pages[t]) : o.title = t + 1, e[t] = o;
        }

        v.pages = e;
        n.book.height();
        var i = v.pageTextureSize;
        v.pageWidth = parseInt(i * n.viewportOriginal.width / n.viewportOriginal.height), v.pageHeight = i, v.pw = v.pageWidth, v.ph = v.pageHeight, v.zoomSize = v.zoomSize || v.pageTextureSize, n.start();
      }), w.on("toolSelect", function () {
        n.bookLayer.removeClass("flipbook-move"), n.btnSelect && n.btnSelect.addClass("flipbook-btn-active"), O(".flipbook-page-htmlContent").css("userSelect", "auto");
      }), w.on("toolMove", function () {
        n.bookLayer.addClass("flipbook-move"), n.btnSelect && n.btnSelect.removeClass("flipbook-btn-active"), O(".flipbook-page-htmlContent").css("userSelect", "none");
      }), this.model = w, v.lightBox ? (v.btnClose.enabled = !0, this.lightbox = new FLIPBOOK.Lightbox(this, this.wrapper, v), this.lightboxStartedTimes = 0, this.wrapper.css("background", "none"), this.bookLayer.css("background", "none"), this.book.css("background", "none"), this.preloader.appendTo(this.$body).css("position", "fixed"), this.$elem.css("cursor", "pointer").bind("tap click", function (e) {
        n.lightboxStartPage = O(this).attr("data-page"), n.started ? (n.lightboxStart(), v.lightBoxFullscreen && setTimeout(function () {
          n.toggleExpand();
        }, 0)) : (B(), v.lightBoxFullscreen && setTimeout(function () {
          n.toggleExpand();
        }, 100));
      }), v.lightBoxOpened ? (B(), O(this).trigger("lightboxLoadingStarted")) : v.lightboxPreload && ("undefined" != typeof IScroll || FLIPBOOK.scriptsAdded[FLIPBOOK.iscrollSrc] || n.loadScript(FLIPBOOK.iscrollSrc, function () {}), void 0 !== FLIPBOOK.PdfService || FLIPBOOK.scriptsAdded[FLIPBOOK.pdfServiceSrc] || n.loadScript(FLIPBOOK.pdfServiceSrc, function () {}), v.pdfMode && ("undefined" != typeof pdfjsLib || FLIPBOOK.scriptsAdded[FLIPBOOK.pdfjsSrc] || n.loadScript(FLIPBOOK.pdfjsSrc, function () {}), void 0 !== FLIPBOOK.PdfService || FLIPBOOK.scriptsAdded[FLIPBOOK.pdfServiceSrc] || n.loadScript(FLIPBOOK.pdfServiceSrc, function () {}), v.btnSearch.enabled && (FLIPBOOK.scriptsAdded[FLIPBOOK.markSrc] || n.loadScript(FLIPBOOK.markSrc, function () {}))), "webgl" == v.viewMode && ("undefined" != typeof THREE || FLIPBOOK.scriptsAdded[FLIPBOOK.threejsSrc] || n.loadScript(FLIPBOOK.threejsSrc, function () {}))), this.fullscreenElement = y.documentElement) : (v.btnClose.enabled = !1, this.preloader.appendTo(this.wrapper), this.wrapper.appendTo(this.$elem), this.fullscreenElement = this.$elem[0], B());
    }

    function P() {
      v.pdfBrowserViewerFullscreen ? T.open(v.pdfUrl, v.pdfBrowserViewerFullscreenTarget) : O('<object type="application/pdf"/>').width("100%").height("100%").attr("data", v.pdfUrl).appendTo(n.$elem);
    }

    function S() {
      if (!n.disposed) {
        var e = T.location.hash,
            t = n.getPageFromHash(),
            o = t;
        t && (t = v.rightToLeft ? v.pages.length - t + 1 : t, n.started ? n.Book && (n.lightbox && (n.lightbox.openLightbox(), n.lightboxStart()), n.goToPage(t, -1 == e.indexOf("flip"))) : (v.startPage = o, v.lightBox && (B(), v.lightBoxFullscreen && setTimeout(function () {
          n.toggleExpand();
        }, 100))));
      }
    }

    function B() {
      if (v.fillPreloader.enabled) {
        n.$fillPreloader = O("<div>").addClass("flipbook-fillPreloader");
        var t = new Image();
        t.src = v.fillPreloader.imgEmpty, t.onload = function () {
          var e = new Image();
          e.src = v.fillPreloader.imgFull, e.onload = function () {
            O(t).appendTo(n.$fillPreloader), n.$fillPreloaderImg = O(e).appendTo(n.$fillPreloader), n.$fillPreloader.appendTo(n.wrapper), x();
          };
        };
      } else x();
    }

    function x() {
      n.id = Date.now(), n.addPageItems(), v.pdfMode ? n.initPdf() : (v.btnSearch.enabled = !1, n.initJpg()), n.setLoadingProgress(.1), n.lightbox && n.options.lightboxShowMenu && n.createMenu();
    }
  }, FLIPBOOK.Main.prototype = {
    start: function start() {
      this.options.dp && (this.options.doublePage = !0), this.started || (this.model.pageW = this.options.pageWidth, this.model.bookW = 2 * this.options.pageWidth, this.options.singlePageMode && (this.model.bookW /= 2), this.model.pageH = this.options.pageHeight, this.model.bookH = this.options.pageHeight, this.options.numPages % 2 == 0 ? this.options.numSheets = (this.options.numPages + 2) / 2 : this.options.numSheets = (this.options.numPages + 1) / 2, this.started = !0, this.options.lightBox && (this.lightbox.openLightbox(), this.lightboxStart()), this.createBook(), this.updateSkinColors());
    },
    updateSkinColors: function updateSkinColors() {
      var e = this.options;
      e.skinColor && this.wrapper.find(".skin-color").css("color", e.skinColor), e.skinBackground && this.wrapper.find(".skin-color-bg").css("background", e.skinBackground);
    },
    lightboxStart: function lightboxStart() {
      var e = this;
      this.started || this.start(), void 0 !== this.Book ? (this.Book.enable(), this.lightboxStartPage ? this.goToPage(this.lightboxStartPage, !0) : this.options.lightboxStartPage && this.goToPage(this.options.lightboxStartPage, !0), this.lightboxStartedTimes++, this.gaCode && ga("send", {
        hitType: "event",
        eventCategory: "Flipbook : " + this.options.name,
        eventAction: "lightbox open",
        eventLabel: "lightbox open",
        eventValue: this.lightboxStartedTimes,
        nonInteraction: !0
      }), this.updateCurrentPage(), this.initColors(), this.resize(), O(this).trigger("lightboxOpened")) : setTimeout(function () {
        e.lightboxStart();
      }, 100);
    },
    setHash: function setHash(e) {
      e < 1 && (e = 1), this.options.deeplinkingEnabled && this.Book.enabled && (T.location.hash = "#" + this.options.deeplinkingPrefix + String(e));
    },
    clearHash: function clearHash() {
      var e,
          t,
          o = T.location;
      "pushState" in history ? history.pushState("", y.title, o.pathname + o.search) : (e = y.body.scrollTop, t = y.body.scrollLeft, o.hash = "", y.body.scrollTop = e, y.body.scrollLeft = t);
    },
    getPageFromHash: function getPageFromHash() {
      var e = null,
          t = T.location.hash,
          o = "#" + this.options.deeplinkingPrefix;
      return -1 !== t.indexOf(o) && (e = parseInt(T.location.hash.replace(/#/g, "").replace(this.options.deeplinkingPrefix, "")), isNaN(e) && (e = 0)), e;
    },
    initColors: function initColors() {
      this.wrapper.find(".skin-color-bg").removeClass("flipbook-bg-light").removeClass("flipbook-bg-dark").addClass("flipbook-bg-" + this.options.skin), this.wrapper.find(".skin-color").removeClass("flipbook-color-light").removeClass("flipbook-color-dark").addClass("flipbook-color-" + this.options.skin), this.updateSkinColors();
    },
    lightboxEnd: function lightboxEnd() {
      "undefined" != typeof screenfull && screenfull.isFullscreen && screenfull.exit(), T.location.hash && this.clearHash(), this.setLoadingProgress(1), this.Book.disable();
    },
    turnPageComplete: function turnPageComplete() {
      this.animating = !1, this.updateCurrentPage();
      var e = this.Book.rightIndex || 0;
      this.options.rightToLeft && (e = this.options.pages.length - e), this.pdfService && this.pdfService.setRightIndex(e), this.options.zoomReset && this.Book.zoomTo(this.options.zoomMin);
    },
    updateCurrentPage: function updateCurrentPage() {
      var e,
          t = this.options.rightToLeft,
          o = this.options.numPages,
          i = this.Book.rightIndex || 0;
      t && (i = this.options.pages.length - i), this.options.singlePageMode || this.Book.singlePage ? (t && i--, e = i + 1, this.currentPageNumber = i, this.setHash(e), this.cPage = [i]) : (o < i || i == o && o % 2 == 0 ? (e = o, this.cPage = [o - 1]) : i < 1 ? (e = 1, this.cPage = [0]) : (e = String(i) + "-" + String(i + 1), this.cPage = [i - 1, i]), this.setHash(i)), t ? (this.enableNext(0 < i), this.enablePrev(i < o - 1)) : (this.enablePrev(0 < i), this.enableNext(i < o - 1)), 2 == this.cPage.length ? (this.wrapper.find(".c-l-p").show(), this.wrapper.find(".c-r-p").show(), this.wrapper.find(".c-p").hide()) : (this.wrapper.find(".c-l-p").hide(), this.wrapper.find(".c-r-p").hide(), this.wrapper.find(".c-p").show()), void 0 !== this.currentPage && (this.s && 0 < this.options.pdfPageScale && this.goToPage(0), e != this.currentPageValue && (this.currentPageValue = String(e), this.currentPage.text(e + " / " + String(o)), this.currentPageInput.width(this.currentPageHolder.width()), this.resize(), O(this).trigger({
        type: "pagechange",
        page: this.currentPageValue,
        name: this.options.name
      })));
    },
    initJpg: function initJpg() {
      var n = this;
      1 == this.options.numPages && (this.options.viewMode = "swipe", this.options.singlePageMode = !0, this.webgl = !1), this.loadPage(0, this.options.pageTextureSize, function () {
        if (n.setLoadingProgress(.5), 1 == n.options.pages.length) {
          var e = n.options.pages[0].img;
          n.options.pw = e.width, n.options.ph = e.height, n.options.pageWidth = e.width, n.options.pageHeight = e.height, n.options.pageMode = "singlePage", n.options.doublePage = !1, n.options.zoomSize = n.options.zoomSize || e.height, n.setLoadingProgress(.7), n.options.btnNext.enabled = !1, n.options.btnPrev.enabled = !1, n.options.btnFirst.enabled = !1, n.options.btnLast.enabled = !1, n.options.sideNavigationButtons = !1, n.options.btnAutoplay.enabled = !1, n.start();
        } else n.loadPage(1, n.options.pageTextureSize, function () {
          var e = n.options.pages[0].img,
              t = n.options.pages[1].img,
              o = e.width / e.height,
              i = t.width / t.height;
          n.options.pw = e.width, n.options.ph = e.height, n.options.pageWidth = e.width, n.options.pageHeight = e.height, n.options.doublePage = 1.5 < i / o, n.options.zoomSize = n.options.zoomSize || e.height, n.setLoadingProgress(.7), n.start();
        });
      });
    },
    initPdf: function initPdf() {
      if (!this.started) {
        ("swipe" == this.options.viewMode || this.options.btnSearch && this.options.btnSearch.enabled) && (this.options.textLayer = !0), this.options.textLayer = !0;
        var t = this;

        if ("undefined" == typeof pdfjsLib) {
          if (!FLIPBOOK.scriptsAdded[FLIPBOOK.pdfjsSrc]) return void t.loadScript(FLIPBOOK.pdfjsSrc, function () {
            t.initPdf();
          });
          if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.pdfjsSrc]) return void setTimeout(function () {
            t.initPdf();
          }, 100);
        }

        if (this.setLoadingProgress(.2), void 0 === FLIPBOOK.PdfService) {
          if (!FLIPBOOK.scriptsAdded[FLIPBOOK.pdfServiceSrc]) return void t.loadScript(FLIPBOOK.pdfServiceSrc, function () {
            t.initPdf();
          });
          if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.pdfServiceSrc]) return void setTimeout(function () {
            t.initPdf();
          }, 100);
        }

        this.setLoadingProgress(.3), T.CanvasPixelArray && (CanvasPixelArray.prototype.set = function (e) {
          for (var t = this.length, o = 0; o < t; o++) {
            this[o] = e[o];
          }
        }), PDFJS = pdfjsLib, pdfjsLib.externalLinkTarget = pdfjsLib.LinkTarget.BLANK, pdfjsLib.GlobalWorkerOptions.workerSrc = this.options.pdfjsworkerSrc || FLIPBOOK.pdfjsworkerSrc, "https:" == location.protocol ? t.options.pdfUrl = t.options.pdfUrl.replace("http://", "https://") : "http:" == location.protocol && (t.options.pdfUrl = t.options.pdfUrl.replace("https://", "http://"));
        var e = {
          cMapPacked: !0,
          cMapUrl: "cmaps/",
          disableAutoFetch: !0,
          disableStream: !0,
          url: t.options.pdfUrl,
          rangeChunkSize: 1024 * Number(t.options.rangeChunkSize)
        };
        if (!this.pdfinitStarted) this.pdfinitStarted = !0, pdfjsLib.getDocument(e).promise.then(function (e) {
          t.pdfDocument = e, t.pdfService = new FLIPBOOK.PdfService(e, t.model, t.options), t.options.thumbLoaded = function (e) {
            t.options.thumbs = t.options.thumbs || [], t.options.thumbs[e.index] = e;
          }, t.setLoadingProgress(.5), t.pdfService.init();
        }, function (e) {
          alert(e);
        });
      }
    },
    loadPageHTML: function loadPageHTML(i, n) {
      var s = this,
          a = (i = i, this.options);
      this.options.pdfMode ? this.pdfService.loadTextLayer(i, function (e) {
        n.call(s, s.options.pages[i].htmlContent);
      }) : a.pages[i].json ? this.loadPageJSON(i, function (e) {
        var t = a.pages[i] || {};

        if (!t.htmlContentInitialized) {
          var o = y.createElement("div");
          o.classList.add("flipbook-page-htmlContent"), o.classList.add("page" + String(i)), o.innerHTML = decodeURIComponent(e.data), t.htmlContent && O(o).append(O(t.htmlContent)), t.htmlContent = o, O(t.htmlContent).find(".internalLink").each(function () {
            var t = s;

            this.onclick = function () {
              var e = Number(this.dataset.page);
              return e = t.options.rightToLeft ? t.options.pages.length - e + 1 : e, t.goToPage(e), !1;
            };
          }), t.htmlContentInitialized = !0;
        }

        n.call(s, t.htmlContent);
      }) : n.call(this, a.pages[i].htmlContent);
    },
    loadPageJSON: function loadPageJSON(e, t) {
      var o = this.options.pages[e] || {},
          i = this;
      if (!o.jsonLoading && !o.jsonLoaded) return o.jsonLoading = !0, void O.getJSON(o.json, function (e) {
        o.jsonLoaded = !0, o.jsonLoading = !1, t.call(i, e);
      });
      o.jsonLoaded ? t.call(i) : setTimeout(function () {
        i.loadPageJSON(e, t);
      }, 100);
    },
    loadPage: function loadPage(e, t, o) {
      var i = this,
          n = this.options.pages && this.options.pages[e] && this.options.pages[e].src;
      if (this.options.pdfMode && !n) this.loadPageFromPdf(e, t, o);else {
        i = this;
        var s = this.options.pages[e];
        s.img ? s.imgLoaded ? i.pageLoaded({
          index: e,
          size: t,
          image: s.img,
          htmlContent: s.htmlContentDiv
        }, o) : setTimeout(function () {
          i.loadPage(e, t, o);
        }, 300) : (s.img = y.createElement("img"), s.img.setAttribute("id", e), s.img.onload = function () {
          s.imgLoaded = !0, s.htmlContent && (s.htmlContentDiv = O(y.createElement("div")).addClass("flipbook-page-htmlContent").append(O(s.htmlContent))), i.pageLoaded({
            index: e,
            size: t,
            image: s.img,
            htmlContent: s.htmlContentDiv
          }, o);
        }, "webgl" == this.options.viewMode && (s.img.crossOrigin = "Anonymous"), "https:" == location.protocol ? s.src = s.src.replace("http://", "https://") : "http:" == location.protocol && (s.src = s.src.replace("https://", "http://")), s.img.src = s.src);
      }
    },
    pageLoaded: function pageLoaded(e, t) {
      t.call(this, e, t), this.options.loadAllPages && e.index < this.options.numPages - 1 && this.loadPage(e.index + 1, e.size, function () {});
    },
    loadPageFromPdf: function loadPageFromPdf(e, t, o) {
      t = t || this.options.pageTextureSize, this.options.pages[e] ? this.pdfService.renderBookPage(e, t, o) : o.call(this);
    },
    getString: function getString(e) {
      return this.options.strings[e];
    },
    mark: function mark(e) {
      var t = O(".flipbook-page-htmlContent");
      t.unmark({
        done: function done() {
          t.mark(e, {
            acrossElements: !0,
            separateWordSearch: !1
          });
        }
      });
    },
    unmark: function unmark() {
      this.searchingString = null, O(".flipbook-page-htmlContent").unmark();
    },
    setTool: function setTool(e) {
      this.tool = e, this.model.trigger(e);
    },
    toggleTool: function toggleTool() {
      var e = "toolSelect" == this.tool ? "toolMove" : "toolSelect";
      this.setTool(e);
    },
    toggleSound: function toggleSound() {
      var e = this.options;
      e.sound ? (e.sound = !1, this.btnSound.$icon.hide(), this.btnSound.$iconAlt.show()) : (e.sound = !0, this.btnSound.$icon.show(), this.btnSound.$iconAlt.hide());
    },
    scrollPageIntoView: function scrollPageIntoView(e) {
      var t = this.options.rightToLeft ? this.options.pages.length - e.pageNumber + 1 : e.pageNumber;
      this.goToPage(t);
    },
    loadScript: function loadScript(o, i) {
      var n = this,
          s = y.createElement("script"),
          e = y.getElementsByTagName("script")[0];
      s.async = 1, e.parentNode.insertBefore(s, e), FLIPBOOK.scriptsAdded[o] = !0, s.onload = s.onreadystatechange = function (e, t) {
        !t && s.readyState && !/loaded|complete/.test(s.readyState) || (s.onload = s.onreadystatechange = null, s = a, t || i && i.call(n), FLIPBOOK.scriptsLoaded[o] = !0);
      }, s.src = o;
    },
    createBook: function createBook() {
      var n = this,
          e = this.model,
          t = this.options;

      if ("material" != t.icons || FLIPBOOK.MaterialIconsLoaded || (FLIPBOOK.MaterialIconsLoaded = !0, O("head").append('<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">')), "undefined" == typeof IScroll) {
        if (!FLIPBOOK.scriptsAdded[FLIPBOOK.iscrollSrc]) return void n.loadScript(FLIPBOOK.iscrollSrc, n.createBook);
        if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.iscrollSrc]) return void setTimeout(function () {
          n.createBook();
        }, 100);
      }

      if (this.options.searchOnStart && (this.options.btnSearch.enabled = !0), this.options.pdfUrl && this.options.btnSearch.enabled) {
        if (!FLIPBOOK.scriptsAdded[FLIPBOOK.markSrc]) return void n.loadScript(FLIPBOOK.markSrc, n.createBook);
        if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.markSrc]) return void setTimeout(function () {
          n.createBook();
        }, 100);
      }

      if (n.setLoadingProgress(.9), "webgl" == n.options.viewMode) {
        if ("undefined" == typeof THREE) {
          if (!FLIPBOOK.scriptsAdded[FLIPBOOK.threejsSrc]) return void n.loadScript(FLIPBOOK.threejsSrc, n.createBook);
          if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.threejsSrc]) return void setTimeout(function () {
            n.createBook();
          }, 100);
        }

        if (void 0 === FLIPBOOK.BookWebGL) {
          if (!FLIPBOOK.scriptsAdded[FLIPBOOK.flipbookWebGlSrc]) return void n.loadScript(FLIPBOOK.flipbookWebGlSrc, n.createBook);
          if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.flipbookWebGlSrc]) return void setTimeout(function () {
            n.createBook();
          }, 100);
        }
      } else if ("swipe" == n.options.viewMode) {
        if (void 0 === FLIPBOOK.BookSwipe) {
          if (!FLIPBOOK.scriptsAdded[FLIPBOOK.flipBookSwipeSrc]) return void n.loadScript(FLIPBOOK.flipBookSwipeSrc, n.createBook);
          if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.flipBookSwipeSrc]) return void setTimeout(function () {
            n.createBook();
          }, 100);
        }
      } else if (void 0 === FLIPBOOK.Book3) {
        if (!FLIPBOOK.scriptsLoaded[FLIPBOOK.flipbookBook3Src]) return void n.loadScript(FLIPBOOK.flipbookBook3Src, n.createBook);
        if (!FLIPBOOK.scriptsAdded[FLIPBOOK.flipbookBook3Src]) return void setTimeout(function () {
          n.createBook();
        }, 100);
      }

      if (this.setLoadingProgress(1), this.initEasing(), n.options.doublePage && 2 < n.options.pages.length) {
        for (var o = [n.options.pages[0]], i = 1; i <= n.options.pages.length - 2; i++) {
          var s = n.options.pages[i],
              a = {
            src: s.src,
            thumb: s.thumb,
            title: s.title,
            htmlContent: s.htmlContent,
            json: s.json,
            side: "left"
          },
              r = {
            src: s.src,
            thumb: s.thumb,
            title: s.title,
            htmlContent: s.htmlContent,
            json: s.json,
            side: "right"
          };
          o.push(a), o.push(r);
        }

        o.push(n.options.pages[n.options.pages.length - 1]), n.options.pages = o;
      }

      if (this.options.numPages = this.options.pages.length, this.options.numPages % 2 == 0 || this.options.singlePageMode || (this.oddPages = !0, this.options.oddPages = !0, this.options.pages.push({
        src: this.options.assets.preloader,
        empty: !0
      })), 0 < n.options.pages.length) for (i = 0; i < n.options.pages.length; i++) {
        void 0 !== n.options.pages[i].htmlContent && (n.options.hasHtmlContent = !0, n.options.pages[i].htmlContent = O(n.options.pages[i].htmlContent));
      }

      function l() {
        n.flipsound = y.createElement("audio"), n.flipsound.setAttribute("src", n.options.assets.flipMp3), n.flipsound.setAttribute("type", "audio/mpeg");
      }

      if ("webgl" == n.options.viewMode) {
        var d = n.options;
        d.scroll = n.scroll, (d.parent = n).Book = new FLIPBOOK.BookWebGL(n.book[0], e, d), n.webglMode = !0, n.initSwipe(), l();
      } else "swipe" == n.options.viewMode ? (n.Book = new FLIPBOOK.BookSwipe(n.book[0], n.bookLayer[0], e, t), n.initSwipe()) : ("2d" != n.options.viewMode && (n.options.viewMode = "3d"), n.Book = new FLIPBOOK.Book3(n.book[0], e, t), n.initSwipe(), n.webglMode = !1, l());

      n.Book.enable(), n.book.hide().fadeIn("slow"), this.tocCreated = !1, this.createMenu(), this.onZoom(this.options.zoom), 1 == this.options.pages.length && (this.rightToLeft = !1), FLIPBOOK.books = FLIPBOOK.books || {}, FLIPBOOK.books[n.id] = n.Book;
      var h = O(n.Book);
      h.bind("loadPagesFromPdf", function (e, t, o, i) {
        n.loadPagesFromPdf(t, o, i);
      }), h.bind("turnPageComplete", function (e) {
        n.turnPageComplete();
      }), h.bind("initEasing", function (e) {
        n.initEasing();
      }), h.bind("playFlipSound", function (e) {
        n.playFlipSound();
      }), h.bind("closeLightbox", function (e) {
        n.closeLightbox();
      }), h.bind("updateCurrentPage", function (e) {
        n.updateCurrentPage();
      }), this.createLogo(), this.onBookCreated();
    },
    addPageItems: function addPageItems() {
      var e = this.options.pages;
      this.id;

      for (var t in e) {
        var o = e[t];
        if (o.htmlContent = o.htmlContent || "", o.items) for (var i in o.items) {
          var n = o.items[i];

          switch (n.type) {
            case "iframe":
              a = '<iframe src="' + n.src + '" width="' + n.width + '" height="' + n.height + '" style="position:absolute;top:' + n.y + "px;left:" + n.x + 'px;bottom:auto;right:auto;" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>', o.htmlContent += a;
              break;

            case "image":
              a = '<img src="' + n.src + '" style="position:absolute;top:' + n.y + "px;left:" + n.x + "px;width:" + n.width + "px;height:" + n.height + 'px;bottom:auto;right:auto;">', o.htmlContent += a;
              break;

            case "link":
              if (a = O("<a>").addClass("flipbook-page-item").width(n.width).height(n.height).css({
                top: n.y + "px",
                left: n.x + "px",
                background: this.options.linkColor
              }).attr("onmouseover", 'this.style.background="' + this.options.linkColorHover + '"').attr("onmouseout", 'this.style.background="' + this.options.linkColor + '"'), n.url) a.attr("href", n.url).attr("target", "_blank");else if (n.page) {
                var s = "#" + this.options.deeplinkingPrefix + n.page;
                n.flip && (s += "flip"), a.attr("href", s);
              }
              o.htmlContent += a[0].outerHTML;
              break;

            case "video":
              var a = O("<video>").addClass("flipbook-page-item");
              n.width && a.attr("width", n.width), n.height && a.attr("height", n.height), n.x && a.css("left", n.x + "px"), n.y && a.css("top", n.y + "px"), n.controls && a.prop("controls", "true"), n.autoplay && a.prop("autoplay", "true");
              O('<source type="video/mp4">').attr("src", n.src).appendTo(a);
              o.htmlContent += a[0].outerHTML;
          }
        }
      }
    },
    onBookCreated: function onBookCreated() {
      var e = this.options,
          t = this;
      e.rightToLeft ? t.goToPage(Number(e.pages.length - Number(e.startPage) + 1), !0) : t.goToPage(Number(e.startPage), !0), O(T).resize(function () {
        t.resize();
      }), t.resize(), t.Book.updateVisiblePages(), t.Book.zoomTo(e.zoomMin), this.updateCurrentPage(), y.addEventListener("keydown", function (e) {
        if (t.Book.enabled) {
          if (!t.options.arrowsAlwaysEnabledForNavigation || 37 != e.keyCode && 39 != e.keyCode) {
            if (!t.options.lightBox && !t.fullscreenActive && (t.options.arrowsDisabledNotFullscreen || t.bodyHasVerticalScrollbar())) return;
          } else ;

          switch ((e = e || T.event).keyCode) {
            case 37:
              t.prevPage();
              break;

            case 38:
              t.zoomIn();
              break;

            case 39:
              t.nextPage();
              break;

            case 40:
              t.zoomOut();
          }

          return !1;
        }
      }), y.addEventListener("MSFullscreenChange", function (e) {
        t.handleFsChange();
      }), y.addEventListener("mozfullscreenchange", function (e) {
        t.handleFsChange();
      }), y.addEventListener("webkitfullscreenchange", function (e) {
        t.handleFsChange();
      }), y.addEventListener("fullscreenchange", function (e) {
        t.handleFsChange();
      }), this.zoom = e.zoomMin, this.bookLayer.bind("DOMMouseScroll", function (e) {
        if (t.Book.enabled && (t.options.lightBox || t.fullscreenActive || !t.options.wheelDisabledNotFullscreen && !t.bodyHasVerticalScrollbar())) return e.stopPropagation(), e.preventDefault(), 0 < e.originalEvent.detail ? t.zoomOut(e.originalEvent) : t.zoomIn(e.originalEvent), !1;
      }), this.bookLayer.bind("mousewheel", function (e) {
        if (t.Book.enabled && (t.options.lightBox || t.fullscreenActive || !t.options.wheelDisabledNotFullscreen && !t.bodyHasVerticalScrollbar())) return e.stopPropagation(), e.preventDefault(), e.originalEvent.wheelDelta < 0 ? t.zoomOut(e.originalEvent) : t.zoomIn(e.originalEvent), !1;
      }), this.setTool("toolMove"), t.options.contentOnStart ? t.toggleToc(!0) : t.options.thumbnailsOnStart ? t.toggleThumbs(!0) : t.options.searchOnStart && (t.toggleSearch(!0), "string" == typeof t.options.searchOnStart && t.thumbs.$findInput.val(t.options.searchOnStart).trigger("keyup")), e.autoplayOnStart && t.toggleAutoplay(!0), t.options.lightBox && t.Book.disable(), t.initColors(), setTimeout(function () {
        t.resize(), t.Book.updateVisiblePages(), t.Book.zoomTo(e.zoomMin);
      }, 500), e.onbookcreated && e.onbookcreated.call(this);
    },
    initSwipe: function initSwipe() {
      if (1 != this.options.numPages) {
        var l = this;
        T.jQuery(this.bookLayer).swipe({
          swipeStatus: function swipeStatus(e, t, o, i, n, s, a) {
            if ("start" == t) try {
              l.currentPageInput.trigger("blur");
            } catch (e) {}
            if (!l.options.sideNavigationButtons || e.target !== l.arrowL[0] && e.target !== l.arrowR[0]) if (("end" == t || "cancel" == t) && n < 200 && i < 10) {
              if ("toolMove" == l.tool && !l.options.doubleClickZoomDisabled) if (null == l.clickTimer) l.clickTimer = setTimeout(function () {
                if (l.clickTimer = null, "touchend" == e.type) e.changedTouches[0].pageX;else if ("mouseup" == e.type) e.offsetX;
              }, 300);else {
                clearTimeout(l.clickTimer), l.clickTimer = null;
                var r = l.options.zoomTime;
                l.zoom >= l.options.zoomMax ? l.zoomTo(l.options.zoomMin, r, e) : l.zoomTo(l.options.zoomMax, r, e);
              }
            } else {
              if (("up" == o || "down" == o) && "move" == t || 1 < l.zoom || "toolSelect" == l.tool) return;
              l.Book.onSwipe(e, t, o, i, n, s, a);
            }
          },
          pinchStatus: function pinchStatus(e, t, o, i, n, s, a) {
            "start" == t && (l.zoomStart = l.zoom), 1 < s && "move" == t && (e.preventDefault(), e.scale && (a = e.scale), l.zoomTo(l.zoomStart * a, 0, e));
          },
          fingers: 2,
          pinchThreshold: 0,
          allowPageScroll: "vertical",
          preventDefaultEvents: !1
        }), this.swipeEnabled = !0;
      }
    },
    toggleMenu: function toggleMenu() {
      this.menuShowing ? (this.menuShowing = !1, this.bookLayer.css("bottom", "0px"), this.menuBottom.fadeOut(), this.currentPageHolder.fadeOut(), O(".flipbook-nav").fadeOut()) : (this.menuShowing = !0, this.bookLayer.css("bottom", this.menuBottom.height() + "px"), this.menuBottom.fadeIn(), this.currentPageHolder.fadeIn(), O(".flipbook-nav").fadeIn()), this.Book.onResize();
    },
    createIcon: function createIcon(e, t, o) {
      var i;
      return i = "material" == this.options.icons ? O("<i>").addClass("material-icons flipbook-icon-material flipbook-menu-btn skin-color").attr("title", e.title).text(t ? e.iconAlt2 : e.icon2) : O(y.createElement("span")).attr("aria-hidden", "true").addClass(t ? e.iconAlt : e.icon).addClass("flipbook-icon-fa flipbook-menu-btn skin-color fa"), o || i.addClass("skin-color-bg"), i;
    },
    createButton: function createButton(t) {
      var o = this.options,
          e = "top" == t.vAlign && o.menu2Transparent || "top" != t.vAlign && o.menuTransparent,
          i = t.background || (e ? o.floatingBtnBackground : o.btnBackground),
          n = t.backgroundHover || (e ? o.floatingBtnBackgroundHover : o.btnBackgroundHover),
          s = t.color || (e ? o.floatingBtnColor : o.btnColor),
          a = t.colorHover || (e ? o.floatingBtnColorHover : o.btnColorHover),
          r = e ? o.floatingBtnTextShadow : o.btnTextShadow,
          l = t.radius || (e ? o.floatingBtnRadius : o.btnRadius),
          d = t.border || (e ? o.floatingBtnBorder : o.btnBorder),
          h = e ? o.floatingBtnMargin : o.btnMargin,
          p = O(y.createElement("span")),
          c = "material" == o.icons ? (t.size || o.btnSize) + 8 : t.size || o.btnSize,
          u = (t.size || o.btnSize) + 24;

      function g(e) {
        e.css(_defineProperty({
          width: u + "px",
          "font-size": c + "px",
          margin: h + "px",
          "border-radius": l + "px",
          "text-shadow": o.btnTextShadow,
          "box-shadow": o.btnShadow,
          border: d,
          color: s,
          background: i
        }, "text-shadow", r)), s && e.removeClass("skin-color"), i && e.removeClass("skin-color-bg");
      }

      p.$icon = this.createIcon(t).appendTo(p), g(p.$icon), t.iconAlt2 && (p.$iconAlt = this.createIcon(t, !0).appendTo(p).hide(), g(p.$iconAlt)), p.icon = t.icon, p.iconAlt = t.iconAlt, t.onclick && p.bind("tap click", function (e) {
        t.onclick();
      }), (a || n) && p.mouseenter(function () {
        p.$icon.css({
          color: a,
          background: n
        }), p.$iconAlt && p.$iconAlt.css({
          color: a,
          background: n
        });
      }).mouseleave(function () {
        p.$icon.css({
          color: s,
          background: i
        }), p.$iconAlt && p.$iconAlt.css({
          color: s,
          background: i
        });
      });
      var f;
      return f = "top" == t.vAlign ? o.menu2Floating ? this.menuTC : "left" == t.hAlign ? this.menuTL : "right" == t.hAlign ? this.menuTR : this.menuTC : o.menuFloating ? this.menuBC : "left" == t.hAlign ? this.menuBL : "right" == t.hAlign ? this.menuBR : this.menuBC, p.attr("data-name", t.name).appendTo(f).attr("title", t.title).addClass("").css("order", t.order), p;
    },
    createMenu: function createMenu() {
      if (!this.menuBottom) {
        var e = this.options,
            t = e.menuFloating ? "flipbook-menu-floating" : "flipbook-menu-fixed",
            o = e.menu2Floating ? "flipbook-menu-floating" : "flipbook-menu-fixed",
            i = this;
        this.menuBottom = O(y.createElement("div")).addClass("flipbook-menuBottom").addClass(t).appendTo(this.wrapper).css({
          background: e.menuBackground,
          "box-shadow": e.menuShadow,
          margin: e.menuMargin + "px",
          padding: e.menuPadding + "px"
        }), e.menuTransparent || e.menuBackground || this.menuBottom.addClass("skin-color-bg"), e.hideMenu && this.menuBottom.hide(), this.menuTop = O(y.createElement("div")).addClass("flipbook-menuTop").addClass(o).appendTo(this.wrapper).css({
          background: e.menu2Background,
          "box-shadow": e.menu2Shadow,
          margin: e.menu2Margin + "px",
          padding: e.menu2Padding + "px"
        }), e.menu2Transparent || e.menu2Background || this.menuTop.addClass("skin-color-bg"), "swipe" == e.viewMode && (e.btnSound.enabled = !1), this.menuBL = O(y.createElement("div")).addClass("flipbook-menu flipbook-menu-left").appendTo(this.menuBottom), this.menuBC = O(y.createElement("div")).addClass("flipbook-menu flipbook-menu-center").appendTo(this.menuBottom), this.menuBR = O(y.createElement("div")).addClass("flipbook-menu flipbook-menu-right").appendTo(this.menuBottom), this.menuTL = O(y.createElement("div")).addClass("flipbook-menu flipbook-menu-left").appendTo(this.menuTop), this.menuTC = O(y.createElement("div")).addClass("flipbook-menu flipbook-menu-center").appendTo(this.menuTop), this.menuTR = O(y.createElement("div")).addClass("flipbook-menu flipbook-menu-right").appendTo(this.menuTop), e.isMobile && (void 0 !== e.btnTocIfMobile && (e.btnToc.hideOnMobile = !e.btnTocIfMobile), void 0 !== e.btnThumbsIfMobile && (e.btnThumbs.hideOnMobile = !e.btnThumbsIfMobile), void 0 !== e.btnShareIfMobile && (e.btnShare.hideOnMobile = !e.btnShareIfMobile), void 0 !== e.btnDownloadPagesIfMobile && (e.btnDownloadPages.hideOnMobile = !e.btnDownloadPagesIfMobile), void 0 !== e.btnDownloadPdfIfMobile && (e.btnDownloadPdf.hideOnMobile = !e.btnDownloadPdfIfMobile), void 0 !== e.btnSoundIfMobile && (e.btnSound.hideOnMobile = !e.btnSoundIfMobile), void 0 !== e.btnExpandIfMobile && (e.btnExpand.hideOnMobile = !e.btnExpandIfMobile), void 0 !== e.btnPrintIfMobile && (e.btnPrint.hideOnMobile = !e.btnPrintIfMobile)), e.sideNavigationButtons && (this.btnNext = O('<div class="flipbook-nav"><div class="flipbook-arrow-wrapper"></div></div>').appendTo(this.bookLayer).bind("tap click", function (e) {
          i.btnNext.disabled || (i.btnNext.disabled = !0, setTimeout(function () {
            i.btnNext.disabled = !1;
          }, 300), e.stopPropagation(), e.preventDefault(), i.nextPage());
        }), this.arrowR = this.createIcon(e.btnNext).appendTo(this.btnNext.first()).addClass("flipbook-right-arrow").css({
          width: e.sideBtnSize + "px",
          height: e.sideBtnSize + "px",
          "font-size": e.sideBtnSize + "px",
          "border-radius": e.sideBtnRadius + "px",
          "margin-top": String(-e.sideBtnSize / 2) + "px",
          "margin-right": e.sideBtnMargin + "px",
          padding: e.sideBtnPaddingV + "px " + e.sideBtnPaddingH + "px",
          "text-shadow": e.sideBtnTextShadow,
          "box-shadow": e.sideBtnShadow,
          border: e.sideBtnBorder,
          color: e.sideBtnColor,
          background: e.sideBtnBackground,
          "box-sizing": "initial"
        }), e.sideBtnColor && this.arrowR.removeClass("skin-color"), e.sideBtnBackground && this.arrowR.removeClass("skin-color-bg"), this.btnPrev = O('<div class="flipbook-nav"><div class="flipbook-arrow-wrapper"></div></div>').appendTo(i.bookLayer).bind("tap click", function (e) {
          i.btnPrev.disabled || (i.btnPrev.disabled = !0, setTimeout(function () {
            i.btnPrev.disabled = !1;
          }, 300), e.stopPropagation(), e.preventDefault(), i.prevPage());
        }), this.arrowL = this.createIcon(e.btnPrev).appendTo(this.btnPrev.first()).addClass("flipbook-left-arrow").css({
          width: e.sideBtnSize + "px",
          height: e.sideBtnSize + "px",
          "font-size": e.sideBtnSize + "px",
          "border-radius": e.sideBtnRadius + "px",
          "margin-top": String(-e.sideBtnSize / 2) + "px",
          "margin-left": e.sideBtnMargin + "px",
          padding: e.sideBtnPaddingV + "px " + e.sideBtnPaddingH + "px",
          "text-shadow": e.sideBtnTextShadow,
          "box-shadow": e.sideBtnShadow,
          border: e.sideBtnBorder,
          color: e.sideBtnColor,
          background: e.sideBtnBackground,
          "box-sizing": "initial"
        }), e.sideBtnColor && this.arrowL.removeClass("skin-color"), e.sideBtnBackground && this.arrowL.removeClass("skin-color-bg"), e.btnFirst.enabled && (this.btnFirst = O('<div class="flipbook-nav"><div class="flipbook-arrow-wrapper"></div></div>').appendTo(this.bookLayer).bind("tap click", function (e) {
          i.btnFirst.disabled || (i.btnFirst.disabled = !0, setTimeout(function () {
            i.btnFirst.disabled = !1;
          }, 300), e.stopPropagation(), e.preventDefault(), i.firstPage());
        }), this.arrowFirst = this.createIcon(e.btnFirst).appendTo(this.btnFirst.first()).addClass("flipbook-first-arrow").css({
          width: e.sideBtnSize + "px",
          height: .66 * e.sideBtnSize + "px",
          "font-size": .66 * e.sideBtnSize + "px",
          "border-radius": e.sideBtnRadius + "px",
          "margin-top": String(e.sideBtnSize / 2 + e.sideBtnMargin + 2 * e.sideBtnPaddingV) + "px",
          "margin-left": e.sideBtnMargin + "px",
          padding: e.sideBtnPaddingV + "px " + e.sideBtnPaddingH + "px",
          "text-shadow": e.sideBtnTextShadow,
          "box-shadow": e.sideBtnShadow,
          border: e.sideBtnBorder,
          color: e.sideBtnColor,
          background: e.sideBtnBackground,
          "box-sizing": "initial"
        }), e.sideBtnColor && this.arrowFirst.removeClass("skin-color"), e.sideBtnBackground && this.arrowFirst.removeClass("skin-color-bg")), e.btnLast.enabled && (this.btnLast = O('<div class="flipbook-nav"><div class="flipbook-arrow-wrapper"></div></div>').appendTo(i.bookLayer).bind("tap click", function (e) {
          i.btnLast.disabled || (i.btnLast.disabled = !0, setTimeout(function () {
            i.btnLast.disabled = !1;
          }, 300), e.stopPropagation(), e.preventDefault(), i.lastPage());
        }), this.arrowLast = this.createIcon(e.btnLast).appendTo(this.btnLast.first()).addClass("flipbook-last-arrow").css({
          width: e.sideBtnSize + "px",
          height: .66 * e.sideBtnSize + "px",
          "font-size": .66 * e.sideBtnSize + "px",
          "border-radius": e.sideBtnRadius + "px",
          "margin-top": String(e.sideBtnSize / 2 + e.sideBtnMargin + 2 * e.sideBtnPaddingV) + "px",
          "margin-right": e.sideBtnMargin + "px",
          padding: e.sideBtnPaddingV + "px " + e.sideBtnPaddingH + "px",
          "text-shadow": e.sideBtnTextShadow,
          "box-shadow": e.sideBtnShadow,
          border: e.sideBtnBorder,
          color: e.sideBtnColor,
          background: e.sideBtnBackground,
          "box-sizing": "initial"
        }), e.sideBtnColor && this.arrowLast.removeClass("skin-color"), e.sideBtnBackground && this.arrowLast.removeClass("skin-color-bg")), 0 <= e.btnOrder.indexOf("btnFirst") && e.btnOrder.splice(e.btnOrder.indexOf("btnFirst"), 1), 0 <= e.btnOrder.indexOf("btnPrev") && e.btnOrder.splice(e.btnOrder.indexOf("btnPrev"), 1), 0 <= e.btnOrder.indexOf("btnNext") && e.btnOrder.splice(e.btnOrder.indexOf("btnNext"), 1), 0 <= e.btnOrder.indexOf("btnLast") && e.btnOrder.splice(e.btnOrder.indexOf("btnLast"), 1)), e.pdfMode && !e.btnDownloadPdf.url && (e.btnDownloadPdf.url = e.pdfUrl), !e.textLayer && e.btnSelect && (e.btnSelect.enabled = !1);

        for (var n = 0; n < e.btnOrder.length; n++) {
          var s = e.btnOrder[n],
              a = e[s];
          e.isMobile && a.hideOnMobile && (a.enabled = !1), a.enabled && (a.name = s, "currentPage" == a.name ? this.createCurrentPage() : this[s] = this.createButton(a).bind("touchend click", function (e) {
            e.stopPropagation(), e.preventDefault(), i.onButtonClick(this, e);
          }));
        }

        if (e.buttons) for (n = 0; n < e.buttons.length; n++) {
          a = e.buttons[n];
          i.createButton(a).index(1);
        }
      }
    },
    onButtonClick: function onButtonClick(e, t) {
      var o = O(e).attr("data-name"),
          i = this.options;

      switch (o) {
        case "btnFirst":
          this.firstPage();
          break;

        case "btnPrev":
          this.prevPage();
          break;

        case "btnNext":
          this.nextPage();
          break;

        case "btnLast":
          this.lastPage();
          break;

        case "btnZoomIn":
          this.zoomIn();
          break;

        case "btnZoomOut":
          this.zoomOut();
          break;

        case "btnAutoplay":
          this.autoplay || this.nextPage(), this.toggleAutoplay();
          break;

        case "btnSearch":
          this.toggleSearch();
          break;

        case "btnBookmark":
          this.toggleBookmark();
          break;

        case "btnRotateLeft":
          this.Book.rotateLeft && this.Book.rotateLeft();
          break;

        case "btnRotateRight":
          this.Book.rotateRight && this.Book.rotateRight();
          break;

        case "btnToc":
          this.toggleToc();
          break;

        case "btnThumbs":
          this.toggleThumbs();
          break;

        case "btnShare":
          this.toggleShareMenu();
          break;

        case "btnDownloadPages":
          if (i.downloadMenu) this.toggleDownloadMenu();else {
            var n = y.createElement("a");
            n.href = i.btnDownloadPages.url, n.download = i.btnDownloadPages.name, n.dispatchEvent(new MouseEvent("click"));
          }
          break;

        case "btnPrint":
          i.printMenu ? this.togglePrintMenu() : this.togglePrintWindow();
          break;

        case "btnDownloadPdf":
          if (i.btnDownloadPdf.forceDownload) {
            var s = i.btnDownloadPdf.url,
                a = y.createElement("a");
            a.href = s;
            var r = a.href.split("/").pop().split("#")[0].split("?")[0];
            a.download = r, y.body.appendChild(a), a.click(), y.body.removeChild(a);
          } else {
            var l = i.btnDownloadPdf.openInNewWindow || (i.btnDownloadPdf.openInNewWindow, 1) ? "_blank" : "_self";
            T.open(i.btnDownloadPdf.url, l);
          }

          this.gaCode && ga("send", {
            hitType: "event",
            eventCategory: "Flipbook : " + i.name,
            eventAction: "download PDF",
            eventLabel: i.btnDownloadPdf.url,
            nonInteraction: !0
          });
          break;

        case "btnSound":
          this.toggleSound();
          break;

        case "btnSelect":
          this.toggleTool();
          break;

        case "btnExpand":
          this.toggleExpand();
          break;

        case "btnClose":
          this.lightbox.closeLightbox();
      }
    },
    handleFsChange: function handleFsChange(e) {
      if (this.Book && this.Book.enabled) {
        var t = O(this.fullscreenElement);
        (y.fullscreenElement || y.webkitFullscreenElement || y.mozFullScreenElement || y.msFullscreenElement) === this.fullscreenElement || this.isFullscreen ? (this.btnExpand.$icon.hide(), this.btnExpand.$iconAlt.show(), t.addClass("flipbook-browser-fullscreen"), this.fullscreenActive = !0, this.options.onfullscreenenter && this.options.onfullscreenenter.call(this)) : (this.btnExpand.$icon.show(), this.btnExpand.$iconAlt.hide(), t.removeClass("flipbook-browser-fullscreen"), this.fullscreenActive = !1, this.options.onfullscreenexit && this.options.onfullscreenexit.call(this)), this.triggerResizeOnce();
      }
    },
    createLogo: function createLogo() {
      var e = this.options;

      if (e.logoImg && (!e.isMobile || !e.logoHideOnMobile)) {
        var t = O("<img>").attr("src", e.logoImg).attr("style", e.logoCSS).appendTo(this.wrapper);
        "right" == e.logoAlignH && t.css("right", "0"), "bottom" == e.logoAlignV && t.css("bottom", "0"), e.logoUrl && t.bind("touchend click", function () {
          T.open(e.logoUrl, "_blank");
        });
      }
    },
    setLoadingProgress: function setLoadingProgress(e) {
      this.disposed || (this.$fillPreloader ? this.setFillPreloaderProgress(e) : 0 < e && e < 1 ? O(this.preloader).stop(!0, !0).show() : O(this.preloader).stop(!0, !0).hide());
    },
    setFillPreloaderProgress: function setFillPreloaderProgress(e) {
      if (this.$fillPreloader) if (0 < e && e < 1) {
        if (this.fillPreloaderProgress = this.fillPreloaderProgress || 0, e < this.fillPreloaderProgress) return;
        this.fillPreloaderProgress = e;
        var t = this.$fillPreloaderImg[0];
        t.style.clip = "rect(0px," + t.width * e + "px," + t.height + "px,0px)", this.$fillPreloader.show();
      } else this.$fillPreloader.hide();
    },
    createNavigation: function createNavigation() {
      var t = this;
      this.navLeft = O("<div />"), this.navLeft.css("background", "#f00").css("left", "0").css("top", "200px").attr("aria-hidden", "true").addClass("skin-color fa fa-chevron-left fa-5x").css("margin-top", this.navLeft.height() + "px").bind("touchend click", function (e) {
        e.stopPropagation(), e.preventDefault(), t.prevPage();
      }), this.navRight = O("<div />").appendTo(this.bookLayer).css("position", "absolute").css("width", "200px").css("height", "200px").css("margin-top", "-100px").css("background", "#f00").css("right", "0").css("top", "200px").bind("touchend click", function (e) {
        e.stopPropagation(), e.preventDefault(), t.nextPage();
      });
    },
    playFlipSound: function playFlipSound() {
      var e = this;
      this.options.sound && this.Book.enabled && void 0 !== this.flipsound.play && (this.flipsound.currentTime = 0, setTimeout(function () {
        try {
          e.flipsound.play();
        } catch (e) {}
      }, 100));
    },
    onMouseWheel: function onMouseWheel(e) {
      if ("wheelDeltaX" in e) wheelDeltaX = e.wheelDeltaX / 12, wheelDeltaY = e.wheelDeltaY / 12;else if ("wheelDelta" in e) wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;else {
        if (!("detail" in e)) return;
        wheelDeltaX = wheelDeltaY = 3 * -e.detail;
      }
      0 < wheelDeltaX ? this.zoomIn(e) : this.zoomOut(e);
    },
    zoomTo: function zoomTo(e, t, o) {
      var i, n;
      this.zoom = e, void 0 === o ? (i = this.model.wrapperW / 2, n = this.model.wrapperH / 2) : (n = o.touches && o.touches[0] ? (i = o.touches[0].pageX, o.touches[0].pageY) : o.changedTouches && o.changedTouches[0] ? (i = o.changedTouches[0].pageX, o.changedTouches[0].pageY) : (i = o.pageX, o.pageY), i -= this.wrapper.offset().left, n -= this.wrapper.offset().top), this.zoom < this.options.zoomMin && (this.zoom = this.options.zoomMin), this.zoom > this.options.zoomMax && (this.zoom = this.options.zoomMax), this.options.zoomMax2 && this.zoom > this.options.zoomMax2 && (this.zoom = this.options.zoomMax2), this.model.zoom = this.zoom, this.Book.zoomTo(this.zoom, t, i, n), this.onZoom(this.zoom);
    },
    zoomOut: function zoomOut(e) {
      var t = this.zoom / this.options.zoomStep;

      if (t < 1 && 1 < this.zoom && (t = 1), t = t < this.options.zoomMin ? this.options.zoomMin : t, this.zoom != t) {
        this.zoom = t;
        var o = this.options.zoomTime;
        this.zoomTo(this.zoom, o, e);
      }
    },
    zoomIn: function zoomIn(e) {
      var t = this.zoom * this.options.zoomStep;

      if (1 < t && this.zoom < 1 && (t = 1), this.bookLayer.height() * t > this.options.zoomSize && (t = this.options.zoomSize / this.bookLayer.height()), this.zoom != t) {
        this.zoom = t;
        var o = this.options.zoomTime;
        this.zoomTo(this.zoom, o, e);
      }
    },
    nextPage: function nextPage() {
      this.Book && this.Book.nextPage();
    },
    prevPage: function prevPage() {
      this.Book && this.Book.prevPage();
    },
    firstPage: function firstPage() {
      this.goToPage(1);
    },
    lastPage: function lastPage() {
      this.goToPage(this.options.pages.length);
    },
    goToPage: function goToPage(e, t) {
      this.Book && this.Book.goToPage(e, t);
    },
    onZoom: function onZoom(e) {
      this.zoom = e, this.enableButton(this.btnZoomIn, e < this.options.zoomMax), this.enableButton(this.btnZoomOut, e > this.options.zoomMin), this.enableSwipe(e <= 1), this.model.zoom = e;
    },
    enableSwipe: function enableSwipe(e) {
      this.swipeEnabled = e;
    },
    createCurrentPage: function createCurrentPage() {
      var e,
          o = this,
          i = this.options,
          t = "flipbook-currentPageHolder ";
      e = "top" == i.currentPage.vAlign ? "left" == i.currentPage.hAlign ? this.menuTL : "right" == i.currentPage.hAlign ? this.menuTR : this.menuTC : "left" == i.currentPage.hAlign ? this.menuBL : "right" == i.currentPage.hAlign ? this.menuBR : this.menuBC;
      var n = "top" == i.currentPage.vAlign && i.menu2Transparent || "top" != i.currentPage.vAlign && i.menuTransparent,
          s = n ? i.floatingBtnBackground : "",
          a = n ? i.floatingBtnColor : i.btnColor,
          r = n ? i.floatingBtnTextShadow : "",
          l = n ? i.floatingBtnRadius : i.btnRadius,
          d = (n ? i.floatingBtnMargin : i.btnMargin, O("<div>").appendTo(e));
      d.css("margin", i.currentPage.marginV + "px " + i.currentPage.marginH + "px"), n || (t += "skin-color "), d.addClass(t).css({
        color: a,
        background: s,
        "text-shadow": r,
        "border-radius": l + "px"
      }), i.currentPage.order && d.css("order", i.currentPage.order), this.currentPageHolder = d, this.currentPage = O(y.createElement("div")).addClass("flipbook-currentPageNumber").appendTo(d);
      var h = O("<form>").appendTo(d).submit(function (e) {
        var t = parseInt(o.currentPageInput.val());
        return t = t > i.pages.length ? i.pages.length : t, o.options.rightToLeft && (t = i.pages.length - t + 1), o.goToPage(t), o.currentPageInput.trigger("blur"), !1;
      });
      this.currentPageInput = O('<input type="text" maxlength="4">').addClass("flipbook-currentPageInput").css({
        margin: i.currentPage.marginV + "px " + i.currentPage.marginH + "px",
        color: a
      }).appendTo(h).val("").focus(function () {
        o.currentPageInput.val(""), o.currentPage.addClass("flipbook-color-transparent");
      }).blur(function () {
        o.currentPageInput.val(""), o.currentPage.removeClass("flipbook-color-transparent");
      }), n || this.currentPageInput.addClass("skin-color");
    },
    createMenuHeader: function createMenuHeader(e, t, o) {
      var i = this,
          n = O("<div>").addClass("flipbook-menu-header skin-clor flipbook-font").appendTo(e),
          s = (t = O("<span>").text(t).addClass("flipbook-menu-title skin-color").appendTo(n), O("<span>").appendTo(n).addClass("flipbook-btn-close").bind("touchend click", function (e) {
        e.stopPropagation(), e.preventDefault(), i.closeMenus();
      }));
      this.createIcon(this.options.btnClose, null, !0).appendTo(s);
    },
    createToc: function createToc() {
      var t = this,
          e = this.options.tableOfContent;

      if (e && e.length || !this.pdfService || this.pdfService.outlineLoaded) {
        if (this.tocHolder = O("<div>").addClass("flipbook-tocHolder flipbook-side-menu skin-color-bg").appendTo(this.wrapper).hide(), this.createMenuHeader(this.tocHolder, this.strings.tableOfContent, this.toggleToc), this.toc = O("<div>").addClass("flipbook-toc").appendTo(this.tocHolder), this.tocScroller = O("<div>").addClass("flipbook-toc-scroller").appendTo(this.toc), this.tocScroll = new FLIPBOOK.IScroll(t.toc[0], {
          bounce: !1,
          mouseWheel: !0,
          scrollbars: !0,
          interactiveScrollbars: !0
        }), e && 0 < e.length) {
          this.options.pages;

          for (var o = 0; o < e.length; o++) {
            this.createTocItem(e[o]);
          }
        } else {
          var i = this.options.pages;

          for (o = 0; o < i.length; o++) {
            var n = i[o].title;

            if ("" != n && void 0 !== n) {
              var s = {
                title: n,
                page: String(o + 1)
              };
              this.createTocItem(s);
            }
          }
        }

        this.initColors(), this.tocScroll.refresh(), this.tocCreated = !0, this.toggleToc();
      } else t.pdfService.loadOutline(function (e) {
        t.options.tableOfContent = e, t.createToc();
      });
    },
    createTocItem: function createTocItem(o, e, t) {
      var i = this,
          n = (e = e || this.tocScroller, this.options.rightToLeft),
          s = O(y.createElement("a")).attr("class", "flipbook-tocItem").addClass("skin-color").css("direction", n ? "rtl" : "ltr").appendTo(e).bind("touchend click", function (e) {
        if (e.stopPropagation(), e.preventDefault(), !i.tocScroll.moved) if (i.options.tableOfContentCloseOnClick && i.toggleToc(!1), !o.page && o.dest) i.pdfService.pdfDocument.getPageIndex(o.dest[0]).then(function (e) {
          var t = e + 1;
          t = i.options.rightToLeft ? i.options.pages.length - t + 1 : t, setTimeout(function () {
            i.goToPage(t);
          }, 200);
        });else {
          var t = Number(o.page);
          t = i.options.rightToLeft ? i.options.pages.length - t + 1 : t, setTimeout(function () {
            i.goToPage(t);
          }, 200);
        }
      });
      t = t || 0, s.level = t, s.css("padding", "8px 0"), s.css("margin-" + (n ? "right" : "left"), "10px"), t ? (s.css("margin-top", "8px"), s.css("padding-bottom", "0")) : (s.css("margin-right", "15px"), s.css("padding-left", "10px"));
      var a = O(y.createElement("span")).appendTo(s).css("width", "20px").css("display", "inline-block").css("cursor", "auto").bind("touchend click", function (e) {
        e.stopPropagation(), e.preventDefault();

        for (var t = 0; t < s.items.length; t++) {
          s.items[t].toggle();
        }

        r.toggle(), l.toggle(), i.tocScroll.refresh();
      }),
          r = O("<span>").attr("aria-hidden", "true").appendTo(a).addClass("fa fa-chevron-" + (n ? "left" : "right") + " skin-color").hide(),
          l = O("<span>").attr("aria-hidden", "true").appendTo(a).addClass("fa fa-chevron-down skin-color").hide();

      if (O(y.createElement("span")).appendTo(s).addClass("title").text(o.title).css("width", String(170 - 10 * s.level) + "px"), O(y.createElement("span")).appendTo(s).width("25px").css("display", "inline-block").css("text-align", "right").text(o.page), o.items && o.items.length) {
        s.items = [];

        for (var d = 0; d < o.items.length; d++) {
          var h = this.createTocItem(o.items[d], s, s.level + 1);
          s.items.push(h), h.hide();
        }

        r.show();
      }

      return s;
    },
    enablePrev: function enablePrev(e) {
      this.enableButton(this.btnPrev, e), this.enableButton(this.btnFirst, e), this.Book.enablePrev(e);
    },
    enableNext: function enableNext(e) {
      this.enableButton(this.btnNext, e), this.enableButton(this.btnLast, e), this.Book.enableNext(e);
    },
    enableButton: function enableButton(e, t) {
      void 0 !== e && (t ? (e.css("opacity", "1"), e.css("pointer-events", "auto")) : (e.css("opacity", "0.2"), e.css("pointer-events", "none")), e.enabled = t);
    },
    resize: function resize() {
      if (this.Book && this.Book.enabled) {
        var e = this.options;
        !e.menuOverBook && this.menuShowing && this.menuBottom ? this.bookLayer.css("bottom", this.menuBottom.outerHeight() + "px") : this.bookLayer.css("bottom", "0px"), !e.menu2OverBook && this.menuShowing && this.menuTop ? this.bookLayer.css("top", this.menuTop.outerHeight() + "px") : this.bookLayer.css("top", "0px"), this.tocShowing || this.thumbsShowing || this.searchShowing || this.bookmarkShowing ? (e.sideMenuOverBook || this.bookLayer.css("left", "250px"), this.options.sideMenuOverMenu || this.wrapper.find(".flipbook-side-menu").css("bottom", this.menuBottom.outerHeight() + "px"), this.options.sideMenuOverMenu2 || this.wrapper.find(".flipbook-side-menu").css("top", this.menuTop.outerHeight() + "px")) : this.bookLayer.css("left", "0px");
        var t = this.model;
        t.wrapperW = this.bookLayer.width(), t.wrapperH = this.bookLayer.height(), e.zoomMax = e.zoomSize / t.wrapperH, t.zoom = e.zoomMin, this.Book.onResize(), this.options.zoomReset && this.Book.zoomTo(this.options.zoomMin);
      }
    },
    pdfResize: function pdfResize() {
      this.Book.onZoom();
    },
    createThumbs: function createThumbs() {
      this.thumbs = new FLIPBOOK.Thumbnails(this);
    },
    toggleThumbs: function toggleThumbs(e) {
      this.thumbs || this.createThumbs(), void 0 !== e && (this.thumbsShowing = !e), this.thumbsShowing ? (this.thumbs.hide(), this.thumbsShowing = !1) : (this.closeMenus(), this.thumbs.show(), this.thumbsShowing = !0), this.resize();
    },
    toggleToc: function toggleToc(e) {
      this.tocCreated ? (!this.tocShowing || e ? (this.closeMenus(), this.tocShowing = !0, this.tocHolder.show(), this.tocScroll.refresh()) : (this.tocHolder.hide(), this.tocShowing = !1), this.resize()) : this.createToc();
    },
    toggleSearch: function toggleSearch(e) {
      this.thumbs || this.createThumbs(), void 0 !== e && (this.searchShowing = !e), this.searchShowing ? (this.thumbs.hide(), this.searchShowing = !1, this.unmark()) : (this.closeMenus(), this.thumbs.show(), this.thumbs.showSearch(), this.searchShowing = !0), this.resize();
    },
    toggleBookmark: function toggleBookmark(e) {
      this.thumbs || this.createThumbs(), void 0 !== e && (this.bookmarkShowing = !e), this.bookmarkShowing ? (this.thumbs.hide(), this.bookmarkShowing = !1) : (this.closeMenus(), this.thumbs.show(), this.thumbs.showBookmarks(), this.bookmarkShowing = !0), this.resize();
    },
    closeMenus: function closeMenus() {
      this.thumbsShowing && this.toggleThumbs(), this.tocShowing && this.toggleToc(), this.searchShowing && this.toggleSearch(), this.bookmarkShowing && this.toggleBookmark(), this.printMenuShowing && this.togglePrintMenu(), this.dlMenuShowing && this.toggleDownloadMenu(), this.shareMenuShowing && this.toggleShareMenu();
    },
    togglePrintMenu: function togglePrintMenu() {
      var t = this;
      if (this.printMenu) this.printMenuShowing ? (this.printMenu.hide(), this.printMenuShowing = !1) : (this.closeMenus(), this.printMenu.show(), this.printMenuShowing = !0, this.updateCurrentPage());else {
        this.printMenu = O('<div class="flipbook-sub-menu flipbook-font">').appendTo(this.wrapper);
        var e = O('<idv class="flipbook-sub-menu-center">').appendTo(this.printMenu),
            o = O('<idv class="flipbook-sub-menu-content skin-color-bg">').appendTo(e);
        this.createMenuHeader(o, this.strings.print, this.togglePrintMenu);
        O('<a><div class="c-p skin-color flipbook-btn">' + this.strings.printCurrentPage + "</div></a>").appendTo(o).bind("touchend click", function (e) {
          t.printPage(t.cPage[0], this);
        }), O('<a><div class="c-l-p skin-color flipbook-btn">' + this.strings.printLeftPage + "</div></a>").appendTo(this.printMenu).appendTo(o).bind("touchend click", function (e) {
          t.printPage(t.cPage[0], this);
        }), O('<a><div class="c-r-p skin-color flipbook-btn">' + this.strings.printRightPage + "</div></a>").appendTo(this.printMenu).appendTo(o).bind("touchend click", function (e) {
          t.printPage(t.cPage[1], this);
        }), O('<a><div class="skin-color flipbook-btn">' + this.strings.printAllPages + "</div></a>").appendTo(o).bind("touchend click", function (e) {
          t.togglePrintWindow();
        });
        this.closeMenus(), this.printMenuShowing = !0, this.initColors(), this.updateCurrentPage();
      }
    },
    toggleDownloadMenu: function toggleDownloadMenu() {
      var i = this;
      if (this.dlMenu) this.dlMenuShowing ? (this.dlMenu.hide(), this.dlMenuShowing = !1) : (this.dlMenu.show(), this.closeMenus(), this.dlMenuShowing = !0, this.updateCurrentPage());else {
        this.dlMenu = O('<div class="flipbook-sub-menu flipbook-font">').appendTo(this.wrapper);
        var e = O('<idv class="flipbook-sub-menu-center">').appendTo(this.dlMenu),
            t = O('<idv class="flipbook-sub-menu-content skin-color-bg">').appendTo(e);
        this.createMenuHeader(t, this.strings.download, this.toggleDownloadMenu);
        O('<a><div class="c-p skin-color flipbook-btn">' + this.strings.downloadCurrentPage + "</div></a>").appendTo(t).bind("touchend click", function (e) {
          i.downloadPage(i.cPage[0], this);
        }), O('<a><div class="c-l-p skin-color flipbook-btn">' + this.strings.downloadLeftPage + "</div></a>").appendTo(t).bind("touchend click", function (e) {
          i.downloadPage(i.cPage[0], this);
        }), O('<a><div class="c-r-p skin-color flipbook-btn">' + this.strings.downloadRightPage + "</div></a>").appendTo(t).bind("touchend click", function (e) {
          i.downloadPage(i.cPage[1], this);
        }), O('<a><div class="skin-color flipbook-btn">' + this.strings.downloadAllPages + "</div></a>").appendTo(t).bind("touchend click", function (e) {
          var t = y.createElement("a");
          t.href = i.options.btnDownloadPages.url;
          var o = t.href.split("/").pop().split("#")[0].split("?")[0];
          t.download = o, t.dispatchEvent(new MouseEvent("click"));
        });
        this.closeMenus(), this.dlMenuShowing = !0, this.initColors(), this.updateCurrentPage();
      }
    },
    toggleShareMenu: function toggleShareMenu() {
      if (this.shareMenu) this.shareMenuShowing ? (this.shareMenu.hide(), this.shareMenuShowing = !1) : (this.shareMenu.show(), this.closeMenus(), this.shareMenuShowing = !0);else {
        this.shareMenu = O('<div class="flipbook-sub-menu flipbook-font">').appendTo(this.wrapper);
        var e = O('<idv class="flipbook-sub-menu-center">').appendTo(this.shareMenu),
            t = O('<idv class="flipbook-sub-menu-content skin-color-bg">').appendTo(e);
        this.createMenuHeader(t, "Share", this.toggleShareMenu);
        var o = O('<idv class="flipbook-share">').appendTo(t),
            i = this.options;
        this.share = new Share(o[0], {
          networks: {
            twitter: i.twitter,
            facebook: i.facebook,
            pinterest: i.pinterest,
            email: i.email
          }
        }), this.closeMenus(), this.shareMenuShowing = !0, this.initColors();
      }
    },
    bookmarkPage: function bookmarkPage(e) {
      var t = this.getBookmarkedPages();
      t.indexOf(String(e)) < 0 && t.push(e), this.setBookmarkedPages(t), this.thumbs.showBookmarkedThumbs(), this.bookmarkShowing || this.toggleBookmark();
    },
    removeBookmark: function removeBookmark(e) {
      var t = this.getBookmarkedPages();
      -1 < t.indexOf(String(e)) && t.splice(t.indexOf(String(e)), 1), this.setBookmarkedPages(t), this.thumbs.showBookmarkedThumbs(), this.bookmarkShowing || this.toggleBookmark();
    },
    isBookmarked: function isBookmarked(e) {
      return 0 < this.getBookmarkedPages().indexOf(String(e));
    },
    getBookmarkedPages: function getBookmarkedPages() {
      var e = localStorage.getItem(this.options.name + "_flipbook_bookmarks");
      return e ? e.split(";") : [];
    },
    setBookmarkedPages: function setBookmarkedPages(e) {
      localStorage.setItem(this.options.name + "_flipbook_bookmarks", e.join(";"));
    },
    printPage: function printPage(e, t) {
      var o;

      if (this.options.pages[e] && this.options.pages[e].print ? o = this.options.pages[e].print : this.options.pages[e] && this.options.pages[e].canvas && this.options.pages[e].canvas[this.options.pageTextureSize] ? o = this.options.pages[e].canvas[this.options.pageTextureSize].toDataURL() : this.options.pages[e] && this.options.pages[e].src && (o = this.options.pages[e].src), o) {
        var i = "<!DOCTYPE html>";
        i += "<html>", i += "<head><title>Print canvas</title></head>", i += "<body>", i += '<img src="' + o + '">', i += "</body>", i += "</html>";
        var n = T.open("", "Print", "height=1600,width=800");
        n.document.open(), n.document.write(i), n.document.close(), n.document.addEventListener("load", function () {
          n.focus(), n.print(), n.document.close(), n.close();
        }, !0);
      } else {
        var s = this;
        this.loadPage(e, this.options.pageTextureSize, function () {
          s.printPage(e);
        });
      }
    },
    downloadPage: function downloadPage(e) {
      var t;
      if (this.options.pages[e] && this.options.pages[e].download) t = this.options.pages[e].download;else if (this.options.pages[e] && this.options.pages[e].src) t = this.options.pages[e].src;else if (this.options.pages[e] && this.options.pages[e].canvas && this.options.pages[e].canvas[this.options.pageTextureSize]) {
        var o = y.createElement("canvas"),
            i = this.options.pageWidth / this.options.pageHeight;
        o.width = this.options.pageTextureSize * i, o.height = this.options.pageTextureSize, o.getContext("2d").drawImage(this.options.pages[e].canvas[this.options.pageTextureSize], 0, 0), t = o.toDataURL("image/jpeg", .5);
      }

      if (t) {
        var n = y.createElement("a");
        n.href = t, n.download = "page" + String(e + 1), y.body.appendChild(n), n.click(), y.body.removeChild(n);
      } else {
        var s = this;
        this.loadPage(e, this.options.pageTextureSize, function () {
          s.downloadPage(e);
        });
      }
    },
    printPdf: function printPdf(e) {
      if (this.options.isMobile) {
        T.open(e, "_blank", "directories=0,titlebar=0,toolbar=0,location=0,status=0,menubar=0").onload = function () {
          this.document.body.children[0].style.display = "none", this.print();
        };
      } else {
        var t = this._printIframe;
        this._printIframe || (t = this._printIframe = y.createElement("iframe"), y.body.appendChild(t), t.style.display = "none", t.onload = function () {
          setTimeout(function () {
            t.focus(), t.contentWindow.print();
          }, 1);
        }), t.src = e;
      }
    },
    togglePrintWindow: function togglePrintWindow(e) {
      var n;
      (n = this).options.printPdfUrl ? n.printPdf(n.options.printPdfUrl) : n.options.pdfUrl ? n.printPdf(n.options.pdfUrl) : t();

      function t() {
        link = "about:blank";
        var e = T.open(link, "_new");
        e.document.open();

        for (var t = "", o = 0; o < n.options.pages.length; o++) {
          n.options.pages[o].src && (t += '<img src="' + n.options.pages[o].src.toString() + '"/>\n');
        }

        var i = "<html>\n<head>\n<title>Temporary Printing Window</title>\n<script>\nfunction step1() {\n  setTimeout('step2()', 10);\n}\nfunction step2() {\n  window.print();\n  window.close();\n}\n<\/script>\n</head>\n<body onLoad='step1()'>\n" + t + "</body>\n</html>\n";
        e.document.write(i), e.document.close();
      }
    },
    thumbsVertical: function thumbsVertical() {
      this.thumbsCreated && (this.thumbScroll.hScroll = !1, this.thumbScroll.vScroll = !0, this.thumbScroll.refresh());
    },
    toggleExpand: function toggleExpand(e) {
      this.browserFullscreen = !0, screenfull.enabled ? screenfull.toggle(this.fullscreenElement) : (this.isFullscreen = !this.isFullscreen, this.handleFsChange());
    },
    expand: function expand() {},
    toggleAutoplay: function toggleAutoplay(e) {
      var t = this;
      this.autoplay = e || !this.autoplay, this.autoplay ? (this.btnAutoplay.$icon.hide(), this.btnAutoplay.$iconAlt.show(), this.autoplayTimer = setInterval(function () {
        if (t.autoplay) {
          var e = t.options.autoplayStartPage || 1;
          t.options.rightToLeft ? t.Book.prevEnabled ? t.prevPage() : t.options.autoplayLoop && t.goToPage(t.options.pages.length - e + 1) : t.Book.nextEnabled ? t.nextPage() : t.options.autoplayLoop && t.goToPage(e);
        }
      }, t.options.autoplayInterval)) : (this.btnAutoplay.$icon.show(), this.btnAutoplay.$iconAlt.hide(), clearInterval(t.autoplayTimer));
    },
    triggerResizeOnce: function triggerResizeOnce() {
      setTimeout(function () {
        O(T).trigger("resize");
      }, 100), setTimeout(function () {
        O(T).trigger("resize");
      }, 500);
    },
    triggerResize: function triggerResize() {
      setTimeout(function () {
        O(T).trigger("resize");
      }, 100), setTimeout(function () {
        O(T).trigger("resize");
      }, 500), setTimeout(function () {
        O(T).trigger("resize");
      }, 2e3);
    },
    initEasing: function initEasing() {
      T.jQuery.extend(T.jQuery.easing, {
        def: "easeOutQuad",
        swing: function swing(e, t, o, i, n) {
          return O.easing[O.easing.def](e, t, o, i, n);
        },
        easeInQuad: function easeInQuad(e, t, o, i, n) {
          return i * (t /= n) * t + o;
        },
        easeOutQuad: function easeOutQuad(e, t, o, i, n) {
          return -i * (t /= n) * (t - 2) + o;
        },
        easeInOutQuad: function easeInOutQuad(e, t, o, i, n) {
          return (t /= n / 2) < 1 ? i / 2 * t * t + o : -i / 2 * (--t * (t - 2) - 1) + o;
        },
        easeInCubic: function easeInCubic(e, t, o, i, n) {
          return i * (t /= n) * t * t + o;
        },
        easeOutCubic: function easeOutCubic(e, t, o, i, n) {
          return i * ((t = t / n - 1) * t * t + 1) + o;
        },
        easeInOutCubic: function easeInOutCubic(e, t, o, i, n) {
          return (t /= n / 2) < 1 ? i / 2 * t * t * t + o : i / 2 * ((t -= 2) * t * t + 2) + o;
        },
        easeInQuart: function easeInQuart(e, t, o, i, n) {
          return i * (t /= n) * t * t * t + o;
        },
        easeOutQuart: function easeOutQuart(e, t, o, i, n) {
          return -i * ((t = t / n - 1) * t * t * t - 1) + o;
        },
        easeInOutQuart: function easeInOutQuart(e, t, o, i, n) {
          return (t /= n / 2) < 1 ? i / 2 * t * t * t * t + o : -i / 2 * ((t -= 2) * t * t * t - 2) + o;
        },
        easeInQuint: function easeInQuint(e, t, o, i, n) {
          return i * (t /= n) * t * t * t * t + o;
        },
        easeOutQuint: function easeOutQuint(e, t, o, i, n) {
          return i * ((t = t / n - 1) * t * t * t * t + 1) + o;
        },
        easeInOutQuint: function easeInOutQuint(e, t, o, i, n) {
          return (t /= n / 2) < 1 ? i / 2 * t * t * t * t * t + o : i / 2 * ((t -= 2) * t * t * t * t + 2) + o;
        },
        easeInSine: function easeInSine(e, t, o, i, n) {
          return -i * Math.cos(t / n * (Math.PI / 2)) + i + o;
        },
        easeOutSine: function easeOutSine(e, t, o, i, n) {
          return i * Math.sin(t / n * (Math.PI / 2)) + o;
        },
        easeInOutSine: function easeInOutSine(e, t, o, i, n) {
          return -i / 2 * (Math.cos(Math.PI * t / n) - 1) + o;
        },
        easeInExpo: function easeInExpo(e, t, o, i, n) {
          return 0 == t ? o : i * Math.pow(2, 10 * (t / n - 1)) + o;
        },
        easeOutExpo: function easeOutExpo(e, t, o, i, n) {
          return t == n ? o + i : i * (1 - Math.pow(2, -10 * t / n)) + o;
        },
        easeInOutExpo: function easeInOutExpo(e, t, o, i, n) {
          return 0 == t ? o : t == n ? o + i : (t /= n / 2) < 1 ? i / 2 * Math.pow(2, 10 * (t - 1)) + o : i / 2 * (2 - Math.pow(2, -10 * --t)) + o;
        },
        easeInCirc: function easeInCirc(e, t, o, i, n) {
          return -i * (Math.sqrt(1 - (t /= n) * t) - 1) + o;
        },
        easeOutCirc: function easeOutCirc(e, t, o, i, n) {
          return i * Math.sqrt(1 - (t = t / n - 1) * t) + o;
        },
        easeInOutCirc: function easeInOutCirc(e, t, o, i, n) {
          return (t /= n / 2) < 1 ? -i / 2 * (Math.sqrt(1 - t * t) - 1) + o : i / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + o;
        },
        easeInElastic: function easeInElastic(e, t, o, i, n) {
          var s = 1.70158,
              a = 0,
              r = i;
          if (0 == t) return o;
          if (1 == (t /= n)) return o + i;

          if (a = a || .3 * n, r < Math.abs(i)) {
            r = i;
            s = a / 4;
          } else s = a / (2 * Math.PI) * Math.asin(i / r);

          return -r * Math.pow(2, 10 * --t) * Math.sin((t * n - s) * (2 * Math.PI) / a) + o;
        },
        easeOutElastic: function easeOutElastic(e, t, o, i, n) {
          var s = 1.70158,
              a = 0,
              r = i;
          if (0 == t) return o;
          if (1 == (t /= n)) return o + i;

          if (a = a || .3 * n, r < Math.abs(i)) {
            r = i;
            s = a / 4;
          } else s = a / (2 * Math.PI) * Math.asin(i / r);

          return r * Math.pow(2, -10 * t) * Math.sin((t * n - s) * (2 * Math.PI) / a) + i + o;
        },
        easeInOutElastic: function easeInOutElastic(e, t, o, i, n) {
          var s = 1.70158,
              a = 0,
              r = i;
          if (0 == t) return o;
          if (2 == (t /= n / 2)) return o + i;

          if (a = a || n * (.3 * 1.5), r < Math.abs(i)) {
            r = i;
            s = a / 4;
          } else s = a / (2 * Math.PI) * Math.asin(i / r);

          return t < 1 ? r * Math.pow(2, 10 * --t) * Math.sin((t * n - s) * (2 * Math.PI) / a) * -.5 + o : r * Math.pow(2, -10 * --t) * Math.sin((t * n - s) * (2 * Math.PI) / a) * .5 + i + o;
        },
        easeInBack: function easeInBack(e, t, o, i, n, s) {
          return s == a && (s = 1.70158), i * (t /= n) * t * ((s + 1) * t - s) + o;
        },
        easeOutBack: function easeOutBack(e, t, o, i, n, s) {
          return s == a && (s = 1.70158), i * ((t = t / n - 1) * t * ((s + 1) * t + s) + 1) + o;
        },
        easeInOutBack: function easeInOutBack(e, t, o, i, n, s) {
          return s == a && (s = 1.70158), (t /= n / 2) < 1 ? i / 2 * (t * t * ((1 + (s *= 1.525)) * t - s)) + o : i / 2 * ((t -= 2) * t * ((1 + (s *= 1.525)) * t + s) + 2) + o;
        },
        easeInBounce: function easeInBounce(e, t, o, i, n) {
          return i - O.easing.easeOutBounce(e, n - t, 0, i, n) + o;
        },
        easeOutBounce: function easeOutBounce(e, t, o, i, n) {
          return (t /= n) < 1 / 2.75 ? i * (7.5625 * t * t) + o : t < 2 / 2.75 ? i * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + o : t < 2.5 / 2.75 ? i * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + o : i * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + o;
        },
        easeInOutBounce: function easeInOutBounce(e, t, o, i, n) {
          return t < n / 2 ? .5 * O.easing.easeInBounce(e, 2 * t, 0, i, n) + o : .5 * O.easing.easeOutBounce(e, 2 * t - n, 0, i, n) + .5 * i + o;
        }
      });
    }
  }, FLIPBOOK.Book = function () {}, FLIPBOOK.Book.prototype = {
    rightIndex: 0,
    goToPage: function goToPage() {}
  }, FLIPBOOK.Thumbnails = function (o) {
    var i = this,
        n = o.options,
        e = o.wrapper;

    if (this.main = o, this.options = n, this.wrapper = e, this.active = null, n.btnThumbs.enabled) {
      O(o).bind("pagechange", function () {
        i.thumbsWrapper.css("top", i.bookmark.height() + 50 + "px");
      }), this.thumbHolder = O(y.createElement("div")).addClass("flipbook-thumbHolder flipbook-side-menu skin-color-bg").appendTo(e).hide(), this.thumbsWrapper = O(y.createElement("div")).appendTo(this.thumbHolder).addClass("flipbook-thumbsWrapper"), this.thumbsScroller = O(y.createElement("div")).appendTo(this.thumbsWrapper).addClass("flipbook-thumbsScroller"), o.createMenuHeader(this.thumbHolder, o.strings.thumbnails, o.toggleThumbs), this.bookmark = O("<div>").addClass("flipbook-font").appendTo(this.thumbHolder).hide();
      O('<a><div class="c-p skin-color flipbook-btn">' + n.strings.bookmarkCurrentPage + "</div></a>").appendTo(this.bookmark).bind("touchend click", function (e) {
        o.bookmarkPage(o.cPage[0], this), e.preventDefault(), e.stopPropagation();
      }), O('<a><div class="c-l-p skin-color flipbook-btn">' + n.strings.bookmarkLeftPage + "</div></a>").appendTo(this.bookmark).bind("touchend click", function (e) {
        o.bookmarkPage(o.cPage[0], this), e.preventDefault(), e.stopPropagation();
      }), O('<a><div class="c-r-p skin-color flipbook-btn">' + n.strings.bookmarkRightPage + "</div></a>").appendTo(this.bookmark).bind("touchend click", function (e) {
        o.bookmarkPage(o.cPage[1], this), e.preventDefault(), e.stopPropagation();
      });
      this.search = O("<div>").addClass("flipbook-search").appendTo(this.thumbHolder).hide(), this.$searchBar = O('<div class="flipbook-findbar" id="findbar" deluminate_imagetype="png"><div id="findbarInputContainer"><input id="findInput" class="toolbarField" title="Find" placeholder="' + n.strings.findInDocument + '..."></div><div class="flipbook-find-info skin-color"/></div>').appendTo(this.search), this.$findInput = this.$searchBar.find("#findInput").keyup(function () {
        i.searchPDF(this.value);
      }), this.$findInfo = this.$searchBar.find(".flipbook-find-info"), this.thumbs = [];
      var t = n.pages,
          s = [];
      if (n.doublePage) for (var a = 0; a < t.length; a++) {
        0 != a && a % 2 == 0 || s.push(t[a]);
      } else s = t;
      n.pdfMode && this.loadThumbsFromPdf(s);
      var r = n.thumbSize,
          l = n.thumbSize * n.pageWidth / n.pageHeight;

      for (a = 0; a < s.length; a++) {
        var d = s[a].thumb;

        if (!s[a].empty) {
          var h = O("<div>").addClass("flipbook-thumb").appendTo(i.thumbsScroller).attr("data-thumb-index", a).width(l).height(r),
              p = O("<span>").appendTo(h).addClass("thumb-btn-close").bind("touchend click", function (e) {
            e.stopPropagation(), e.preventDefault(), o.removeBookmark(O(this).parent().attr("data-thumb-index"));
          });
          O("<span>").attr("aria-hidden", "true").appendTo(p).addClass("fa fa-times skin-color");
          if (this.thumbs.push(h), s[a].thumbCanvas) var c = O(s[a].thumbCanvas);else {
            if (!d) continue;

            (c = O("<img/>").attr("src", d))[0].onload = function () {
              i.thumbScroll.refresh();
            };
          }

          if (c.appendTo(h), O("<br/>").appendTo(h), n.doublePage && 0 < a) {
            h.width(2 * l), c.height(r).width(2 * l).attr("page-title", 2 * a + 1);
            O(y.createElement("soan")).text(String(2 * a) + "-" + String(2 * a + 1)).appendTo(h).addClass("skin-color").addClass("flipbook-thumb-num");
          } else {
            c.height(r).width(l).attr("page-title", a + 1);
            O(y.createElement("span")).text(a + 1).appendTo(h).addClass("skin-color").addClass("flipbook-thumb-num");
          }

          c.bind("touchend click", function (e) {
            if (e.stopPropagation(), e.preventDefault(), !i.thumbScroll.moved) {
              var t = Number(O(this).attr("page-title"));
              n.rightToLeft && (t = n.pages.length - t + 1), setTimeout(function () {
                o.goToPage(t);
              }, 200), "search" != i.active && n.thumbsCloseOnClick && o.toggleThumbs(!1);
            }
          });
        }
      }

      this.thumbScroll = new FLIPBOOK.IScroll(this.thumbsWrapper[0], {
        bounce: !1,
        mouseWheel: !0,
        scrollbars: !0,
        interactiveScrollbars: !0
      }), o.initColors();
    }
  }, FLIPBOOK.Thumbnails.prototype = {
    loadThumbsFromPdf: function loadThumbsFromPdf(e) {
      for (var t = this.main.pdfDocument._pdfInfo.numPages, o = 0; o < t; o++) {
        var i = y.createElement("canvas");
        e[o].thumbCanvas = i;
      }

      this.loadThumbFromPdf(0, e);
    },
    loadVisibleThumbs: function loadVisibleThumbs() {},
    loadThumbFromPdf: function loadThumbFromPdf(e, r) {
      var l = this;
      this.main.pdfDocument.getPage(e + 1).then(function (e) {
        var t = e.getViewport({
          scale: 1
        }),
            o = l.options.thumbSize / t.height,
            i = e.getViewport({
          scale: o
        }),
            n = r[e.pageIndex].thumbCanvas,
            s = n.getContext("2d");
        n.height = i.height, n.width = i.width;
        var a = {
          canvasContext: s,
          viewport: i
        };
        e.cleanupAfterRender = !0, e.render(a).promise.then(function () {
          e.cleanup(), e.pageIndex + 1 < l.main.pdfDocument._pdfInfo.numPages && l.loadThumbFromPdf(e.pageIndex + 1, r);
        }), l.thumbScroll.refresh();
      });
    },
    showAllThumbs: function showAllThumbs() {
      O(".flipbook-thumb").show(), this.thumbScroll.refresh();
    },
    hideAllThumbs: function hideAllThumbs() {
      O(".flipbook-thumb").hide(), this.thumbScroll.refresh();
    },
    showThumb: function showThumb(e) {
      this.thumbs[e] && this.thumbs[e].show(), this.thumbScroll.refresh();
    },
    hideThumb: function hideThumb(e) {
      this.thumbs[e].hide(), this.thumbScroll.refresh();
    },
    showBookmarks: function showBookmarks() {
      O(".thumb-btn-close").show(), this.showBookmarkedThumbs(), this.bookmark.show(), this.setTitle(this.options.strings.bookmarks), this.main.updateCurrentPage(), this.active = "bookmarks";
    },
    showSearch: function showSearch() {
      this.thumbsWrapper.css("top", "120px"), this.hideAllThumbs(), this.search.show(), this.$findInfo.hide(), O(".thumb-btn-close").hide(), this.setTitle(this.options.strings.search), this.$findInput.val("").focus(), this.active = "search";
    },
    showBookmarkedThumbs: function showBookmarkedThumbs() {
      var e = this.main.getBookmarkedPages();
      this.hideAllThumbs();

      for (var t = 0; t < e.length; t++) {
        var o = e[t];
        o && this.showThumb(o);
      }

      this.thumbsWrapper.css("top", 50 + this.bookmark.height() + "px");
    },
    show: function show() {
      this.setTitle(this.options.strings.thumbnails), this.bookmark.hide(), this.search.hide(), this.thumbHolder.show(), this.main.thumbsVertical(), this.thumbsWrapper.css("top", "50px"), this.showAllThumbs(), O(".thumb-btn-close").hide(), this.loadVisibleThumbs(), this.main.resize(), this.active = "thumbs";
    },
    hide: function hide() {
      this.thumbHolder.hide(), this.main.resize(), this.active = null;
    },
    searchPDF: function searchPDF(e) {
      var t = this.main;
      if (this.hideAllThumbs(), this.pagesFound = 0, this.$findInfo.hide(), t.unmark(), "" != e && (t.searchingString = e, t.pdfService)) for (var o = 0; o < t.pdfService.pdfInfo.numPages; o++) {
        this.findInPage(e, o);
      }
    },
    setTitle: function setTitle(e) {
      this.thumbHolder.find(".flipbook-menu-title").text(e);
    },
    findInPage: function findInPage(t, o) {
      var i = this;
      this.main.pdfService.findInPage(t, o, function (e) {
        0 < e && (i.showThumb(o), i.pagesFound++, i.$findInfo.show().text(i.pagesFound + " " + i.options.strings.pagesFoundContaining + ' "' + t + '"'), i.main.mark(t));
      });
    }
  }, FLIPBOOK.Lightbox = function (e, t, o) {
    var i = this;
    this.context = e, this.options = o, e.$elem.bind("tap click", function (e) {
      t.disposed || (i.openLightbox(), e.stopPropagation());
    });
    O(e.elem).find("img");
    i.overlay = O(y.createElement("div")).attr("style", o.lightboxCSS).addClass("flipbook-overlay").css("display", "none").css("top", i.options.lightboxMarginV).css("bottom", i.options.lightboxMarginV).css("left", i.options.lightboxMarginH).css("right", i.options.lightboxMarginH).appendTo("body"), i.options.lightboxCloseOnClick && O("body").bind("tap click", function (e) {
      var t = O(e.target);
      t.parents().hasClass("flipbook-overlay") && !t.hasClass("flipbook-bookLayer") || i.closeLightbox();
    }), o.lightboxBackground && i.overlay.css("background", o.lightboxBackground), o.lightboxBackgroundColor && i.overlay.css("background", o.lightboxBackgroundColor), o.lightboxBackgroundPattern && i.overlay.css("background", "url(" + o.lightboxBackgroundPattern + ") repeat"), o.lightboxBackgroundImage && (i.overlay.css("background", "url(" + o.lightboxBackgroundImage + ") no-repeat"), i.overlay.css("background-size", "cover"), i.overlay.css("background-position", "center center")), O(y).keyup(function (e) {
      27 == e.keyCode && i.closeLightbox();
    }), i.wrapper = O(y.createElement("div")).css("height", "auto").appendTo(i.overlay), i.wrapper.attr("class", "flipbook-wrapper-transparent").css("margin", "0px auto").css("padding", "0px").css("height", "100%").css("width", "100%"), t.appendTo(i.wrapper);
    O("<div/>").appendTo(i.wrapper).addClass("flipbook-lightbox-toolbar");
  }, FLIPBOOK.Lightbox.prototype = {
    openLightbox: function openLightbox() {
      FLIPBOOK.lightboxOpened || (FLIPBOOK.lightboxOpened = !0, this.overlay.css("display", "none"), this.overlay.fadeIn("slow"), O("body").addClass("flipbook-overflow-hidden"), O("html").addClass("flipbook-overflow-hidden"));
    },
    closeLightbox: function closeLightbox() {
      FLIPBOOK.lightboxOpened = !1, this.overlay.fadeOut("fast"), O("body").removeClass("flipbook-overflow-hidden"), O("html").removeClass("flipbook-overflow-hidden"), O(this.context.fullscreenElement).removeClass("flipbook-browser-fullscreen"), this.context.lightboxEnd();
    },
    resize: function resize() {
      var e = O(T);
      e.width(), e.height();
    }
  }, FLIPBOOK.getFlipbookSrc = function () {
    for (var e = y.getElementsByTagName("script"), t = 0; t < e.length; t++) {
      var o = String(e[t].src);
      if (o.match("flipbook\\.js") || o.match("flipbook\\.min\\.js")) return o;
      if (o.match("flipbook\\.lite\\.js") || o.match("flipbook\\.lite\\.min\\.js")) return o.replace(".lite", "");
    }

    return "";
  }, FLIPBOOK.flipbookSrc = FLIPBOOK.getFlipbookSrc(), FLIPBOOK.iscrollSrc = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/iscroll."), FLIPBOOK.threejsSrc = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/three."), FLIPBOOK.flipbookWebGlSrc = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/flipbook.webgl."), FLIPBOOK.flipbookBook3Src = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/flipbook.book3."), FLIPBOOK.flipBookSwipeSrc = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/flipbook.swipe."), FLIPBOOK.pdfjsSrc = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/pdf."), FLIPBOOK.pdfServiceSrc = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/flipbook.pdfservice."), FLIPBOOK.pdfjsworkerSrc = FLIPBOOK.flipbookSrc.replace("/flipbook.", "/pdf.worker."), FLIPBOOK.markSrc = "https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.js", FLIPBOOK.scriptsLoaded = {}, FLIPBOOK.scriptsAdded = {};
}(jQuery, window, document), FLIPBOOK.onPageLinkClick = function (e) {
  var t = e.dataset.bookid,
      o = e.dataset.page;
  o && FLIPBOOK.books[t].goToPage(Number(o));
  var i = e.dataset.url;
  i && window.open(i, "_blank");
}, function () {
  "use strict";

  var s = "undefined" != typeof window && void 0 !== window.document ? window.document : {},
      e =  true && module.exports,
      n = "undefined" != typeof Element && "ALLOW_KEYBOARD_INPUT" in Element,
      a = function () {
    for (var e, t = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]], o = 0, i = t.length, n = {}; o < i; o++) {
      if ((e = t[o]) && e[1] in s) {
        for (o = 0; o < e.length; o++) {
          n[t[0][o]] = e[o];
        }

        return n;
      }
    }

    return !1;
  }(),
      i = {
    change: a.fullscreenchange,
    error: a.fullscreenerror
  },
      t = {
    request: function request(i) {
      return new Promise(function (e) {
        var t = a.requestFullscreen,
            o = function () {
          this.off("change", o), e();
        }.bind(this);

        i = i || s.documentElement, / Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) ? i[t]() : i[t](n ? Element.ALLOW_KEYBOARD_INPUT : {}), this.on("change", o);
      }.bind(this));
    },
    exit: function exit() {
      return new Promise(function (e) {
        var t = function () {
          this.off("change", t), e();
        }.bind(this);

        s[a.exitFullscreen](), this.on("change", t);
      }.bind(this));
    },
    toggle: function toggle(e) {
      return this.isFullscreen ? this.exit() : this.request(e);
    },
    onchange: function onchange(e) {
      this.on("change", e);
    },
    onerror: function onerror(e) {
      this.on("error", e);
    },
    on: function on(e, t) {
      var o = i[e];
      o && s.addEventListener(o, t, !1);
    },
    off: function off(e, t) {
      var o = i[e];
      o && s.removeEventListener(o, t, !1);
    },
    raw: a
  };

  a ? (Object.defineProperties(t, {
    isFullscreen: {
      get: function get() {
        return Boolean(s[a.fullscreenElement]);
      }
    },
    element: {
      enumerable: !0,
      get: function get() {
        return s[a.fullscreenElement];
      }
    },
    enabled: {
      enumerable: !0,
      get: function get() {
        return Boolean(s[a.fullscreenEnabled]);
      }
    }
  }), e ? module.exports = t : window.screenfull = t) : e ? module.exports = !1 : window.screenfull = !1;
}(), function (e) {
   true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js").jQuery ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : e( true && module.exports ? __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js") : jQuery);
}(function (re) {
  "use strict";

  function i(e, f) {
    function t(e) {
      if (!(!0 === G.data(Fe + "_intouch") || 0 < re(e.target).closest(f.excludedElements, G).length)) {
        var t = e.originalEvent ? e.originalEvent : e;

        if (!t.pointerType || "mouse" != t.pointerType || 0 != f.fallbackToMouseEvents) {
          var o,
              i = t.touches,
              n = i ? i[0] : t;
          return Y = Oe, i ? X = i.length : !1 !== f.preventDefaultEvents && e.preventDefault(), Z = j = N = null, U = 1, q = V = $ = W = R = 0, (s = {})[le] = L(le), s[de] = L(de), s[he] = L(he), s[pe] = L(pe), Q = s, B(), T(0, n), !i || X === f.fingers || f.fingers === Be || k() ? (ee = z(), 2 == X && (T(1, i[1]), $ = V = I(J[0].start, J[1].start)), (f.swipeStatus || f.pinchStatus) && (o = m(t, Y))) : o = !1, !1 === o ? (m(t, Y = Me), o) : (f.hold && (ae = setTimeout(re.proxy(function () {
            G.trigger("hold", [t.target]), f.hold && (o = f.hold.call(G, t, t.target));
          }, this), f.longTapThreshold)), O(!0), null);
        }
      }

      var s;
    }

    function o(e) {
      var t,
          o,
          i,
          n,
          s,
          a,
          r,
          l,
          d = e.originalEvent ? e.originalEvent : e;

      if (Y !== ye && Y !== Me && !x()) {
        var h,
            p = d.touches,
            c = y(p ? p[0] : d);

        if (te = z(), p && (X = p.length), f.hold && clearTimeout(ae), Y = Te, 2 == X && (0 == $ ? (T(1, p[1]), $ = V = I(J[0].start, J[1].start)) : (y(p[1]), V = I(J[0].end, J[1].end), J[0].end, J[1].end, Z = U < 1 ? ue : ce), U = (V / $ * 1).toFixed(2), q = Math.abs($ - V)), X === f.fingers || f.fingers === Be || !p || k()) {
          if (N = F(c.start, c.end), function (e, t) {
            if (!1 !== f.preventDefaultEvents) if (f.allowPageScroll === ge) e.preventDefault();else {
              var o = f.allowPageScroll === fe;

              switch (t) {
                case le:
                  (f.swipeLeft && o || !o && f.allowPageScroll != Pe) && e.preventDefault();
                  break;

                case de:
                  (f.swipeRight && o || !o && f.allowPageScroll != Pe) && e.preventDefault();
                  break;

                case he:
                  (f.swipeUp && o || !o && f.allowPageScroll != Se) && e.preventDefault();
                  break;

                case pe:
                  (f.swipeDown && o || !o && f.allowPageScroll != Se) && e.preventDefault();
              }
            }
          }(e, j = F(c.last, c.end)), r = c.start, l = c.end, R = Math.round(Math.sqrt(Math.pow(l.x - r.x, 2) + Math.pow(l.y - r.y, 2))), W = C(), a = R, (s = N) != ge && (a = Math.max(a, M(s)), Q[s].distance = a), h = m(d, Y), !f.triggerOnTouchEnd || f.triggerOnTouchLeave) {
            var u = !0;

            if (f.triggerOnTouchLeave) {
              var g = {
                left: (n = (i = re(i = this)).offset()).left,
                right: n.left + i.outerWidth(),
                top: n.top,
                bottom: n.top + i.outerHeight()
              };
              t = c.end, o = g, u = t.x > o.left && t.x < o.right && t.y > o.top && t.y < o.bottom;
            }

            !f.triggerOnTouchEnd && u ? Y = b(Te) : f.triggerOnTouchLeave && !u && (Y = b(ye)), Y != Me && Y != ye || m(d, Y);
          }
        } else m(d, Y = Me);

        !1 === h && m(d, Y = Me);
      }
    }

    function i(e) {
      var t,
          o = e.originalEvent ? e.originalEvent : e,
          i = o.touches;

      if (i) {
        if (i.length && !x()) return t = o, oe = z(), ie = t.touches.length + 1, !0;
        if (i.length && x()) return !0;
      }

      return x() && (X = ie), te = z(), W = C(), d() || !l() ? m(o, Y = Me) : f.triggerOnTouchEnd || !1 === f.triggerOnTouchEnd && Y === Te ? (!1 !== f.preventDefaultEvents && !1 !== e.cancelable && e.preventDefault(), m(o, Y = ye)) : !f.triggerOnTouchEnd && w() ? r(o, Y = ye, ke) : Y === Te && m(o, Y = Me), O(!1), null;
    }

    function n() {
      V = $ = ee = te = X = 0, U = 1, B(), O(!1);
    }

    function s(e) {
      var t = e.originalEvent ? e.originalEvent : e;
      f.triggerOnTouchLeave && m(t, Y = b(ye));
    }

    function a() {
      G.unbind(A, t), G.unbind(H, n), G.unbind(_, o), G.unbind(D, i), K && G.unbind(K, s), O(!1);
    }

    function b(e) {
      var t = e,
          o = h(),
          i = l(),
          n = d();
      return !o || n ? t = Me : !i || e != Te || f.triggerOnTouchEnd && !f.triggerOnTouchLeave ? !i && e == ye && f.triggerOnTouchLeave && (t = Me) : t = ye, t;
    }

    function m(e, t) {
      var o,
          i = e.touches;
      return (c() && u() || u()) && (o = r(e, t, be)), (p() && k() || k()) && !1 !== o && (o = r(e, t, me)), S() && P() && !1 !== o ? o = r(e, t, ve) : W > f.longTapThreshold && R < xe && f.longTap && !1 !== o ? o = r(e, t, we) : 1 !== X && Le || !(isNaN(R) || R < f.threshold) || !w() || !1 === o || (o = r(e, t, ke)), t === Me && n(), t === ye && (i && i.length || n()), o;
    }

    function r(e, t, o) {
      var i;

      if (o == be) {
        if (G.trigger("swipeStatus", [t, N || null, R || 0, W || 0, X, J, j]), f.swipeStatus && !1 === (i = f.swipeStatus.call(G, e, t, N || null, R || 0, W || 0, X, J, j))) return !1;

        if (t == ye && c()) {
          if (clearTimeout(se), clearTimeout(ae), G.trigger("swipe", [N, R, W, X, J, j]), f.swipe && !1 === (i = f.swipe.call(G, e, N, R, W, X, J, j))) return !1;

          switch (N) {
            case le:
              G.trigger("swipeLeft", [N, R, W, X, J, j]), f.swipeLeft && (i = f.swipeLeft.call(G, e, N, R, W, X, J, j));
              break;

            case de:
              G.trigger("swipeRight", [N, R, W, X, J, j]), f.swipeRight && (i = f.swipeRight.call(G, e, N, R, W, X, J, j));
              break;

            case he:
              G.trigger("swipeUp", [N, R, W, X, J, j]), f.swipeUp && (i = f.swipeUp.call(G, e, N, R, W, X, J, j));
              break;

            case pe:
              G.trigger("swipeDown", [N, R, W, X, J, j]), f.swipeDown && (i = f.swipeDown.call(G, e, N, R, W, X, J, j));
          }
        }
      }

      if (o == me) {
        if (G.trigger("pinchStatus", [t, Z || null, q || 0, W || 0, X, U, J]), f.pinchStatus && !1 === (i = f.pinchStatus.call(G, e, t, Z || null, q || 0, W || 0, X, U, J))) return !1;
        if (t == ye && p()) switch (Z) {
          case ce:
            G.trigger("pinchIn", [Z || null, q || 0, W || 0, X, U, J]), f.pinchIn && (i = f.pinchIn.call(G, e, Z || null, q || 0, W || 0, X, U, J));
            break;

          case ue:
            G.trigger("pinchOut", [Z || null, q || 0, W || 0, X, U, J]), f.pinchOut && (i = f.pinchOut.call(G, e, Z || null, q || 0, W || 0, X, U, J));
        }
      }

      return o == ke ? t !== Me && t !== ye || (clearTimeout(se), clearTimeout(ae), P() && !S() ? (ne = z(), se = setTimeout(re.proxy(function () {
        ne = null, G.trigger("tap", [e.target]), f.tap && (i = f.tap.call(G, e, e.target));
      }, this), f.doubleTapThreshold)) : (ne = null, G.trigger("tap", [e.target]), f.tap && (i = f.tap.call(G, e, e.target)))) : o == ve ? t !== Me && t !== ye || (clearTimeout(se), clearTimeout(ae), ne = null, G.trigger("doubletap", [e.target]), f.doubleTap && (i = f.doubleTap.call(G, e, e.target))) : o == we && (t !== Me && t !== ye || (clearTimeout(se), ne = null, G.trigger("longtap", [e.target]), f.longTap && (i = f.longTap.call(G, e, e.target)))), i;
    }

    function l() {
      var e = !0;
      return null !== f.threshold && (e = R >= f.threshold), e;
    }

    function d() {
      var e = !1;
      return null !== f.cancelThreshold && null !== N && (e = M(N) - R >= f.cancelThreshold), e;
    }

    function h() {
      return !(f.maxTimeThreshold && W >= f.maxTimeThreshold);
    }

    function p() {
      var e = g(),
          t = v(),
          o = null === f.pinchThreshold || q >= f.pinchThreshold;
      return e && t && o;
    }

    function k() {
      return f.pinchStatus || f.pinchIn || f.pinchOut;
    }

    function c() {
      var e = h(),
          t = l(),
          o = g(),
          i = v();
      return !d() && i && o && t && e;
    }

    function u() {
      return f.swipe || f.swipeStatus || f.swipeLeft || f.swipeRight || f.swipeUp || f.swipeDown;
    }

    function g() {
      return X === f.fingers || f.fingers === Be || !Le;
    }

    function v() {
      return 0 !== J[0].end.x;
    }

    function w() {
      return f.tap;
    }

    function P() {
      return !!f.doubleTap;
    }

    function S() {
      if (null == ne) return !1;
      var e = z();
      return P() && e - ne <= f.doubleTapThreshold;
    }

    function B() {
      ie = oe = 0;
    }

    function x() {
      var e = !1;
      oe && z() - oe <= f.fingerReleaseThreshold && (e = !0);
      return e;
    }

    function O(e) {
      G && (!0 === e ? (G.bind(_, o), G.bind(D, i), K && G.bind(K, s)) : (G.unbind(_, o, !1), G.unbind(D, i, !1), K && G.unbind(K, s, !1)), G.data(Fe + "_intouch", !0 === e));
    }

    function T(e, t) {
      var o = {
        start: {
          x: 0,
          y: 0
        },
        last: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        }
      };
      return o.start.x = o.last.x = o.end.x = t.pageX || t.clientX, o.start.y = o.last.y = o.end.y = t.pageY || t.clientY, J[e] = o;
    }

    function y(e) {
      var t = void 0 !== e.identifier ? e.identifier : 0,
          o = J[t] || null;
      return null === o && (o = T(t, e)), o.last.x = o.end.x, o.last.y = o.end.y, o.end.x = e.pageX || e.clientX, o.end.y = e.pageY || e.clientY, o;
    }

    function M(e) {
      if (Q[e]) return Q[e].distance;
    }

    function L(e) {
      return {
        direction: e,
        distance: 0
      };
    }

    function C() {
      return te - ee;
    }

    function I(e, t) {
      var o = Math.abs(e.x - t.x),
          i = Math.abs(e.y - t.y);
      return Math.round(Math.sqrt(o * o + i * i));
    }

    function F(e, t) {
      if (i = t, (o = e).x == i.x && o.y == i.y) return ge;
      var o,
          i,
          n,
          s,
          a,
          r,
          l,
          d,
          h = (s = t, a = (n = e).x - s.x, r = s.y - n.y, l = Math.atan2(r, a), (d = Math.round(180 * l / Math.PI)) < 0 && (d = 360 - Math.abs(d)), d);
      return h <= 45 && 0 <= h || h <= 360 && 315 <= h ? le : 135 <= h && h <= 225 ? de : 45 < h && h < 135 ? pe : he;
    }

    function z() {
      return new Date().getTime();
    }

    f = re.extend({}, f);

    var E = Le || Ie || !f.fallbackToMouseEvents,
        A = E ? Ie ? Ce ? "MSPointerDown" : "pointerdown" : "touchstart" : "mousedown",
        _ = E ? Ie ? Ce ? "MSPointerMove" : "pointermove" : "touchmove" : "mousemove",
        D = E ? Ie ? Ce ? "MSPointerUp" : "pointerup" : "touchend" : "mouseup",
        K = E ? Ie ? "mouseleave" : null : "mouseleave",
        H = Ie ? Ce ? "MSPointerCancel" : "pointercancel" : "touchcancel",
        R = 0,
        N = null,
        j = null,
        W = 0,
        $ = 0,
        V = 0,
        U = 1,
        q = 0,
        Z = 0,
        Q = null,
        G = re(e),
        Y = "start",
        X = 0,
        J = {},
        ee = 0,
        te = 0,
        oe = 0,
        ie = 0,
        ne = 0,
        se = null,
        ae = null;

    try {
      G.bind(A, t), G.bind(H, n);
    } catch (e) {
      re.error("events not supported " + A + "," + H + " on jQuery.swipe");
    }

    this.enable = function () {
      return this.disable(), G.bind(A, t), G.bind(H, n), G;
    }, this.disable = function () {
      return a(), G;
    }, this.destroy = function () {
      a(), G.data(Fe, null), G = null;
    }, this.option = function (e, t) {
      if ("object" == _typeof(e)) f = re.extend(f, e);else if (void 0 !== f[e]) {
        if (void 0 === t) return f[e];
        f[e] = t;
      } else {
        if (!e) return f;
        re.error("Option " + e + " does not exist on jQuery.swipe.options");
      }
      return null;
    };
  }

  var le = "left",
      de = "right",
      he = "up",
      pe = "down",
      ce = "in",
      ue = "out",
      ge = "none",
      fe = "auto",
      be = "swipe",
      me = "pinch",
      ke = "tap",
      ve = "doubletap",
      we = "longtap",
      Pe = "horizontal",
      Se = "vertical",
      Be = "all",
      xe = 10,
      Oe = "start",
      Te = "move",
      ye = "end",
      Me = "cancel",
      Le = "ontouchstart" in window,
      Ce = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !Le,
      Ie = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !Le,
      Fe = "TouchSwipe";
  re.fn.swipe = function (e) {
    var t = re(this),
        o = t.data(Fe);

    if (o && "string" == typeof e) {
      if (o[e]) return o[e].apply(o, Array.prototype.slice.call(arguments, 1));
      re.error("Method " + e + " does not exist on jQuery.swipe");
    } else if (o && "object" == _typeof(e)) o.option.apply(o, arguments);else if (!(o || "object" != _typeof(e) && e)) return function (o) {
      return !o || void 0 !== o.allowPageScroll || void 0 === o.swipe && void 0 === o.swipeStatus || (o.allowPageScroll = ge), void 0 !== o.click && void 0 === o.tap && (o.tap = o.click), o = o || {}, o = re.extend({}, re.fn.swipe.defaults, o), this.each(function () {
        var e = re(this),
            t = e.data(Fe);
        t || (t = new i(this, o), e.data(Fe, t));
      });
    }.apply(this, arguments);

    return t;
  }, re.fn.swipe.version = "1.6.18", re.fn.swipe.defaults = {
    fingers: 1,
    threshold: 75,
    cancelThreshold: null,
    pinchThreshold: 20,
    maxTimeThreshold: null,
    fingerReleaseThreshold: 250,
    longTapThreshold: 500,
    doubleTapThreshold: 200,
    swipe: null,
    swipeLeft: null,
    swipeRight: null,
    swipeUp: null,
    swipeDown: null,
    swipeStatus: null,
    pinchIn: null,
    pinchOut: null,
    pinchStatus: null,
    click: null,
    tap: null,
    doubleTap: null,
    longTap: null,
    hold: null,
    triggerOnTouchEnd: !0,
    triggerOnTouchLeave: !1,
    allowPageScroll: "auto",
    fallbackToMouseEvents: !0,
    excludedElements: ".noSwipe",
    preventDefaultEvents: !0
  }, re.fn.swipe.phases = {
    PHASE_START: Oe,
    PHASE_MOVE: Te,
    PHASE_END: ye,
    PHASE_CANCEL: Me
  }, re.fn.swipe.directions = {
    LEFT: le,
    RIGHT: de,
    UP: he,
    DOWN: pe,
    IN: ce,
    OUT: ue
  }, re.fn.swipe.pageScroll = {
    NONE: ge,
    HORIZONTAL: Pe,
    VERTICAL: Se,
    AUTO: fe
  }, re.fn.swipe.fingers = {
    ONE: 1,
    TWO: 2,
    THREE: 3,
    FOUR: 4,
    FIVE: 5,
    ALL: Be
  };
}), function (e) {
  if ("object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
}(function () {
  function e() {}

  "classList" in document.documentElement || !Object.defineProperty || "undefined" == typeof HTMLElement || Object.defineProperty(HTMLElement.prototype, "classList", {
    get: function get() {
      var e, n, t;
      return t = function t(i) {
        return function (e) {
          var t, o;
          o = (t = n.className.split(/\s+/)).indexOf(e), i(t, o, e), n.className = t.join(" ");
        };
      }, n = this, e = {
        add: t(function (e, t, o) {
          ~t || e.push(o);
        }),
        remove: t(function (e, t) {
          ~t && e.splice(t, 1);
        }),
        toggle: t(function (e, t, o) {
          ~t ? e.splice(t, 1) : e.push(o);
        }),
        contains: function contains(e) {
          return !!~n.className.split(/\s+/).indexOf(e);
        },
        item: function item(e) {
          return n.className.split(/\s+/)[e] || null;
        }
      }, Object.defineProperty(e, "length", {
        get: function get() {
          return n.className.split(/\s+/).length;
        }
      }), e;
    }
  }), String.prototype.to_rfc3986 = function () {
    return encodeURIComponent(this).replace(/[!'()*]/g, function (e) {
      return "%" + e.charCodeAt(0).toString(16);
    });
  }, e.prototype.extend = function (e, t, o) {
    var i, n;

    for (n in t) {
      (i = void 0 !== e[n]) && "object" == _typeof(t[n]) ? this.extend(e[n], t[n], o) : !o && i || (e[n] = t[n]);
    }
  }, e.prototype.hide = function (e) {
    return e.style.display = "none";
  }, e.prototype.show = function (e) {
    return e.style.display = "block";
  }, e.prototype.has_class = function (e, t) {
    return e.classList.contains(t);
  }, e.prototype.add_class = function (e, t) {
    return e.classList.add(t);
  }, e.prototype.remove_class = function (e, t) {
    return e.classList.remove(t);
  }, e.prototype.is_encoded = function (e) {
    return e = e.to_rfc3986(), decodeURIComponent(e) !== e;
  }, e.prototype.encode = function (e) {
    return void 0 === e || this.is_encoded(e) ? e : e.to_rfc3986();
  }, e.prototype.popup = function (e, t) {
    var o, i, n, s;
    return null == t && (t = {}), (i = {
      width: 500,
      height: 350
    }).top = screen.height / 2 - i.height / 2, i.left = screen.width / 2 - i.width / 2, n = (n = function () {
      var e;

      for (o in e = [], t) {
        s = t[o], e.push(o + "=" + this.encode(s));
      }

      return e;
    }.call(this).join("&")) && "?" + n, window.open(e + n, "targetWindow", "toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes,left=" + i.left + ",top=" + i.top + ",width=" + i.width + ",height=" + i.height);
  };
  var n = {}.hasOwnProperty;
  return function (e, t) {
    function o() {
      this.constructor = e;
    }

    for (var i in t) {
      n.call(t, i) && (e[i] = t[i]);
    }

    o.prototype = t.prototype, e.prototype = new o(), e.__super__ = t.prototype;
  }(t, e), t.prototype.setup = function (e, t) {
    var o, i, n, s;

    for (n = [e], this.extend(this.config, t, !0), this.set_global_configuration(), this.normalize_network_configuration(), this.config.networks.facebook.enabled && this.config.networks.facebook.load_sdk && this.inject_facebook_sdk(), i = o = 0, s = n.length; o < s; i = ++o) {
      this.setup_instance(e, i);
    }
  }, t.prototype.setup_instance = function (e, t) {
    var o, i, n, s, a, r, l, d;

    for (s = e, this.add_class(s, "sharer-" + t), this.inject_html(s), document.getElementById("flipbook-share-facebook").style.display = this.config.networks.facebook.display, document.getElementById("flipbook-share-twitter").style.display = this.config.networks.twitter.display, document.getElementById("flipbook-share-pinterest").style.display = this.config.networks.pinterest.display, document.getElementById("flipbook-share-email").style.display = this.config.networks.email.display, s.getElementsByTagName("label")[0], i = s.getElementsByClassName("social")[0], l = s.getElementsByTagName("li"), this.add_class(i, "networks-" + this.config.enabled_networks), s.addEventListener("click", function (e) {
      return function () {
        return e.event_toggle(i);
      };
    }(this)), o = this, d = [], t = n = 0, a = l.length; n < a; t = ++n) {
      r = l[t], d.push(r.addEventListener("click", function () {
        return o.event_network(s, this), o.event_close(i);
      }));
    }

    return d;
  }, t.prototype.event_toggle = function (e) {
    return this.has_class(e, "active") ? this.event_close(e) : this.event_open(e);
  }, t.prototype.event_open = function (e) {
    return this.has_class(e, "load") && this.remove_class(e, "load"), this.add_class(e, "active");
  }, t.prototype.event_close = function (e) {
    return this.remove_class(e, "active");
  }, t.prototype.event_network = function (e, t) {
    var o;
    return o = t.getAttribute("data-network"), this.hook("before", o, e), this["network_" + o](), this.hook("after", o, e);
  }, t.prototype.open = function () {
    return this["public"]("open");
  }, t.prototype.close = function () {
    return this["public"]("close");
  }, t.prototype.toggle = function () {
    return this["public"]("toggle");
  }, t.prototype["public"] = function (e) {
    var t, o, i, n, s, a;

    for (a = [], i = o = 0, n = (s = document.querySelectorAll(this.element)).length; o < n; i = ++o) {
      t = s[i].getElementsByClassName("social")[0], a.push(this["event_" + e](t));
    }

    return a;
  }, t.prototype.network_facebook = function () {
    return this.config.networks.facebook.load_sdk ? window.FB ? FB.ui({
      method: "feed",
      name: this.config.networks.facebook.title,
      link: this.config.networks.facebook.url,
      picture: this.config.networks.facebook.image,
      caption: this.config.networks.facebook.caption,
      description: this.config.networks.facebook.description
    }) : console.error("The Facebook JS SDK hasn't loaded yet.") : this.popup("https://www.facebook.com/sharer/sharer.php", {
      u: this.config.networks.facebook.url
    });
  }, t.prototype.network_twitter = function () {
    return this.popup("https://twitter.com/intent/tweet", {
      text: this.config.networks.twitter.description,
      url: this.config.networks.twitter.url
    });
  }, t.prototype.network_google_plus = function () {
    return this.popup("https://plus.google.com/share", {
      url: this.config.networks.google_plus.url
    });
  }, t.prototype.network_pinterest = function () {
    return this.popup("https://www.pinterest.com/pin/create/button", {
      url: this.config.networks.pinterest.url,
      media: this.config.networks.pinterest.image,
      description: this.config.networks.pinterest.description
    });
  }, t.prototype.network_email = function () {
    return this.popup("mailto:", {
      subject: this.config.networks.email.title,
      body: this.config.networks.email.description + "%0D%0A" + this.config.networks.email.url || this.config.url
    });
  }, t.prototype.inject_stylesheet = function (e) {
    var t;
    return this.el.head.querySelector('link[href="' + e + '"]') ? void 0 : ((t = document.createElement("link")).setAttribute("rel", "stylesheet"), t.setAttribute("href", e), this.el.head.appendChild(t));
  }, t.prototype.inject_html = function (e) {
    return e.innerHTML = "<div class='social load " + this.config.ui.flyout + "'><ul><li id='flipbook-share-pinterest' data-network='pinterest'><i class='fab fa-pinterest-p skin-color'></i></li><li id='flipbook-share-twitter' data-network='twitter'><i class='fab fa-twitter skin-color'></i></li><li id='flipbook-share-facebook' data-network='facebook'><i class='fab fa-facebook-f skin-color'></i></li><li id='flipbook-share-email' data-network='email'><i class='fas fa-at skin-color'></i></li></ul></div>";
  }, t.prototype.inject_facebook_sdk = function () {
    var e, t;
    return window.FB || !this.config.networks.facebook.app_id || this.el.body.querySelector("#fb-root") ? void 0 : ((t = document.createElement("script")).text = "window.fbAsyncInit=function(){FB.init({appId:'" + this.config.networks.facebook.app_id + "',status:true,xfbml:true})};(function(e,t,n){var r,i=e.getElementsByTagName(t)[0];if(e.getElementById(n)){return}r=e.createElement(t);r.id=n;r.src='" + this.config.protocol + "connect.facebook.net/en_US/all.js';i.parentNode.insertBefore(r,i)})(document,'script','facebook-jssdk')", (e = document.createElement("div")).id = "fb-root", this.el.body.appendChild(e), this.el.body.appendChild(t));
  }, t.prototype.hook = function (e, t, o) {
    var i, n;
    "function" != typeof (i = this.config.networks[t][e]) || void 0 !== (n = i.call(this.config.networks[t], o)) && (n = this.normalize_filter_config_updates(n), this.extend(this.config.networks[t], n, !0), this.normalize_network_configuration());
  }, t.prototype.default_title = function () {
    var e;
    return (e = document.querySelector('meta[property="og:title"]') || document.querySelector('meta[name="twitter:title"]')) ? e.getAttribute("content") : (e = document.querySelector("title")) ? e.innerText : void 0;
  }, t.prototype.default_image = function () {
    var e;
    return (e = document.querySelector('meta[property="og:image"]') || document.querySelector('meta[name="twitter:image"]')) ? e.getAttribute("content") : void 0;
  }, t.prototype.default_description = function () {
    var e;
    return (e = document.querySelector('meta[property="og:description"]') || document.querySelector('meta[name="twitter:description"]') || document.querySelector('meta[name="description"]')) ? e.getAttribute("content") : "";
  }, t.prototype.set_global_configuration = function () {
    var e, t, o, i, n;

    for (t in n = [], i = this.config.networks) {
      for (o in i[t]) {
        null == this.config.networks[t][o] && (this.config.networks[t][o] = this.config[o]);
      }

      this.config.networks[t].enabled ? (e = "block", this.config.enabled_networks += 1) : e = "none", n.push(this.config.networks[t].display = e);
    }

    return n;
  }, t.prototype.normalize_network_configuration = function () {
    return this.config.networks.facebook.app_id || (this.config.networks.facebook.load_sdk = !1), this.is_encoded(this.config.networks.twitter.description) || (this.config.networks.twitter.description = encodeURIComponent(this.config.networks.twitter.description)), "number" == typeof this.config.networks.facebook.app_id ? this.config.networks.facebook.app_id = this.config.networks.facebook.app_id.toString() : void 0;
  }, t.prototype.normalize_filter_config_updates = function (e) {
    return this.config.networks.facebook.app_id !== e.app_id && (console.warn("You are unable to change the Facebook app_id after the button has been initialized. Please update your Facebook filters accordingly."), delete e.app_id), this.config.networks.facebook.load_sdk !== e.load_sdk && (console.warn("You are unable to change the Facebook load_sdk option after the button has been initialized. Please update your Facebook filters accordingly."), delete e.app_id), e;
  }, t;

  function t(e, t) {
    return this.element = e, this.el = {
      head: document.getElementsByTagName("head")[0],
      body: document.getElementsByTagName("body")[0]
    }, this.config = {
      enabled_networks: 0,
      protocol: -1 === ["http", "https"].indexOf(window.location.href.split(":")[0]) ? "https://" : "//",
      url: window.location.href,
      caption: null,
      title: this.default_title(),
      image: this.default_image(),
      description: this.default_description(),
      ui: {
        flyout: "top center",
        button_text: "Share",
        button_font: !0,
        icon_font: !0
      },
      networks: {
        twitter: {
          enabled: !0,
          url: null,
          description: null
        },
        facebook: {
          enabled: !0,
          load_sdk: !0,
          url: null,
          app_id: null,
          title: null,
          caption: null,
          description: null,
          image: null
        },
        pinterest: {
          enabled: !0,
          url: null,
          image: null,
          description: null
        },
        email: {
          enabled: !0,
          title: null,
          description: null,
          url: null
        }
      }
    }, this.setup(this.element, t), this;
  }
});

/***/ }),

/***/ "./resources/js/flipbook/jquery-ui.min.js":
/*!************************************************!*\
  !*** ./resources/js/flipbook/jquery-ui.min.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! jQuery UI - v1.9.2 - 2012-11-23
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2012 jQuery Foundation and other contributors; Licensed MIT */
(function (e, t) {
  function i(t, n) {
    var r,
        i,
        o,
        u = t.nodeName.toLowerCase();
    return "area" === u ? (r = t.parentNode, i = r.name, !t.href || !i || r.nodeName.toLowerCase() !== "map" ? !1 : (o = e("img[usemap=#" + i + "]")[0], !!o && s(o))) : (/input|select|textarea|button|object/.test(u) ? !t.disabled : "a" === u ? t.href || n : n) && s(t);
  }

  function s(t) {
    return e.expr.filters.visible(t) && !e(t).parents().andSelf().filter(function () {
      return e.css(this, "visibility") === "hidden";
    }).length;
  }

  var n = 0,
      r = /^ui-id-\d+$/;
  e.ui = e.ui || {};
  if (e.ui.version) return;
  e.extend(e.ui, {
    version: "1.9.2",
    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      NUMPAD_ADD: 107,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      NUMPAD_ENTER: 108,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_SUBTRACT: 109,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }
  }), e.fn.extend({
    _focus: e.fn.focus,
    focus: function focus(t, n) {
      return typeof t == "number" ? this.each(function () {
        var r = this;
        setTimeout(function () {
          e(r).focus(), n && n.call(r);
        }, t);
      }) : this._focus.apply(this, arguments);
    },
    scrollParent: function scrollParent() {
      var t;
      return e.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? t = this.parents().filter(function () {
        return /(relative|absolute|fixed)/.test(e.css(this, "position")) && /(auto|scroll)/.test(e.css(this, "overflow") + e.css(this, "overflow-y") + e.css(this, "overflow-x"));
      }).eq(0) : t = this.parents().filter(function () {
        return /(auto|scroll)/.test(e.css(this, "overflow") + e.css(this, "overflow-y") + e.css(this, "overflow-x"));
      }).eq(0), /fixed/.test(this.css("position")) || !t.length ? e(document) : t;
    },
    zIndex: function zIndex(n) {
      if (n !== t) return this.css("zIndex", n);

      if (this.length) {
        var r = e(this[0]),
            i,
            s;

        while (r.length && r[0] !== document) {
          i = r.css("position");

          if (i === "absolute" || i === "relative" || i === "fixed") {
            s = parseInt(r.css("zIndex"), 10);
            if (!isNaN(s) && s !== 0) return s;
          }

          r = r.parent();
        }
      }

      return 0;
    },
    uniqueId: function uniqueId() {
      return this.each(function () {
        this.id || (this.id = "ui-id-" + ++n);
      });
    },
    removeUniqueId: function removeUniqueId() {
      return this.each(function () {
        r.test(this.id) && e(this).removeAttr("id");
      });
    }
  }), e.extend(e.expr[":"], {
    data: e.expr.createPseudo ? e.expr.createPseudo(function (t) {
      return function (n) {
        return !!e.data(n, t);
      };
    }) : function (t, n, r) {
      return !!e.data(t, r[3]);
    },
    focusable: function focusable(t) {
      return i(t, !isNaN(e.attr(t, "tabindex")));
    },
    tabbable: function tabbable(t) {
      var n = e.attr(t, "tabindex"),
          r = isNaN(n);
      return (r || n >= 0) && i(t, !r);
    }
  }), e(function () {
    var t = document.body,
        n = t.appendChild(n = document.createElement("div"));
    n.offsetHeight, e.extend(n.style, {
      minHeight: "100px",
      height: "auto",
      padding: 0,
      borderWidth: 0
    }), e.support.minHeight = n.offsetHeight === 100, e.support.selectstart = "onselectstart" in n, t.removeChild(n).style.display = "none";
  }), e("<a>").outerWidth(1).jquery || e.each(["Width", "Height"], function (n, r) {
    function u(t, n, r, s) {
      return e.each(i, function () {
        n -= parseFloat(e.css(t, "padding" + this)) || 0, r && (n -= parseFloat(e.css(t, "border" + this + "Width")) || 0), s && (n -= parseFloat(e.css(t, "margin" + this)) || 0);
      }), n;
    }

    var i = r === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
        s = r.toLowerCase(),
        o = {
      innerWidth: e.fn.innerWidth,
      innerHeight: e.fn.innerHeight,
      outerWidth: e.fn.outerWidth,
      outerHeight: e.fn.outerHeight
    };
    e.fn["inner" + r] = function (n) {
      return n === t ? o["inner" + r].call(this) : this.each(function () {
        e(this).css(s, u(this, n) + "px");
      });
    }, e.fn["outer" + r] = function (t, n) {
      return typeof t != "number" ? o["outer" + r].call(this, t) : this.each(function () {
        e(this).css(s, u(this, t, !0, n) + "px");
      });
    };
  }), e("<a>").data("a-b", "a").removeData("a-b").data("a-b") && (e.fn.removeData = function (t) {
    return function (n) {
      return arguments.length ? t.call(this, e.camelCase(n)) : t.call(this);
    };
  }(e.fn.removeData)), function () {
    var t = /msie ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) || [];
    e.ui.ie = t.length ? !0 : !1, e.ui.ie6 = parseFloat(t[1], 10) === 6;
  }(), e.fn.extend({
    disableSelection: function disableSelection() {
      return this.bind((e.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function (e) {
        e.preventDefault();
      });
    },
    enableSelection: function enableSelection() {
      return this.unbind(".ui-disableSelection");
    }
  }), e.extend(e.ui, {
    plugin: {
      add: function add(t, n, r) {
        var i,
            s = e.ui[t].prototype;

        for (i in r) {
          s.plugins[i] = s.plugins[i] || [], s.plugins[i].push([n, r[i]]);
        }
      },
      call: function call(e, t, n) {
        var r,
            i = e.plugins[t];
        if (!i || !e.element[0].parentNode || e.element[0].parentNode.nodeType === 11) return;

        for (r = 0; r < i.length; r++) {
          e.options[i[r][0]] && i[r][1].apply(e.element, n);
        }
      }
    },
    contains: e.contains,
    hasScroll: function hasScroll(t, n) {
      if (e(t).css("overflow") === "hidden") return !1;
      var r = n && n === "left" ? "scrollLeft" : "scrollTop",
          i = !1;
      return t[r] > 0 ? !0 : (t[r] = 1, i = t[r] > 0, t[r] = 0, i);
    },
    isOverAxis: function isOverAxis(e, t, n) {
      return e > t && e < t + n;
    },
    isOver: function isOver(t, n, r, i, s, o) {
      return e.ui.isOverAxis(t, r, s) && e.ui.isOverAxis(n, i, o);
    }
  });
})(jQuery), function (e, t) {
  var n = 0,
      r = Array.prototype.slice,
      i = e.cleanData;
  e.cleanData = function (t) {
    for (var n = 0, r; (r = t[n]) != null; n++) {
      try {
        e(r).triggerHandler("remove");
      } catch (s) {}
    }

    i(t);
  }, e.widget = function (t, n, r) {
    var i,
        s,
        o,
        u,
        a = t.split(".")[0];
    t = t.split(".")[1], i = a + "-" + t, r || (r = n, n = e.Widget), e.expr[":"][i.toLowerCase()] = function (t) {
      return !!e.data(t, i);
    }, e[a] = e[a] || {}, s = e[a][t], o = e[a][t] = function (e, t) {
      if (!this._createWidget) return new o(e, t);
      arguments.length && this._createWidget(e, t);
    }, e.extend(o, s, {
      version: r.version,
      _proto: e.extend({}, r),
      _childConstructors: []
    }), u = new n(), u.options = e.widget.extend({}, u.options), e.each(r, function (t, i) {
      e.isFunction(i) && (r[t] = function () {
        var e = function e() {
          return n.prototype[t].apply(this, arguments);
        },
            r = function r(e) {
          return n.prototype[t].apply(this, e);
        };

        return function () {
          var t = this._super,
              n = this._superApply,
              s;
          return this._super = e, this._superApply = r, s = i.apply(this, arguments), this._super = t, this._superApply = n, s;
        };
      }());
    }), o.prototype = e.widget.extend(u, {
      widgetEventPrefix: s ? u.widgetEventPrefix : t
    }, r, {
      constructor: o,
      namespace: a,
      widgetName: t,
      widgetBaseClass: i,
      widgetFullName: i
    }), s ? (e.each(s._childConstructors, function (t, n) {
      var r = n.prototype;
      e.widget(r.namespace + "." + r.widgetName, o, n._proto);
    }), delete s._childConstructors) : n._childConstructors.push(o), e.widget.bridge(t, o);
  }, e.widget.extend = function (n) {
    var i = r.call(arguments, 1),
        s = 0,
        o = i.length,
        u,
        a;

    for (; s < o; s++) {
      for (u in i[s]) {
        a = i[s][u], i[s].hasOwnProperty(u) && a !== t && (e.isPlainObject(a) ? n[u] = e.isPlainObject(n[u]) ? e.widget.extend({}, n[u], a) : e.widget.extend({}, a) : n[u] = a);
      }
    }

    return n;
  }, e.widget.bridge = function (n, i) {
    var s = i.prototype.widgetFullName || n;

    e.fn[n] = function (o) {
      var u = typeof o == "string",
          a = r.call(arguments, 1),
          f = this;
      return o = !u && a.length ? e.widget.extend.apply(null, [o].concat(a)) : o, u ? this.each(function () {
        var r,
            i = e.data(this, s);
        if (!i) return e.error("cannot call methods on " + n + " prior to initialization; " + "attempted to call method '" + o + "'");
        if (!e.isFunction(i[o]) || o.charAt(0) === "_") return e.error("no such method '" + o + "' for " + n + " widget instance");
        r = i[o].apply(i, a);
        if (r !== i && r !== t) return f = r && r.jquery ? f.pushStack(r.get()) : r, !1;
      }) : this.each(function () {
        var t = e.data(this, s);
        t ? t.option(o || {})._init() : e.data(this, s, new i(o, this));
      }), f;
    };
  }, e.Widget = function () {}, e.Widget._childConstructors = [], e.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      disabled: !1,
      create: null
    },
    _createWidget: function _createWidget(t, r) {
      r = e(r || this.defaultElement || this)[0], this.element = e(r), this.uuid = n++, this.eventNamespace = "." + this.widgetName + this.uuid, this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), this.bindings = e(), this.hoverable = e(), this.focusable = e(), r !== this && (e.data(r, this.widgetName, this), e.data(r, this.widgetFullName, this), this._on(!0, this.element, {
        remove: function remove(e) {
          e.target === r && this.destroy();
        }
      }), this.document = e(r.style ? r.ownerDocument : r.document || r), this.window = e(this.document[0].defaultView || this.document[0].parentWindow)), this._create(), this._trigger("create", null, this._getCreateEventData()), this._init();
    },
    _getCreateOptions: e.noop,
    _getCreateEventData: e.noop,
    _create: e.noop,
    _init: e.noop,
    destroy: function destroy() {
      this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)), this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled"), this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus");
    },
    _destroy: e.noop,
    widget: function widget() {
      return this.element;
    },
    option: function option(n, r) {
      var i = n,
          s,
          o,
          u;
      if (arguments.length === 0) return e.widget.extend({}, this.options);

      if (typeof n == "string") {
        i = {}, s = n.split("."), n = s.shift();

        if (s.length) {
          o = i[n] = e.widget.extend({}, this.options[n]);

          for (u = 0; u < s.length - 1; u++) {
            o[s[u]] = o[s[u]] || {}, o = o[s[u]];
          }

          n = s.pop();
          if (r === t) return o[n] === t ? null : o[n];
          o[n] = r;
        } else {
          if (r === t) return this.options[n] === t ? null : this.options[n];
          i[n] = r;
        }
      }

      return this._setOptions(i), this;
    },
    _setOptions: function _setOptions(e) {
      var t;

      for (t in e) {
        this._setOption(t, e[t]);
      }

      return this;
    },
    _setOption: function _setOption(e, t) {
      return this.options[e] = t, e === "disabled" && (this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!t).attr("aria-disabled", t), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")), this;
    },
    enable: function enable() {
      return this._setOption("disabled", !1);
    },
    disable: function disable() {
      return this._setOption("disabled", !0);
    },
    _on: function _on(t, n, r) {
      var i,
          s = this;
      typeof t != "boolean" && (r = n, n = t, t = !1), r ? (n = i = e(n), this.bindings = this.bindings.add(n)) : (r = n, n = this.element, i = this.widget()), e.each(r, function (r, o) {
        function u() {
          if (!t && (s.options.disabled === !0 || e(this).hasClass("ui-state-disabled"))) return;
          return (typeof o == "string" ? s[o] : o).apply(s, arguments);
        }

        typeof o != "string" && (u.guid = o.guid = o.guid || u.guid || e.guid++);
        var a = r.match(/^(\w+)\s*(.*)$/),
            f = a[1] + s.eventNamespace,
            l = a[2];
        l ? i.delegate(l, f, u) : n.bind(f, u);
      });
    },
    _off: function _off(e, t) {
      t = (t || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, e.unbind(t).undelegate(t);
    },
    _delay: function _delay(e, t) {
      function n() {
        return (typeof e == "string" ? r[e] : e).apply(r, arguments);
      }

      var r = this;
      return setTimeout(n, t || 0);
    },
    _hoverable: function _hoverable(t) {
      this.hoverable = this.hoverable.add(t), this._on(t, {
        mouseenter: function mouseenter(t) {
          e(t.currentTarget).addClass("ui-state-hover");
        },
        mouseleave: function mouseleave(t) {
          e(t.currentTarget).removeClass("ui-state-hover");
        }
      });
    },
    _focusable: function _focusable(t) {
      this.focusable = this.focusable.add(t), this._on(t, {
        focusin: function focusin(t) {
          e(t.currentTarget).addClass("ui-state-focus");
        },
        focusout: function focusout(t) {
          e(t.currentTarget).removeClass("ui-state-focus");
        }
      });
    },
    _trigger: function _trigger(t, n, r) {
      var i,
          s,
          o = this.options[t];
      r = r || {}, n = e.Event(n), n.type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), n.target = this.element[0], s = n.originalEvent;
      if (s) for (i in s) {
        i in n || (n[i] = s[i]);
      }
      return this.element.trigger(n, r), !(e.isFunction(o) && o.apply(this.element[0], [n].concat(r)) === !1 || n.isDefaultPrevented());
    }
  }, e.each({
    show: "fadeIn",
    hide: "fadeOut"
  }, function (t, n) {
    e.Widget.prototype["_" + t] = function (r, i, s) {
      typeof i == "string" && (i = {
        effect: i
      });
      var o,
          u = i ? i === !0 || typeof i == "number" ? n : i.effect || n : t;
      i = i || {}, typeof i == "number" && (i = {
        duration: i
      }), o = !e.isEmptyObject(i), i.complete = s, i.delay && r.delay(i.delay), o && e.effects && (e.effects.effect[u] || e.uiBackCompat !== !1 && e.effects[u]) ? r[t](i) : u !== t && r[u] ? r[u](i.duration, i.easing, s) : r.queue(function (n) {
        e(this)[t](), s && s.call(r[0]), n();
      });
    };
  }), e.uiBackCompat !== !1 && (e.Widget.prototype._getCreateOptions = function () {
    return e.metadata && e.metadata.get(this.element[0])[this.widgetName];
  });
}(jQuery), function (e, t) {
  var n = !1;
  e(document).mouseup(function (e) {
    n = !1;
  }), e.widget("ui.mouse", {
    version: "1.9.2",
    options: {
      cancel: "input,textarea,button,select,option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function _mouseInit() {
      var t = this;
      this.element.bind("mousedown." + this.widgetName, function (e) {
        return t._mouseDown(e);
      }).bind("click." + this.widgetName, function (n) {
        if (!0 === e.data(n.target, t.widgetName + ".preventClickEvent")) return e.removeData(n.target, t.widgetName + ".preventClickEvent"), n.stopImmediatePropagation(), !1;
      }), this.started = !1;
    },
    _mouseDestroy: function _mouseDestroy() {
      this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && e(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
    },
    _mouseDown: function _mouseDown(t) {
      if (n) return;
      this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
      var r = this,
          i = t.which === 1,
          s = typeof this.options.cancel == "string" && t.target.nodeName ? e(t.target).closest(this.options.cancel).length : !1;
      if (!i || s || !this._mouseCapture(t)) return !0;
      this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
        r.mouseDelayMet = !0;
      }, this.options.delay));

      if (this._mouseDistanceMet(t) && this._mouseDelayMet(t)) {
        this._mouseStarted = this._mouseStart(t) !== !1;
        if (!this._mouseStarted) return t.preventDefault(), !0;
      }

      return !0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (e) {
        return r._mouseMove(e);
      }, this._mouseUpDelegate = function (e) {
        return r._mouseUp(e);
      }, e(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), n = !0, !0;
    },
    _mouseMove: function _mouseMove(t) {
      return !e.ui.ie || document.documentMode >= 9 || !!t.button ? this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, t) !== !1, this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted) : this._mouseUp(t);
    },
    _mouseUp: function _mouseUp(t) {
      return e(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), !1;
    },
    _mouseDistanceMet: function _mouseDistanceMet(e) {
      return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance;
    },
    _mouseDelayMet: function _mouseDelayMet(e) {
      return this.mouseDelayMet;
    },
    _mouseStart: function _mouseStart(e) {},
    _mouseDrag: function _mouseDrag(e) {},
    _mouseStop: function _mouseStop(e) {},
    _mouseCapture: function _mouseCapture(e) {
      return !0;
    }
  });
}(jQuery), function (e, t) {
  e.widget("ui.draggable", e.ui.mouse, {
    version: "1.9.2",
    widgetEventPrefix: "drag",
    options: {
      addClasses: !0,
      appendTo: "parent",
      axis: !1,
      connectToSortable: !1,
      containment: !1,
      cursor: "auto",
      cursorAt: !1,
      grid: !1,
      handle: !1,
      helper: "original",
      iframeFix: !1,
      opacity: !1,
      refreshPositions: !1,
      revert: !1,
      revertDuration: 500,
      scope: "default",
      scroll: !0,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: !1,
      snapMode: "both",
      snapTolerance: 20,
      stack: !1,
      zIndex: !1
    },
    _create: function _create() {
      this.options.helper == "original" && !/^(?:r|a|f)/.test(this.element.css("position")) && (this.element[0].style.position = "relative"), this.options.addClasses && this.element.addClass("ui-draggable"), this.options.disabled && this.element.addClass("ui-draggable-disabled"), this._mouseInit();
    },
    _destroy: function _destroy() {
      this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), this._mouseDestroy();
    },
    _mouseCapture: function _mouseCapture(t) {
      var n = this.options;
      return this.helper || n.disabled || e(t.target).is(".ui-resizable-handle") ? !1 : (this.handle = this._getHandle(t), this.handle ? (e(n.iframeFix === !0 ? "iframe" : n.iframeFix).each(function () {
        e('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({
          width: this.offsetWidth + "px",
          height: this.offsetHeight + "px",
          position: "absolute",
          opacity: "0.001",
          zIndex: 1e3
        }).css(e(this).offset()).appendTo("body");
      }), !0) : !1);
    },
    _mouseStart: function _mouseStart(t) {
      var n = this.options;
      return this.helper = this._createHelper(t), this.helper.addClass("ui-draggable-dragging"), this._cacheHelperProportions(), e.ui.ddmanager && (e.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(), this.offset = this.positionAbs = this.element.offset(), this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      }, e.extend(this.offset, {
        click: {
          left: t.pageX - this.offset.left,
          top: t.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      }), this.originalPosition = this.position = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, n.cursorAt && this._adjustOffsetFromHelper(n.cursorAt), n.containment && this._setContainment(), this._trigger("start", t) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), e.ui.ddmanager && !n.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this._mouseDrag(t, !0), e.ui.ddmanager && e.ui.ddmanager.dragStart(this, t), !0);
    },
    _mouseDrag: function _mouseDrag(t, n) {
      this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute");

      if (!n) {
        var r = this._uiHash();

        if (this._trigger("drag", t, r) === !1) return this._mouseUp({}), !1;
        this.position = r.position;
      }

      if (!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left + "px";
      if (!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top + "px";
      return e.ui.ddmanager && e.ui.ddmanager.drag(this, t), !1;
    },
    _mouseStop: function _mouseStop(t) {
      var n = !1;
      e.ui.ddmanager && !this.options.dropBehaviour && (n = e.ui.ddmanager.drop(this, t)), this.dropped && (n = this.dropped, this.dropped = !1);
      var r = this.element[0],
          i = !1;

      while (r && (r = r.parentNode)) {
        r == document && (i = !0);
      }

      if (!i && this.options.helper === "original") return !1;

      if (this.options.revert == "invalid" && !n || this.options.revert == "valid" && n || this.options.revert === !0 || e.isFunction(this.options.revert) && this.options.revert.call(this.element, n)) {
        var s = this;
        e(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
          s._trigger("stop", t) !== !1 && s._clear();
        });
      } else this._trigger("stop", t) !== !1 && this._clear();

      return !1;
    },
    _mouseUp: function _mouseUp(t) {
      return e("div.ui-draggable-iframeFix").each(function () {
        this.parentNode.removeChild(this);
      }), e.ui.ddmanager && e.ui.ddmanager.dragStop(this, t), e.ui.mouse.prototype._mouseUp.call(this, t);
    },
    cancel: function cancel() {
      return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), this;
    },
    _getHandle: function _getHandle(t) {
      var n = !this.options.handle || !e(this.options.handle, this.element).length ? !0 : !1;
      return e(this.options.handle, this.element).find("*").andSelf().each(function () {
        this == t.target && (n = !0);
      }), n;
    },
    _createHelper: function _createHelper(t) {
      var n = this.options,
          r = e.isFunction(n.helper) ? e(n.helper.apply(this.element[0], [t])) : n.helper == "clone" ? this.element.clone().removeAttr("id") : this.element;
      return r.parents("body").length || r.appendTo(n.appendTo == "parent" ? this.element[0].parentNode : n.appendTo), r[0] != this.element[0] && !/(fixed|absolute)/.test(r.css("position")) && r.css("position", "absolute"), r;
    },
    _adjustOffsetFromHelper: function _adjustOffsetFromHelper(t) {
      typeof t == "string" && (t = t.split(" ")), e.isArray(t) && (t = {
        left: +t[0],
        top: +t[1] || 0
      }), "left" in t && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top);
    },
    _getParentOffset: function _getParentOffset() {
      this.offsetParent = this.helper.offsetParent();
      var t = this.offsetParent.offset();
      this.cssPosition == "absolute" && this.scrollParent[0] != document && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop());
      if (this.offsetParent[0] == document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == "html" && e.ui.ie) t = {
        top: 0,
        left: 0
      };
      return {
        top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
      };
    },
    _getRelativeOffset: function _getRelativeOffset() {
      if (this.cssPosition == "relative") {
        var e = this.element.position();
        return {
          top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
          left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
        };
      }

      return {
        top: 0,
        left: 0
      };
    },
    _cacheMargins: function _cacheMargins() {
      this.margins = {
        left: parseInt(this.element.css("marginLeft"), 10) || 0,
        top: parseInt(this.element.css("marginTop"), 10) || 0,
        right: parseInt(this.element.css("marginRight"), 10) || 0,
        bottom: parseInt(this.element.css("marginBottom"), 10) || 0
      };
    },
    _cacheHelperProportions: function _cacheHelperProportions() {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function _setContainment() {
      var t = this.options;
      t.containment == "parent" && (t.containment = this.helper[0].parentNode);
      if (t.containment == "document" || t.containment == "window") this.containment = [t.containment == "document" ? 0 : e(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, t.containment == "document" ? 0 : e(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, (t.containment == "document" ? 0 : e(window).scrollLeft()) + e(t.containment == "document" ? document : window).width() - this.helperProportions.width - this.margins.left, (t.containment == "document" ? 0 : e(window).scrollTop()) + (e(t.containment == "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];

      if (!/^(document|window|parent)$/.test(t.containment) && t.containment.constructor != Array) {
        var n = e(t.containment),
            r = n[0];
        if (!r) return;
        var i = n.offset(),
            s = e(r).css("overflow") != "hidden";
        this.containment = [(parseInt(e(r).css("borderLeftWidth"), 10) || 0) + (parseInt(e(r).css("paddingLeft"), 10) || 0), (parseInt(e(r).css("borderTopWidth"), 10) || 0) + (parseInt(e(r).css("paddingTop"), 10) || 0), (s ? Math.max(r.scrollWidth, r.offsetWidth) : r.offsetWidth) - (parseInt(e(r).css("borderLeftWidth"), 10) || 0) - (parseInt(e(r).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (s ? Math.max(r.scrollHeight, r.offsetHeight) : r.offsetHeight) - (parseInt(e(r).css("borderTopWidth"), 10) || 0) - (parseInt(e(r).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relative_container = n;
      } else t.containment.constructor == Array && (this.containment = t.containment);
    },
    _convertPositionTo: function _convertPositionTo(t, n) {
      n || (n = this.position);
      var r = t == "absolute" ? 1 : -1,
          i = this.options,
          s = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          o = /(html|body)/i.test(s[0].tagName);
      return {
        top: n.top + this.offset.relative.top * r + this.offset.parent.top * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : o ? 0 : s.scrollTop()) * r,
        left: n.left + this.offset.relative.left * r + this.offset.parent.left * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : o ? 0 : s.scrollLeft()) * r
      };
    },
    _generatePosition: function _generatePosition(t) {
      var n = this.options,
          r = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          i = /(html|body)/i.test(r[0].tagName),
          s = t.pageX,
          o = t.pageY;

      if (this.originalPosition) {
        var u;

        if (this.containment) {
          if (this.relative_container) {
            var a = this.relative_container.offset();
            u = [this.containment[0] + a.left, this.containment[1] + a.top, this.containment[2] + a.left, this.containment[3] + a.top];
          } else u = this.containment;

          t.pageX - this.offset.click.left < u[0] && (s = u[0] + this.offset.click.left), t.pageY - this.offset.click.top < u[1] && (o = u[1] + this.offset.click.top), t.pageX - this.offset.click.left > u[2] && (s = u[2] + this.offset.click.left), t.pageY - this.offset.click.top > u[3] && (o = u[3] + this.offset.click.top);
        }

        if (n.grid) {
          var f = n.grid[1] ? this.originalPageY + Math.round((o - this.originalPageY) / n.grid[1]) * n.grid[1] : this.originalPageY;
          o = u ? f - this.offset.click.top < u[1] || f - this.offset.click.top > u[3] ? f - this.offset.click.top < u[1] ? f + n.grid[1] : f - n.grid[1] : f : f;
          var l = n.grid[0] ? this.originalPageX + Math.round((s - this.originalPageX) / n.grid[0]) * n.grid[0] : this.originalPageX;
          s = u ? l - this.offset.click.left < u[0] || l - this.offset.click.left > u[2] ? l - this.offset.click.left < u[0] ? l + n.grid[0] : l - n.grid[0] : l : l;
        }
      }

      return {
        top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : i ? 0 : r.scrollTop()),
        left: s - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : i ? 0 : r.scrollLeft())
      };
    },
    _clear: function _clear() {
      this.helper.removeClass("ui-draggable-dragging"), this.helper[0] != this.element[0] && !this.cancelHelperRemoval && this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1;
    },
    _trigger: function _trigger(t, n, r) {
      return r = r || this._uiHash(), e.ui.plugin.call(this, t, [n, r]), t == "drag" && (this.positionAbs = this._convertPositionTo("absolute")), e.Widget.prototype._trigger.call(this, t, n, r);
    },
    plugins: {},
    _uiHash: function _uiHash(e) {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs
      };
    }
  }), e.ui.plugin.add("draggable", "connectToSortable", {
    start: function start(t, n) {
      var r = e(this).data("draggable"),
          i = r.options,
          s = e.extend({}, n, {
        item: r.element
      });
      r.sortables = [], e(i.connectToSortable).each(function () {
        var n = e.data(this, "sortable");
        n && !n.options.disabled && (r.sortables.push({
          instance: n,
          shouldRevert: n.options.revert
        }), n.refreshPositions(), n._trigger("activate", t, s));
      });
    },
    stop: function stop(t, n) {
      var r = e(this).data("draggable"),
          i = e.extend({}, n, {
        item: r.element
      });
      e.each(r.sortables, function () {
        this.instance.isOver ? (this.instance.isOver = 0, r.cancelHelperRemoval = !0, this.instance.cancelHelperRemoval = !1, this.shouldRevert && (this.instance.options.revert = !0), this.instance._mouseStop(t), this.instance.options.helper = this.instance.options._helper, r.options.helper == "original" && this.instance.currentItem.css({
          top: "auto",
          left: "auto"
        })) : (this.instance.cancelHelperRemoval = !1, this.instance._trigger("deactivate", t, i));
      });
    },
    drag: function drag(t, n) {
      var r = e(this).data("draggable"),
          i = this,
          s = function s(t) {
        var n = this.offset.click.top,
            r = this.offset.click.left,
            i = this.positionAbs.top,
            s = this.positionAbs.left,
            o = t.height,
            u = t.width,
            a = t.top,
            f = t.left;
        return e.ui.isOver(i + n, s + r, a, f, o, u);
      };

      e.each(r.sortables, function (s) {
        var o = !1,
            u = this;
        this.instance.positionAbs = r.positionAbs, this.instance.helperProportions = r.helperProportions, this.instance.offset.click = r.offset.click, this.instance._intersectsWith(this.instance.containerCache) && (o = !0, e.each(r.sortables, function () {
          return this.instance.positionAbs = r.positionAbs, this.instance.helperProportions = r.helperProportions, this.instance.offset.click = r.offset.click, this != u && this.instance._intersectsWith(this.instance.containerCache) && e.ui.contains(u.instance.element[0], this.instance.element[0]) && (o = !1), o;
        })), o ? (this.instance.isOver || (this.instance.isOver = 1, this.instance.currentItem = e(i).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item", !0), this.instance.options._helper = this.instance.options.helper, this.instance.options.helper = function () {
          return n.helper[0];
        }, t.target = this.instance.currentItem[0], this.instance._mouseCapture(t, !0), this.instance._mouseStart(t, !0, !0), this.instance.offset.click.top = r.offset.click.top, this.instance.offset.click.left = r.offset.click.left, this.instance.offset.parent.left -= r.offset.parent.left - this.instance.offset.parent.left, this.instance.offset.parent.top -= r.offset.parent.top - this.instance.offset.parent.top, r._trigger("toSortable", t), r.dropped = this.instance.element, r.currentItem = r.element, this.instance.fromOutside = r), this.instance.currentItem && this.instance._mouseDrag(t)) : this.instance.isOver && (this.instance.isOver = 0, this.instance.cancelHelperRemoval = !0, this.instance.options.revert = !1, this.instance._trigger("out", t, this.instance._uiHash(this.instance)), this.instance._mouseStop(t, !0), this.instance.options.helper = this.instance.options._helper, this.instance.currentItem.remove(), this.instance.placeholder && this.instance.placeholder.remove(), r._trigger("fromSortable", t), r.dropped = !1);
      });
    }
  }), e.ui.plugin.add("draggable", "cursor", {
    start: function start(t, n) {
      var r = e("body"),
          i = e(this).data("draggable").options;
      r.css("cursor") && (i._cursor = r.css("cursor")), r.css("cursor", i.cursor);
    },
    stop: function stop(t, n) {
      var r = e(this).data("draggable").options;
      r._cursor && e("body").css("cursor", r._cursor);
    }
  }), e.ui.plugin.add("draggable", "opacity", {
    start: function start(t, n) {
      var r = e(n.helper),
          i = e(this).data("draggable").options;
      r.css("opacity") && (i._opacity = r.css("opacity")), r.css("opacity", i.opacity);
    },
    stop: function stop(t, n) {
      var r = e(this).data("draggable").options;
      r._opacity && e(n.helper).css("opacity", r._opacity);
    }
  }), e.ui.plugin.add("draggable", "scroll", {
    start: function start(t, n) {
      var r = e(this).data("draggable");
      r.scrollParent[0] != document && r.scrollParent[0].tagName != "HTML" && (r.overflowOffset = r.scrollParent.offset());
    },
    drag: function drag(t, n) {
      var r = e(this).data("draggable"),
          i = r.options,
          s = !1;

      if (r.scrollParent[0] != document && r.scrollParent[0].tagName != "HTML") {
        if (!i.axis || i.axis != "x") r.overflowOffset.top + r.scrollParent[0].offsetHeight - t.pageY < i.scrollSensitivity ? r.scrollParent[0].scrollTop = s = r.scrollParent[0].scrollTop + i.scrollSpeed : t.pageY - r.overflowOffset.top < i.scrollSensitivity && (r.scrollParent[0].scrollTop = s = r.scrollParent[0].scrollTop - i.scrollSpeed);
        if (!i.axis || i.axis != "y") r.overflowOffset.left + r.scrollParent[0].offsetWidth - t.pageX < i.scrollSensitivity ? r.scrollParent[0].scrollLeft = s = r.scrollParent[0].scrollLeft + i.scrollSpeed : t.pageX - r.overflowOffset.left < i.scrollSensitivity && (r.scrollParent[0].scrollLeft = s = r.scrollParent[0].scrollLeft - i.scrollSpeed);
      } else {
        if (!i.axis || i.axis != "x") t.pageY - e(document).scrollTop() < i.scrollSensitivity ? s = e(document).scrollTop(e(document).scrollTop() - i.scrollSpeed) : e(window).height() - (t.pageY - e(document).scrollTop()) < i.scrollSensitivity && (s = e(document).scrollTop(e(document).scrollTop() + i.scrollSpeed));
        if (!i.axis || i.axis != "y") t.pageX - e(document).scrollLeft() < i.scrollSensitivity ? s = e(document).scrollLeft(e(document).scrollLeft() - i.scrollSpeed) : e(window).width() - (t.pageX - e(document).scrollLeft()) < i.scrollSensitivity && (s = e(document).scrollLeft(e(document).scrollLeft() + i.scrollSpeed));
      }

      s !== !1 && e.ui.ddmanager && !i.dropBehaviour && e.ui.ddmanager.prepareOffsets(r, t);
    }
  }), e.ui.plugin.add("draggable", "snap", {
    start: function start(t, n) {
      var r = e(this).data("draggable"),
          i = r.options;
      r.snapElements = [], e(i.snap.constructor != String ? i.snap.items || ":data(draggable)" : i.snap).each(function () {
        var t = e(this),
            n = t.offset();
        this != r.element[0] && r.snapElements.push({
          item: this,
          width: t.outerWidth(),
          height: t.outerHeight(),
          top: n.top,
          left: n.left
        });
      });
    },
    drag: function drag(t, n) {
      var r = e(this).data("draggable"),
          i = r.options,
          s = i.snapTolerance,
          o = n.offset.left,
          u = o + r.helperProportions.width,
          a = n.offset.top,
          f = a + r.helperProportions.height;

      for (var l = r.snapElements.length - 1; l >= 0; l--) {
        var c = r.snapElements[l].left,
            h = c + r.snapElements[l].width,
            p = r.snapElements[l].top,
            d = p + r.snapElements[l].height;

        if (!(c - s < o && o < h + s && p - s < a && a < d + s || c - s < o && o < h + s && p - s < f && f < d + s || c - s < u && u < h + s && p - s < a && a < d + s || c - s < u && u < h + s && p - s < f && f < d + s)) {
          r.snapElements[l].snapping && r.options.snap.release && r.options.snap.release.call(r.element, t, e.extend(r._uiHash(), {
            snapItem: r.snapElements[l].item
          })), r.snapElements[l].snapping = !1;
          continue;
        }

        if (i.snapMode != "inner") {
          var v = Math.abs(p - f) <= s,
              m = Math.abs(d - a) <= s,
              g = Math.abs(c - u) <= s,
              y = Math.abs(h - o) <= s;
          v && (n.position.top = r._convertPositionTo("relative", {
            top: p - r.helperProportions.height,
            left: 0
          }).top - r.margins.top), m && (n.position.top = r._convertPositionTo("relative", {
            top: d,
            left: 0
          }).top - r.margins.top), g && (n.position.left = r._convertPositionTo("relative", {
            top: 0,
            left: c - r.helperProportions.width
          }).left - r.margins.left), y && (n.position.left = r._convertPositionTo("relative", {
            top: 0,
            left: h
          }).left - r.margins.left);
        }

        var b = v || m || g || y;

        if (i.snapMode != "outer") {
          var v = Math.abs(p - a) <= s,
              m = Math.abs(d - f) <= s,
              g = Math.abs(c - o) <= s,
              y = Math.abs(h - u) <= s;
          v && (n.position.top = r._convertPositionTo("relative", {
            top: p,
            left: 0
          }).top - r.margins.top), m && (n.position.top = r._convertPositionTo("relative", {
            top: d - r.helperProportions.height,
            left: 0
          }).top - r.margins.top), g && (n.position.left = r._convertPositionTo("relative", {
            top: 0,
            left: c
          }).left - r.margins.left), y && (n.position.left = r._convertPositionTo("relative", {
            top: 0,
            left: h - r.helperProportions.width
          }).left - r.margins.left);
        }

        !r.snapElements[l].snapping && (v || m || g || y || b) && r.options.snap.snap && r.options.snap.snap.call(r.element, t, e.extend(r._uiHash(), {
          snapItem: r.snapElements[l].item
        })), r.snapElements[l].snapping = v || m || g || y || b;
      }
    }
  }), e.ui.plugin.add("draggable", "stack", {
    start: function start(t, n) {
      var r = e(this).data("draggable").options,
          i = e.makeArray(e(r.stack)).sort(function (t, n) {
        return (parseInt(e(t).css("zIndex"), 10) || 0) - (parseInt(e(n).css("zIndex"), 10) || 0);
      });
      if (!i.length) return;
      var s = parseInt(i[0].style.zIndex) || 0;
      e(i).each(function (e) {
        this.style.zIndex = s + e;
      }), this[0].style.zIndex = s + i.length;
    }
  }), e.ui.plugin.add("draggable", "zIndex", {
    start: function start(t, n) {
      var r = e(n.helper),
          i = e(this).data("draggable").options;
      r.css("zIndex") && (i._zIndex = r.css("zIndex")), r.css("zIndex", i.zIndex);
    },
    stop: function stop(t, n) {
      var r = e(this).data("draggable").options;
      r._zIndex && e(n.helper).css("zIndex", r._zIndex);
    }
  });
}(jQuery), function (e, t) {
  e.widget("ui.droppable", {
    version: "1.9.2",
    widgetEventPrefix: "drop",
    options: {
      accept: "*",
      activeClass: !1,
      addClasses: !0,
      greedy: !1,
      hoverClass: !1,
      scope: "default",
      tolerance: "intersect"
    },
    _create: function _create() {
      var t = this.options,
          n = t.accept;
      this.isover = 0, this.isout = 1, this.accept = e.isFunction(n) ? n : function (e) {
        return e.is(n);
      }, this.proportions = {
        width: this.element[0].offsetWidth,
        height: this.element[0].offsetHeight
      }, e.ui.ddmanager.droppables[t.scope] = e.ui.ddmanager.droppables[t.scope] || [], e.ui.ddmanager.droppables[t.scope].push(this), t.addClasses && this.element.addClass("ui-droppable");
    },
    _destroy: function _destroy() {
      var t = e.ui.ddmanager.droppables[this.options.scope];

      for (var n = 0; n < t.length; n++) {
        t[n] == this && t.splice(n, 1);
      }

      this.element.removeClass("ui-droppable ui-droppable-disabled");
    },
    _setOption: function _setOption(t, n) {
      t == "accept" && (this.accept = e.isFunction(n) ? n : function (e) {
        return e.is(n);
      }), e.Widget.prototype._setOption.apply(this, arguments);
    },
    _activate: function _activate(t) {
      var n = e.ui.ddmanager.current;
      this.options.activeClass && this.element.addClass(this.options.activeClass), n && this._trigger("activate", t, this.ui(n));
    },
    _deactivate: function _deactivate(t) {
      var n = e.ui.ddmanager.current;
      this.options.activeClass && this.element.removeClass(this.options.activeClass), n && this._trigger("deactivate", t, this.ui(n));
    },
    _over: function _over(t) {
      var n = e.ui.ddmanager.current;
      if (!n || (n.currentItem || n.element)[0] == this.element[0]) return;
      this.accept.call(this.element[0], n.currentItem || n.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass), this._trigger("over", t, this.ui(n)));
    },
    _out: function _out(t) {
      var n = e.ui.ddmanager.current;
      if (!n || (n.currentItem || n.element)[0] == this.element[0]) return;
      this.accept.call(this.element[0], n.currentItem || n.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("out", t, this.ui(n)));
    },
    _drop: function _drop(t, n) {
      var r = n || e.ui.ddmanager.current;
      if (!r || (r.currentItem || r.element)[0] == this.element[0]) return !1;
      var i = !1;
      return this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function () {
        var t = e.data(this, "droppable");
        if (t.options.greedy && !t.options.disabled && t.options.scope == r.options.scope && t.accept.call(t.element[0], r.currentItem || r.element) && e.ui.intersect(r, e.extend(t, {
          offset: t.element.offset()
        }), t.options.tolerance)) return i = !0, !1;
      }), i ? !1 : this.accept.call(this.element[0], r.currentItem || r.element) ? (this.options.activeClass && this.element.removeClass(this.options.activeClass), this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("drop", t, this.ui(r)), this.element) : !1;
    },
    ui: function ui(e) {
      return {
        draggable: e.currentItem || e.element,
        helper: e.helper,
        position: e.position,
        offset: e.positionAbs
      };
    }
  }), e.ui.intersect = function (t, n, r) {
    if (!n.offset) return !1;
    var i = (t.positionAbs || t.position.absolute).left,
        s = i + t.helperProportions.width,
        o = (t.positionAbs || t.position.absolute).top,
        u = o + t.helperProportions.height,
        a = n.offset.left,
        f = a + n.proportions.width,
        l = n.offset.top,
        c = l + n.proportions.height;

    switch (r) {
      case "fit":
        return a <= i && s <= f && l <= o && u <= c;

      case "intersect":
        return a < i + t.helperProportions.width / 2 && s - t.helperProportions.width / 2 < f && l < o + t.helperProportions.height / 2 && u - t.helperProportions.height / 2 < c;

      case "pointer":
        var h = (t.positionAbs || t.position.absolute).left + (t.clickOffset || t.offset.click).left,
            p = (t.positionAbs || t.position.absolute).top + (t.clickOffset || t.offset.click).top,
            d = e.ui.isOver(p, h, l, a, n.proportions.height, n.proportions.width);
        return d;

      case "touch":
        return (o >= l && o <= c || u >= l && u <= c || o < l && u > c) && (i >= a && i <= f || s >= a && s <= f || i < a && s > f);

      default:
        return !1;
    }
  }, e.ui.ddmanager = {
    current: null,
    droppables: {
      "default": []
    },
    prepareOffsets: function prepareOffsets(t, n) {
      var r = e.ui.ddmanager.droppables[t.options.scope] || [],
          i = n ? n.type : null,
          s = (t.currentItem || t.element).find(":data(droppable)").andSelf();

      e: for (var o = 0; o < r.length; o++) {
        if (r[o].options.disabled || t && !r[o].accept.call(r[o].element[0], t.currentItem || t.element)) continue;

        for (var u = 0; u < s.length; u++) {
          if (s[u] == r[o].element[0]) {
            r[o].proportions.height = 0;
            continue e;
          }
        }

        r[o].visible = r[o].element.css("display") != "none";
        if (!r[o].visible) continue;
        i == "mousedown" && r[o]._activate.call(r[o], n), r[o].offset = r[o].element.offset(), r[o].proportions = {
          width: r[o].element[0].offsetWidth,
          height: r[o].element[0].offsetHeight
        };
      }
    },
    drop: function drop(t, n) {
      var r = !1;
      return e.each(e.ui.ddmanager.droppables[t.options.scope] || [], function () {
        if (!this.options) return;
        !this.options.disabled && this.visible && e.ui.intersect(t, this, this.options.tolerance) && (r = this._drop.call(this, n) || r), !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = 1, this.isover = 0, this._deactivate.call(this, n));
      }), r;
    },
    dragStart: function dragStart(t, n) {
      t.element.parentsUntil("body").bind("scroll.droppable", function () {
        t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, n);
      });
    },
    drag: function drag(t, n) {
      t.options.refreshPositions && e.ui.ddmanager.prepareOffsets(t, n), e.each(e.ui.ddmanager.droppables[t.options.scope] || [], function () {
        if (this.options.disabled || this.greedyChild || !this.visible) return;
        var r = e.ui.intersect(t, this, this.options.tolerance),
            i = !r && this.isover == 1 ? "isout" : r && this.isover == 0 ? "isover" : null;
        if (!i) return;
        var s;

        if (this.options.greedy) {
          var o = this.options.scope,
              u = this.element.parents(":data(droppable)").filter(function () {
            return e.data(this, "droppable").options.scope === o;
          });
          u.length && (s = e.data(u[0], "droppable"), s.greedyChild = i == "isover" ? 1 : 0);
        }

        s && i == "isover" && (s.isover = 0, s.isout = 1, s._out.call(s, n)), this[i] = 1, this[i == "isout" ? "isover" : "isout"] = 0, this[i == "isover" ? "_over" : "_out"].call(this, n), s && i == "isout" && (s.isout = 0, s.isover = 1, s._over.call(s, n));
      });
    },
    dragStop: function dragStop(t, n) {
      t.element.parentsUntil("body").unbind("scroll.droppable"), t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, n);
    }
  };
}(jQuery), function (e, t) {
  e.widget("ui.resizable", e.ui.mouse, {
    version: "1.9.2",
    widgetEventPrefix: "resize",
    options: {
      alsoResize: !1,
      animate: !1,
      animateDuration: "slow",
      animateEasing: "swing",
      aspectRatio: !1,
      autoHide: !1,
      containment: !1,
      ghost: !1,
      grid: !1,
      handles: "e,s,se",
      helper: !1,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      zIndex: 1e3
    },
    _create: function _create() {
      var t = this,
          n = this.options;
      this.element.addClass("ui-resizable"), e.extend(this, {
        _aspectRatio: !!n.aspectRatio,
        aspectRatio: n.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: n.helper || n.ghost || n.animate ? n.helper || "ui-resizable-helper" : null
      }), this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i) && (this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
        position: this.element.css("position"),
        width: this.element.outerWidth(),
        height: this.element.outerHeight(),
        top: this.element.css("top"),
        left: this.element.css("left")
      })), this.element = this.element.parent().data("resizable", this.element.data("resizable")), this.elementIsWrapper = !0, this.element.css({
        marginLeft: this.originalElement.css("marginLeft"),
        marginTop: this.originalElement.css("marginTop"),
        marginRight: this.originalElement.css("marginRight"),
        marginBottom: this.originalElement.css("marginBottom")
      }), this.originalElement.css({
        marginLeft: 0,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0
      }), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
        position: "static",
        zoom: 1,
        display: "block"
      })), this.originalElement.css({
        margin: this.originalElement.css("margin")
      }), this._proportionallyResize()), this.handles = n.handles || (e(".ui-resizable-handle", this.element).length ? {
        n: ".ui-resizable-n",
        e: ".ui-resizable-e",
        s: ".ui-resizable-s",
        w: ".ui-resizable-w",
        se: ".ui-resizable-se",
        sw: ".ui-resizable-sw",
        ne: ".ui-resizable-ne",
        nw: ".ui-resizable-nw"
      } : "e,s,se");

      if (this.handles.constructor == String) {
        this.handles == "all" && (this.handles = "n,e,s,w,se,sw,ne,nw");
        var r = this.handles.split(",");
        this.handles = {};

        for (var i = 0; i < r.length; i++) {
          var s = e.trim(r[i]),
              o = "ui-resizable-" + s,
              u = e('<div class="ui-resizable-handle ' + o + '"></div>');
          u.css({
            zIndex: n.zIndex
          }), "se" == s && u.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), this.handles[s] = ".ui-resizable-" + s, this.element.append(u);
        }
      }

      this._renderAxis = function (t) {
        t = t || this.element;

        for (var n in this.handles) {
          this.handles[n].constructor == String && (this.handles[n] = e(this.handles[n], this.element).show());

          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
            var r = e(this.handles[n], this.element),
                i = 0;
            i = /sw|ne|nw|se|n|s/.test(n) ? r.outerHeight() : r.outerWidth();
            var s = ["padding", /ne|nw|n/.test(n) ? "Top" : /se|sw|s/.test(n) ? "Bottom" : /^e$/.test(n) ? "Right" : "Left"].join("");
            t.css(s, i), this._proportionallyResize();
          }

          if (!e(this.handles[n]).length) continue;
        }
      }, this._renderAxis(this.element), this._handles = e(".ui-resizable-handle", this.element).disableSelection(), this._handles.mouseover(function () {
        if (!t.resizing) {
          if (this.className) var e = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
          t.axis = e && e[1] ? e[1] : "se";
        }
      }), n.autoHide && (this._handles.hide(), e(this.element).addClass("ui-resizable-autohide").mouseenter(function () {
        if (n.disabled) return;
        e(this).removeClass("ui-resizable-autohide"), t._handles.show();
      }).mouseleave(function () {
        if (n.disabled) return;
        t.resizing || (e(this).addClass("ui-resizable-autohide"), t._handles.hide());
      })), this._mouseInit();
    },
    _destroy: function _destroy() {
      this._mouseDestroy();

      var t = function t(_t) {
        e(_t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
      };

      if (this.elementIsWrapper) {
        t(this.element);
        var n = this.element;
        this.originalElement.css({
          position: n.css("position"),
          width: n.outerWidth(),
          height: n.outerHeight(),
          top: n.css("top"),
          left: n.css("left")
        }).insertAfter(n), n.remove();
      }

      return this.originalElement.css("resize", this.originalResizeStyle), t(this.originalElement), this;
    },
    _mouseCapture: function _mouseCapture(t) {
      var n = !1;

      for (var r in this.handles) {
        e(this.handles[r])[0] == t.target && (n = !0);
      }

      return !this.options.disabled && n;
    },
    _mouseStart: function _mouseStart(t) {
      var r = this.options,
          i = this.element.position(),
          s = this.element;
      this.resizing = !0, this.documentScroll = {
        top: e(document).scrollTop(),
        left: e(document).scrollLeft()
      }, (s.is(".ui-draggable") || /absolute/.test(s.css("position"))) && s.css({
        position: "absolute",
        top: i.top,
        left: i.left
      }), this._renderProxy();
      var o = n(this.helper.css("left")),
          u = n(this.helper.css("top"));
      r.containment && (o += e(r.containment).scrollLeft() || 0, u += e(r.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
        left: o,
        top: u
      }, this.size = this._helper ? {
        width: s.outerWidth(),
        height: s.outerHeight()
      } : {
        width: s.width(),
        height: s.height()
      }, this.originalSize = this._helper ? {
        width: s.outerWidth(),
        height: s.outerHeight()
      } : {
        width: s.width(),
        height: s.height()
      }, this.originalPosition = {
        left: o,
        top: u
      }, this.sizeDiff = {
        width: s.outerWidth() - s.width(),
        height: s.outerHeight() - s.height()
      }, this.originalMousePosition = {
        left: t.pageX,
        top: t.pageY
      }, this.aspectRatio = typeof r.aspectRatio == "number" ? r.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
      var a = e(".ui-resizable-" + this.axis).css("cursor");
      return e("body").css("cursor", a == "auto" ? this.axis + "-resize" : a), s.addClass("ui-resizable-resizing"), this._propagate("start", t), !0;
    },
    _mouseDrag: function _mouseDrag(e) {
      var t = this.helper,
          n = this.options,
          r = {},
          i = this,
          s = this.originalMousePosition,
          o = this.axis,
          u = e.pageX - s.left || 0,
          a = e.pageY - s.top || 0,
          f = this._change[o];
      if (!f) return !1;
      var l = f.apply(this, [e, u, a]);

      this._updateVirtualBoundaries(e.shiftKey);

      if (this._aspectRatio || e.shiftKey) l = this._updateRatio(l, e);
      return l = this._respectSize(l, e), this._propagate("resize", e), t.css({
        top: this.position.top + "px",
        left: this.position.left + "px",
        width: this.size.width + "px",
        height: this.size.height + "px"
      }), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), this._updateCache(l), this._trigger("resize", e, this.ui()), !1;
    },
    _mouseStop: function _mouseStop(t) {
      this.resizing = !1;
      var n = this.options,
          r = this;

      if (this._helper) {
        var i = this._proportionallyResizeElements,
            s = i.length && /textarea/i.test(i[0].nodeName),
            o = s && e.ui.hasScroll(i[0], "left") ? 0 : r.sizeDiff.height,
            u = s ? 0 : r.sizeDiff.width,
            a = {
          width: r.helper.width() - u,
          height: r.helper.height() - o
        },
            f = parseInt(r.element.css("left"), 10) + (r.position.left - r.originalPosition.left) || null,
            l = parseInt(r.element.css("top"), 10) + (r.position.top - r.originalPosition.top) || null;
        n.animate || this.element.css(e.extend(a, {
          top: l,
          left: f
        })), r.helper.height(r.size.height), r.helper.width(r.size.width), this._helper && !n.animate && this._proportionallyResize();
      }

      return e("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"), this._propagate("stop", t), this._helper && this.helper.remove(), !1;
    },
    _updateVirtualBoundaries: function _updateVirtualBoundaries(e) {
      var t = this.options,
          n,
          i,
          s,
          o,
          u;
      u = {
        minWidth: r(t.minWidth) ? t.minWidth : 0,
        maxWidth: r(t.maxWidth) ? t.maxWidth : Infinity,
        minHeight: r(t.minHeight) ? t.minHeight : 0,
        maxHeight: r(t.maxHeight) ? t.maxHeight : Infinity
      };
      if (this._aspectRatio || e) n = u.minHeight * this.aspectRatio, s = u.minWidth / this.aspectRatio, i = u.maxHeight * this.aspectRatio, o = u.maxWidth / this.aspectRatio, n > u.minWidth && (u.minWidth = n), s > u.minHeight && (u.minHeight = s), i < u.maxWidth && (u.maxWidth = i), o < u.maxHeight && (u.maxHeight = o);
      this._vBoundaries = u;
    },
    _updateCache: function _updateCache(e) {
      var t = this.options;
      this.offset = this.helper.offset(), r(e.left) && (this.position.left = e.left), r(e.top) && (this.position.top = e.top), r(e.height) && (this.size.height = e.height), r(e.width) && (this.size.width = e.width);
    },
    _updateRatio: function _updateRatio(e, t) {
      var n = this.options,
          i = this.position,
          s = this.size,
          o = this.axis;
      return r(e.height) ? e.width = e.height * this.aspectRatio : r(e.width) && (e.height = e.width / this.aspectRatio), o == "sw" && (e.left = i.left + (s.width - e.width), e.top = null), o == "nw" && (e.top = i.top + (s.height - e.height), e.left = i.left + (s.width - e.width)), e;
    },
    _respectSize: function _respectSize(e, t) {
      var n = this.helper,
          i = this._vBoundaries,
          s = this._aspectRatio || t.shiftKey,
          o = this.axis,
          u = r(e.width) && i.maxWidth && i.maxWidth < e.width,
          a = r(e.height) && i.maxHeight && i.maxHeight < e.height,
          f = r(e.width) && i.minWidth && i.minWidth > e.width,
          l = r(e.height) && i.minHeight && i.minHeight > e.height;
      f && (e.width = i.minWidth), l && (e.height = i.minHeight), u && (e.width = i.maxWidth), a && (e.height = i.maxHeight);
      var c = this.originalPosition.left + this.originalSize.width,
          h = this.position.top + this.size.height,
          p = /sw|nw|w/.test(o),
          d = /nw|ne|n/.test(o);
      f && p && (e.left = c - i.minWidth), u && p && (e.left = c - i.maxWidth), l && d && (e.top = h - i.minHeight), a && d && (e.top = h - i.maxHeight);
      var v = !e.width && !e.height;
      return v && !e.left && e.top ? e.top = null : v && !e.top && e.left && (e.left = null), e;
    },
    _proportionallyResize: function _proportionallyResize() {
      var t = this.options;
      if (!this._proportionallyResizeElements.length) return;
      var n = this.helper || this.element;

      for (var r = 0; r < this._proportionallyResizeElements.length; r++) {
        var i = this._proportionallyResizeElements[r];

        if (!this.borderDif) {
          var s = [i.css("borderTopWidth"), i.css("borderRightWidth"), i.css("borderBottomWidth"), i.css("borderLeftWidth")],
              o = [i.css("paddingTop"), i.css("paddingRight"), i.css("paddingBottom"), i.css("paddingLeft")];
          this.borderDif = e.map(s, function (e, t) {
            var n = parseInt(e, 10) || 0,
                r = parseInt(o[t], 10) || 0;
            return n + r;
          });
        }

        i.css({
          height: n.height() - this.borderDif[0] - this.borderDif[2] || 0,
          width: n.width() - this.borderDif[1] - this.borderDif[3] || 0
        });
      }
    },
    _renderProxy: function _renderProxy() {
      var t = this.element,
          n = this.options;
      this.elementOffset = t.offset();

      if (this._helper) {
        this.helper = this.helper || e('<div style="overflow:hidden;"></div>');
        var r = e.ui.ie6 ? 1 : 0,
            i = e.ui.ie6 ? 2 : -1;
        this.helper.addClass(this._helper).css({
          width: this.element.outerWidth() + i,
          height: this.element.outerHeight() + i,
          position: "absolute",
          left: this.elementOffset.left - r + "px",
          top: this.elementOffset.top - r + "px",
          zIndex: ++n.zIndex
        }), this.helper.appendTo("body").disableSelection();
      } else this.helper = this.element;
    },
    _change: {
      e: function e(_e, t, n) {
        return {
          width: this.originalSize.width + t
        };
      },
      w: function w(e, t, n) {
        var r = this.options,
            i = this.originalSize,
            s = this.originalPosition;
        return {
          left: s.left + t,
          width: i.width - t
        };
      },
      n: function n(e, t, _n) {
        var r = this.options,
            i = this.originalSize,
            s = this.originalPosition;
        return {
          top: s.top + _n,
          height: i.height - _n
        };
      },
      s: function s(e, t, n) {
        return {
          height: this.originalSize.height + n
        };
      },
      se: function se(t, n, r) {
        return e.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [t, n, r]));
      },
      sw: function sw(t, n, r) {
        return e.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [t, n, r]));
      },
      ne: function ne(t, n, r) {
        return e.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [t, n, r]));
      },
      nw: function nw(t, n, r) {
        return e.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [t, n, r]));
      }
    },
    _propagate: function _propagate(t, n) {
      e.ui.plugin.call(this, t, [n, this.ui()]), t != "resize" && this._trigger(t, n, this.ui());
    },
    plugins: {},
    ui: function ui() {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition
      };
    }
  }), e.ui.plugin.add("resizable", "alsoResize", {
    start: function start(t, n) {
      var r = e(this).data("resizable"),
          i = r.options,
          s = function s(t) {
        e(t).each(function () {
          var t = e(this);
          t.data("resizable-alsoresize", {
            width: parseInt(t.width(), 10),
            height: parseInt(t.height(), 10),
            left: parseInt(t.css("left"), 10),
            top: parseInt(t.css("top"), 10)
          });
        });
      };

      _typeof(i.alsoResize) == "object" && !i.alsoResize.parentNode ? i.alsoResize.length ? (i.alsoResize = i.alsoResize[0], s(i.alsoResize)) : e.each(i.alsoResize, function (e) {
        s(e);
      }) : s(i.alsoResize);
    },
    resize: function resize(t, n) {
      var r = e(this).data("resizable"),
          i = r.options,
          s = r.originalSize,
          o = r.originalPosition,
          u = {
        height: r.size.height - s.height || 0,
        width: r.size.width - s.width || 0,
        top: r.position.top - o.top || 0,
        left: r.position.left - o.left || 0
      },
          a = function a(t, r) {
        e(t).each(function () {
          var t = e(this),
              i = e(this).data("resizable-alsoresize"),
              s = {},
              o = r && r.length ? r : t.parents(n.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
          e.each(o, function (e, t) {
            var n = (i[t] || 0) + (u[t] || 0);
            n && n >= 0 && (s[t] = n || null);
          }), t.css(s);
        });
      };

      _typeof(i.alsoResize) == "object" && !i.alsoResize.nodeType ? e.each(i.alsoResize, function (e, t) {
        a(e, t);
      }) : a(i.alsoResize);
    },
    stop: function stop(t, n) {
      e(this).removeData("resizable-alsoresize");
    }
  }), e.ui.plugin.add("resizable", "animate", {
    stop: function stop(t, n) {
      var r = e(this).data("resizable"),
          i = r.options,
          s = r._proportionallyResizeElements,
          o = s.length && /textarea/i.test(s[0].nodeName),
          u = o && e.ui.hasScroll(s[0], "left") ? 0 : r.sizeDiff.height,
          a = o ? 0 : r.sizeDiff.width,
          f = {
        width: r.size.width - a,
        height: r.size.height - u
      },
          l = parseInt(r.element.css("left"), 10) + (r.position.left - r.originalPosition.left) || null,
          c = parseInt(r.element.css("top"), 10) + (r.position.top - r.originalPosition.top) || null;
      r.element.animate(e.extend(f, c && l ? {
        top: c,
        left: l
      } : {}), {
        duration: i.animateDuration,
        easing: i.animateEasing,
        step: function step() {
          var n = {
            width: parseInt(r.element.css("width"), 10),
            height: parseInt(r.element.css("height"), 10),
            top: parseInt(r.element.css("top"), 10),
            left: parseInt(r.element.css("left"), 10)
          };
          s && s.length && e(s[0]).css({
            width: n.width,
            height: n.height
          }), r._updateCache(n), r._propagate("resize", t);
        }
      });
    }
  }), e.ui.plugin.add("resizable", "containment", {
    start: function start(t, r) {
      var i = e(this).data("resizable"),
          s = i.options,
          o = i.element,
          u = s.containment,
          a = u instanceof e ? u.get(0) : /parent/.test(u) ? o.parent().get(0) : u;
      if (!a) return;
      i.containerElement = e(a);
      if (/document/.test(u) || u == document) i.containerOffset = {
        left: 0,
        top: 0
      }, i.containerPosition = {
        left: 0,
        top: 0
      }, i.parentData = {
        element: e(document),
        left: 0,
        top: 0,
        width: e(document).width(),
        height: e(document).height() || document.body.parentNode.scrollHeight
      };else {
        var f = e(a),
            l = [];
        e(["Top", "Right", "Left", "Bottom"]).each(function (e, t) {
          l[e] = n(f.css("padding" + t));
        }), i.containerOffset = f.offset(), i.containerPosition = f.position(), i.containerSize = {
          height: f.innerHeight() - l[3],
          width: f.innerWidth() - l[1]
        };
        var c = i.containerOffset,
            h = i.containerSize.height,
            p = i.containerSize.width,
            d = e.ui.hasScroll(a, "left") ? a.scrollWidth : p,
            v = e.ui.hasScroll(a) ? a.scrollHeight : h;
        i.parentData = {
          element: a,
          left: c.left,
          top: c.top,
          width: d,
          height: v
        };
      }
    },
    resize: function resize(t, n) {
      var r = e(this).data("resizable"),
          i = r.options,
          s = r.containerSize,
          o = r.containerOffset,
          u = r.size,
          a = r.position,
          f = r._aspectRatio || t.shiftKey,
          l = {
        top: 0,
        left: 0
      },
          c = r.containerElement;
      c[0] != document && /static/.test(c.css("position")) && (l = o), a.left < (r._helper ? o.left : 0) && (r.size.width = r.size.width + (r._helper ? r.position.left - o.left : r.position.left - l.left), f && (r.size.height = r.size.width / r.aspectRatio), r.position.left = i.helper ? o.left : 0), a.top < (r._helper ? o.top : 0) && (r.size.height = r.size.height + (r._helper ? r.position.top - o.top : r.position.top), f && (r.size.width = r.size.height * r.aspectRatio), r.position.top = r._helper ? o.top : 0), r.offset.left = r.parentData.left + r.position.left, r.offset.top = r.parentData.top + r.position.top;
      var h = Math.abs((r._helper ? r.offset.left - l.left : r.offset.left - l.left) + r.sizeDiff.width),
          p = Math.abs((r._helper ? r.offset.top - l.top : r.offset.top - o.top) + r.sizeDiff.height),
          d = r.containerElement.get(0) == r.element.parent().get(0),
          v = /relative|absolute/.test(r.containerElement.css("position"));
      d && v && (h -= r.parentData.left), h + r.size.width >= r.parentData.width && (r.size.width = r.parentData.width - h, f && (r.size.height = r.size.width / r.aspectRatio)), p + r.size.height >= r.parentData.height && (r.size.height = r.parentData.height - p, f && (r.size.width = r.size.height * r.aspectRatio));
    },
    stop: function stop(t, n) {
      var r = e(this).data("resizable"),
          i = r.options,
          s = r.position,
          o = r.containerOffset,
          u = r.containerPosition,
          a = r.containerElement,
          f = e(r.helper),
          l = f.offset(),
          c = f.outerWidth() - r.sizeDiff.width,
          h = f.outerHeight() - r.sizeDiff.height;
      r._helper && !i.animate && /relative/.test(a.css("position")) && e(this).css({
        left: l.left - u.left - o.left,
        width: c,
        height: h
      }), r._helper && !i.animate && /static/.test(a.css("position")) && e(this).css({
        left: l.left - u.left - o.left,
        width: c,
        height: h
      });
    }
  }), e.ui.plugin.add("resizable", "ghost", {
    start: function start(t, n) {
      var r = e(this).data("resizable"),
          i = r.options,
          s = r.size;
      r.ghost = r.originalElement.clone(), r.ghost.css({
        opacity: .25,
        display: "block",
        position: "relative",
        height: s.height,
        width: s.width,
        margin: 0,
        left: 0,
        top: 0
      }).addClass("ui-resizable-ghost").addClass(typeof i.ghost == "string" ? i.ghost : ""), r.ghost.appendTo(r.helper);
    },
    resize: function resize(t, n) {
      var r = e(this).data("resizable"),
          i = r.options;
      r.ghost && r.ghost.css({
        position: "relative",
        height: r.size.height,
        width: r.size.width
      });
    },
    stop: function stop(t, n) {
      var r = e(this).data("resizable"),
          i = r.options;
      r.ghost && r.helper && r.helper.get(0).removeChild(r.ghost.get(0));
    }
  }), e.ui.plugin.add("resizable", "grid", {
    resize: function resize(t, n) {
      var r = e(this).data("resizable"),
          i = r.options,
          s = r.size,
          o = r.originalSize,
          u = r.originalPosition,
          a = r.axis,
          f = i._aspectRatio || t.shiftKey;
      i.grid = typeof i.grid == "number" ? [i.grid, i.grid] : i.grid;
      var l = Math.round((s.width - o.width) / (i.grid[0] || 1)) * (i.grid[0] || 1),
          c = Math.round((s.height - o.height) / (i.grid[1] || 1)) * (i.grid[1] || 1);
      /^(se|s|e)$/.test(a) ? (r.size.width = o.width + l, r.size.height = o.height + c) : /^(ne)$/.test(a) ? (r.size.width = o.width + l, r.size.height = o.height + c, r.position.top = u.top - c) : /^(sw)$/.test(a) ? (r.size.width = o.width + l, r.size.height = o.height + c, r.position.left = u.left - l) : (r.size.width = o.width + l, r.size.height = o.height + c, r.position.top = u.top - c, r.position.left = u.left - l);
    }
  });

  var n = function n(e) {
    return parseInt(e, 10) || 0;
  },
      r = function r(e) {
    return !isNaN(parseInt(e, 10));
  };
}(jQuery), function (e, t) {
  e.widget("ui.selectable", e.ui.mouse, {
    version: "1.9.2",
    options: {
      appendTo: "body",
      autoRefresh: !0,
      distance: 0,
      filter: "*",
      tolerance: "touch"
    },
    _create: function _create() {
      var t = this;
      this.element.addClass("ui-selectable"), this.dragged = !1;
      var n;
      this.refresh = function () {
        n = e(t.options.filter, t.element[0]), n.addClass("ui-selectee"), n.each(function () {
          var t = e(this),
              n = t.offset();
          e.data(this, "selectable-item", {
            element: this,
            $element: t,
            left: n.left,
            top: n.top,
            right: n.left + t.outerWidth(),
            bottom: n.top + t.outerHeight(),
            startselected: !1,
            selected: t.hasClass("ui-selected"),
            selecting: t.hasClass("ui-selecting"),
            unselecting: t.hasClass("ui-unselecting")
          });
        });
      }, this.refresh(), this.selectees = n.addClass("ui-selectee"), this._mouseInit(), this.helper = e("<div class='ui-selectable-helper'></div>");
    },
    _destroy: function _destroy() {
      this.selectees.removeClass("ui-selectee").removeData("selectable-item"), this.element.removeClass("ui-selectable ui-selectable-disabled"), this._mouseDestroy();
    },
    _mouseStart: function _mouseStart(t) {
      var n = this;
      this.opos = [t.pageX, t.pageY];
      if (this.options.disabled) return;
      var r = this.options;
      this.selectees = e(r.filter, this.element[0]), this._trigger("start", t), e(r.appendTo).append(this.helper), this.helper.css({
        left: t.clientX,
        top: t.clientY,
        width: 0,
        height: 0
      }), r.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function () {
        var r = e.data(this, "selectable-item");
        r.startselected = !0, !t.metaKey && !t.ctrlKey && (r.$element.removeClass("ui-selected"), r.selected = !1, r.$element.addClass("ui-unselecting"), r.unselecting = !0, n._trigger("unselecting", t, {
          unselecting: r.element
        }));
      }), e(t.target).parents().andSelf().each(function () {
        var r = e.data(this, "selectable-item");

        if (r) {
          var i = !t.metaKey && !t.ctrlKey || !r.$element.hasClass("ui-selected");
          return r.$element.removeClass(i ? "ui-unselecting" : "ui-selected").addClass(i ? "ui-selecting" : "ui-unselecting"), r.unselecting = !i, r.selecting = i, r.selected = i, i ? n._trigger("selecting", t, {
            selecting: r.element
          }) : n._trigger("unselecting", t, {
            unselecting: r.element
          }), !1;
        }
      });
    },
    _mouseDrag: function _mouseDrag(t) {
      var n = this;
      this.dragged = !0;
      if (this.options.disabled) return;
      var r = this.options,
          i = this.opos[0],
          s = this.opos[1],
          o = t.pageX,
          u = t.pageY;

      if (i > o) {
        var a = o;
        o = i, i = a;
      }

      if (s > u) {
        var a = u;
        u = s, s = a;
      }

      return this.helper.css({
        left: i,
        top: s,
        width: o - i,
        height: u - s
      }), this.selectees.each(function () {
        var a = e.data(this, "selectable-item");
        if (!a || a.element == n.element[0]) return;
        var f = !1;
        r.tolerance == "touch" ? f = !(a.left > o || a.right < i || a.top > u || a.bottom < s) : r.tolerance == "fit" && (f = a.left > i && a.right < o && a.top > s && a.bottom < u), f ? (a.selected && (a.$element.removeClass("ui-selected"), a.selected = !1), a.unselecting && (a.$element.removeClass("ui-unselecting"), a.unselecting = !1), a.selecting || (a.$element.addClass("ui-selecting"), a.selecting = !0, n._trigger("selecting", t, {
          selecting: a.element
        }))) : (a.selecting && ((t.metaKey || t.ctrlKey) && a.startselected ? (a.$element.removeClass("ui-selecting"), a.selecting = !1, a.$element.addClass("ui-selected"), a.selected = !0) : (a.$element.removeClass("ui-selecting"), a.selecting = !1, a.startselected && (a.$element.addClass("ui-unselecting"), a.unselecting = !0), n._trigger("unselecting", t, {
          unselecting: a.element
        }))), a.selected && !t.metaKey && !t.ctrlKey && !a.startselected && (a.$element.removeClass("ui-selected"), a.selected = !1, a.$element.addClass("ui-unselecting"), a.unselecting = !0, n._trigger("unselecting", t, {
          unselecting: a.element
        })));
      }), !1;
    },
    _mouseStop: function _mouseStop(t) {
      var n = this;
      this.dragged = !1;
      var r = this.options;
      return e(".ui-unselecting", this.element[0]).each(function () {
        var r = e.data(this, "selectable-item");
        r.$element.removeClass("ui-unselecting"), r.unselecting = !1, r.startselected = !1, n._trigger("unselected", t, {
          unselected: r.element
        });
      }), e(".ui-selecting", this.element[0]).each(function () {
        var r = e.data(this, "selectable-item");
        r.$element.removeClass("ui-selecting").addClass("ui-selected"), r.selecting = !1, r.selected = !0, r.startselected = !0, n._trigger("selected", t, {
          selected: r.element
        });
      }), this._trigger("stop", t), this.helper.remove(), !1;
    }
  });
}(jQuery), function (e, t) {
  e.widget("ui.sortable", e.ui.mouse, {
    version: "1.9.2",
    widgetEventPrefix: "sort",
    ready: !1,
    options: {
      appendTo: "parent",
      axis: !1,
      connectWith: !1,
      containment: !1,
      cursor: "auto",
      cursorAt: !1,
      dropOnEmpty: !0,
      forcePlaceholderSize: !1,
      forceHelperSize: !1,
      grid: !1,
      handle: !1,
      helper: "original",
      items: "> *",
      opacity: !1,
      placeholder: !1,
      revert: !1,
      scroll: !0,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: "default",
      tolerance: "intersect",
      zIndex: 1e3
    },
    _create: function _create() {
      var e = this.options;
      this.containerCache = {}, this.element.addClass("ui-sortable"), this.refresh(), this.floating = this.items.length ? e.axis === "x" || /left|right/.test(this.items[0].item.css("float")) || /inline|table-cell/.test(this.items[0].item.css("display")) : !1, this.offset = this.element.offset(), this._mouseInit(), this.ready = !0;
    },
    _destroy: function _destroy() {
      this.element.removeClass("ui-sortable ui-sortable-disabled"), this._mouseDestroy();

      for (var e = this.items.length - 1; e >= 0; e--) {
        this.items[e].item.removeData(this.widgetName + "-item");
      }

      return this;
    },
    _setOption: function _setOption(t, n) {
      t === "disabled" ? (this.options[t] = n, this.widget().toggleClass("ui-sortable-disabled", !!n)) : e.Widget.prototype._setOption.apply(this, arguments);
    },
    _mouseCapture: function _mouseCapture(t, n) {
      var r = this;
      if (this.reverting) return !1;
      if (this.options.disabled || this.options.type == "static") return !1;

      this._refreshItems(t);

      var i = null,
          s = e(t.target).parents().each(function () {
        if (e.data(this, r.widgetName + "-item") == r) return i = e(this), !1;
      });
      e.data(t.target, r.widgetName + "-item") == r && (i = e(t.target));
      if (!i) return !1;

      if (this.options.handle && !n) {
        var o = !1;
        e(this.options.handle, i).find("*").andSelf().each(function () {
          this == t.target && (o = !0);
        });
        if (!o) return !1;
      }

      return this.currentItem = i, this._removeCurrentsFromItems(), !0;
    },
    _mouseStart: function _mouseStart(t, n, r) {
      var i = this.options;
      this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(t), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      }, e.extend(this.offset, {
        click: {
          left: t.pageX - this.offset.left,
          top: t.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, i.cursorAt && this._adjustOffsetFromHelper(i.cursorAt), this.domPosition = {
        prev: this.currentItem.prev()[0],
        parent: this.currentItem.parent()[0]
      }, this.helper[0] != this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), i.containment && this._setContainment(), i.cursor && (e("body").css("cursor") && (this._storedCursor = e("body").css("cursor")), e("body").css("cursor", i.cursor)), i.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", i.opacity)), i.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", i.zIndex)), this.scrollParent[0] != document && this.scrollParent[0].tagName != "HTML" && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions();
      if (!r) for (var s = this.containers.length - 1; s >= 0; s--) {
        this.containers[s]._trigger("activate", t, this._uiHash(this));
      }
      return e.ui.ddmanager && (e.ui.ddmanager.current = this), e.ui.ddmanager && !i.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(t), !0;
    },
    _mouseDrag: function _mouseDrag(t) {
      this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs);

      if (this.options.scroll) {
        var n = this.options,
            r = !1;
        this.scrollParent[0] != document && this.scrollParent[0].tagName != "HTML" ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < n.scrollSensitivity ? this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop + n.scrollSpeed : t.pageY - this.overflowOffset.top < n.scrollSensitivity && (this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop - n.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < n.scrollSensitivity ? this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft + n.scrollSpeed : t.pageX - this.overflowOffset.left < n.scrollSensitivity && (this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft - n.scrollSpeed)) : (t.pageY - e(document).scrollTop() < n.scrollSensitivity ? r = e(document).scrollTop(e(document).scrollTop() - n.scrollSpeed) : e(window).height() - (t.pageY - e(document).scrollTop()) < n.scrollSensitivity && (r = e(document).scrollTop(e(document).scrollTop() + n.scrollSpeed)), t.pageX - e(document).scrollLeft() < n.scrollSensitivity ? r = e(document).scrollLeft(e(document).scrollLeft() - n.scrollSpeed) : e(window).width() - (t.pageX - e(document).scrollLeft()) < n.scrollSensitivity && (r = e(document).scrollLeft(e(document).scrollLeft() + n.scrollSpeed))), r !== !1 && e.ui.ddmanager && !n.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t);
      }

      this.positionAbs = this._convertPositionTo("absolute");
      if (!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left + "px";
      if (!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top + "px";

      for (var i = this.items.length - 1; i >= 0; i--) {
        var s = this.items[i],
            o = s.item[0],
            u = this._intersectsWithPointer(s);

        if (!u) continue;
        if (s.instance !== this.currentContainer) continue;

        if (o != this.currentItem[0] && this.placeholder[u == 1 ? "next" : "prev"]()[0] != o && !e.contains(this.placeholder[0], o) && (this.options.type == "semi-dynamic" ? !e.contains(this.element[0], o) : !0)) {
          this.direction = u == 1 ? "down" : "up";
          if (this.options.tolerance != "pointer" && !this._intersectsWithSides(s)) break;
          this._rearrange(t, s), this._trigger("change", t, this._uiHash());
          break;
        }
      }

      return this._contactContainers(t), e.ui.ddmanager && e.ui.ddmanager.drag(this, t), this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1;
    },
    _mouseStop: function _mouseStop(t, n) {
      if (!t) return;
      e.ui.ddmanager && !this.options.dropBehaviour && e.ui.ddmanager.drop(this, t);

      if (this.options.revert) {
        var r = this,
            i = this.placeholder.offset();
        this.reverting = !0, e(this.helper).animate({
          left: i.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
          top: i.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
        }, parseInt(this.options.revert, 10) || 500, function () {
          r._clear(t);
        });
      } else this._clear(t, n);

      return !1;
    },
    cancel: function cancel() {
      if (this.dragging) {
        this._mouseUp({
          target: null
        }), this.options.helper == "original" ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();

        for (var t = this.containers.length - 1; t >= 0; t--) {
          this.containers[t]._trigger("deactivate", null, this._uiHash(this)), this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)), this.containers[t].containerCache.over = 0);
        }
      }

      return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.options.helper != "original" && this.helper && this.helper[0].parentNode && this.helper.remove(), e.extend(this, {
        helper: null,
        dragging: !1,
        reverting: !1,
        _noFinalSort: null
      }), this.domPosition.prev ? e(this.domPosition.prev).after(this.currentItem) : e(this.domPosition.parent).prepend(this.currentItem)), this;
    },
    serialize: function serialize(t) {
      var n = this._getItemsAsjQuery(t && t.connected),
          r = [];

      return t = t || {}, e(n).each(function () {
        var n = (e(t.item || this).attr(t.attribute || "id") || "").match(t.expression || /(.+)[-=_](.+)/);
        n && r.push((t.key || n[1] + "[]") + "=" + (t.key && t.expression ? n[1] : n[2]));
      }), !r.length && t.key && r.push(t.key + "="), r.join("&");
    },
    toArray: function toArray(t) {
      var n = this._getItemsAsjQuery(t && t.connected),
          r = [];

      return t = t || {}, n.each(function () {
        r.push(e(t.item || this).attr(t.attribute || "id") || "");
      }), r;
    },
    _intersectsWith: function _intersectsWith(e) {
      var t = this.positionAbs.left,
          n = t + this.helperProportions.width,
          r = this.positionAbs.top,
          i = r + this.helperProportions.height,
          s = e.left,
          o = s + e.width,
          u = e.top,
          a = u + e.height,
          f = this.offset.click.top,
          l = this.offset.click.left,
          c = r + f > u && r + f < a && t + l > s && t + l < o;
      return this.options.tolerance == "pointer" || this.options.forcePointerForContainers || this.options.tolerance != "pointer" && this.helperProportions[this.floating ? "width" : "height"] > e[this.floating ? "width" : "height"] ? c : s < t + this.helperProportions.width / 2 && n - this.helperProportions.width / 2 < o && u < r + this.helperProportions.height / 2 && i - this.helperProportions.height / 2 < a;
    },
    _intersectsWithPointer: function _intersectsWithPointer(t) {
      var n = this.options.axis === "x" || e.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, t.top, t.height),
          r = this.options.axis === "y" || e.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, t.left, t.width),
          i = n && r,
          s = this._getDragVerticalDirection(),
          o = this._getDragHorizontalDirection();

      return i ? this.floating ? o && o == "right" || s == "down" ? 2 : 1 : s && (s == "down" ? 2 : 1) : !1;
    },
    _intersectsWithSides: function _intersectsWithSides(t) {
      var n = e.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, t.top + t.height / 2, t.height),
          r = e.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, t.left + t.width / 2, t.width),
          i = this._getDragVerticalDirection(),
          s = this._getDragHorizontalDirection();

      return this.floating && s ? s == "right" && r || s == "left" && !r : i && (i == "down" && n || i == "up" && !n);
    },
    _getDragVerticalDirection: function _getDragVerticalDirection() {
      var e = this.positionAbs.top - this.lastPositionAbs.top;
      return e != 0 && (e > 0 ? "down" : "up");
    },
    _getDragHorizontalDirection: function _getDragHorizontalDirection() {
      var e = this.positionAbs.left - this.lastPositionAbs.left;
      return e != 0 && (e > 0 ? "right" : "left");
    },
    refresh: function refresh(e) {
      return this._refreshItems(e), this.refreshPositions(), this;
    },
    _connectWith: function _connectWith() {
      var e = this.options;
      return e.connectWith.constructor == String ? [e.connectWith] : e.connectWith;
    },
    _getItemsAsjQuery: function _getItemsAsjQuery(t) {
      var n = [],
          r = [],
          i = this._connectWith();

      if (i && t) for (var s = i.length - 1; s >= 0; s--) {
        var o = e(i[s]);

        for (var u = o.length - 1; u >= 0; u--) {
          var a = e.data(o[u], this.widgetName);
          a && a != this && !a.options.disabled && r.push([e.isFunction(a.options.items) ? a.options.items.call(a.element) : e(a.options.items, a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), a]);
        }
      }
      r.push([e.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
        options: this.options,
        item: this.currentItem
      }) : e(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

      for (var s = r.length - 1; s >= 0; s--) {
        r[s][0].each(function () {
          n.push(this);
        });
      }

      return e(n);
    },
    _removeCurrentsFromItems: function _removeCurrentsFromItems() {
      var t = this.currentItem.find(":data(" + this.widgetName + "-item)");
      this.items = e.grep(this.items, function (e) {
        for (var n = 0; n < t.length; n++) {
          if (t[n] == e.item[0]) return !1;
        }

        return !0;
      });
    },
    _refreshItems: function _refreshItems(t) {
      this.items = [], this.containers = [this];

      var n = this.items,
          r = [[e.isFunction(this.options.items) ? this.options.items.call(this.element[0], t, {
        item: this.currentItem
      }) : e(this.options.items, this.element), this]],
          i = this._connectWith();

      if (i && this.ready) for (var s = i.length - 1; s >= 0; s--) {
        var o = e(i[s]);

        for (var u = o.length - 1; u >= 0; u--) {
          var a = e.data(o[u], this.widgetName);
          a && a != this && !a.options.disabled && (r.push([e.isFunction(a.options.items) ? a.options.items.call(a.element[0], t, {
            item: this.currentItem
          }) : e(a.options.items, a.element), a]), this.containers.push(a));
        }
      }

      for (var s = r.length - 1; s >= 0; s--) {
        var f = r[s][1],
            l = r[s][0];

        for (var u = 0, c = l.length; u < c; u++) {
          var h = e(l[u]);
          h.data(this.widgetName + "-item", f), n.push({
            item: h,
            instance: f,
            width: 0,
            height: 0,
            left: 0,
            top: 0
          });
        }
      }
    },
    refreshPositions: function refreshPositions(t) {
      this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());

      for (var n = this.items.length - 1; n >= 0; n--) {
        var r = this.items[n];
        if (r.instance != this.currentContainer && this.currentContainer && r.item[0] != this.currentItem[0]) continue;
        var i = this.options.toleranceElement ? e(this.options.toleranceElement, r.item) : r.item;
        t || (r.width = i.outerWidth(), r.height = i.outerHeight());
        var s = i.offset();
        r.left = s.left, r.top = s.top;
      }

      if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);else for (var n = this.containers.length - 1; n >= 0; n--) {
        var s = this.containers[n].element.offset();
        this.containers[n].containerCache.left = s.left, this.containers[n].containerCache.top = s.top, this.containers[n].containerCache.width = this.containers[n].element.outerWidth(), this.containers[n].containerCache.height = this.containers[n].element.outerHeight();
      }
      return this;
    },
    _createPlaceholder: function _createPlaceholder(t) {
      t = t || this;
      var n = t.options;

      if (!n.placeholder || n.placeholder.constructor == String) {
        var r = n.placeholder;
        n.placeholder = {
          element: function element() {
            var n = e(document.createElement(t.currentItem[0].nodeName)).addClass(r || t.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];
            return r || (n.style.visibility = "hidden"), n;
          },
          update: function update(e, i) {
            if (r && !n.forcePlaceholderSize) return;
            i.height() || i.height(t.currentItem.innerHeight() - parseInt(t.currentItem.css("paddingTop") || 0, 10) - parseInt(t.currentItem.css("paddingBottom") || 0, 10)), i.width() || i.width(t.currentItem.innerWidth() - parseInt(t.currentItem.css("paddingLeft") || 0, 10) - parseInt(t.currentItem.css("paddingRight") || 0, 10));
          }
        };
      }

      t.placeholder = e(n.placeholder.element.call(t.element, t.currentItem)), t.currentItem.after(t.placeholder), n.placeholder.update(t, t.placeholder);
    },
    _contactContainers: function _contactContainers(t) {
      var n = null,
          r = null;

      for (var i = this.containers.length - 1; i >= 0; i--) {
        if (e.contains(this.currentItem[0], this.containers[i].element[0])) continue;

        if (this._intersectsWith(this.containers[i].containerCache)) {
          if (n && e.contains(this.containers[i].element[0], n.element[0])) continue;
          n = this.containers[i], r = i;
        } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", t, this._uiHash(this)), this.containers[i].containerCache.over = 0);
      }

      if (!n) return;
      if (this.containers.length === 1) this.containers[r]._trigger("over", t, this._uiHash(this)), this.containers[r].containerCache.over = 1;else {
        var s = 1e4,
            o = null,
            u = this.containers[r].floating ? "left" : "top",
            a = this.containers[r].floating ? "width" : "height",
            f = this.positionAbs[u] + this.offset.click[u];

        for (var l = this.items.length - 1; l >= 0; l--) {
          if (!e.contains(this.containers[r].element[0], this.items[l].item[0])) continue;
          if (this.items[l].item[0] == this.currentItem[0]) continue;
          var c = this.items[l].item.offset()[u],
              h = !1;
          Math.abs(c - f) > Math.abs(c + this.items[l][a] - f) && (h = !0, c += this.items[l][a]), Math.abs(c - f) < s && (s = Math.abs(c - f), o = this.items[l], this.direction = h ? "up" : "down");
        }

        if (!o && !this.options.dropOnEmpty) return;
        this.currentContainer = this.containers[r], o ? this._rearrange(t, o, null, !0) : this._rearrange(t, null, this.containers[r].element, !0), this._trigger("change", t, this._uiHash()), this.containers[r]._trigger("change", t, this._uiHash(this)), this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[r]._trigger("over", t, this._uiHash(this)), this.containers[r].containerCache.over = 1;
      }
    },
    _createHelper: function _createHelper(t) {
      var n = this.options,
          r = e.isFunction(n.helper) ? e(n.helper.apply(this.element[0], [t, this.currentItem])) : n.helper == "clone" ? this.currentItem.clone() : this.currentItem;
      return r.parents("body").length || e(n.appendTo != "parent" ? n.appendTo : this.currentItem[0].parentNode)[0].appendChild(r[0]), r[0] == this.currentItem[0] && (this._storedCSS = {
        width: this.currentItem[0].style.width,
        height: this.currentItem[0].style.height,
        position: this.currentItem.css("position"),
        top: this.currentItem.css("top"),
        left: this.currentItem.css("left")
      }), (r[0].style.width == "" || n.forceHelperSize) && r.width(this.currentItem.width()), (r[0].style.height == "" || n.forceHelperSize) && r.height(this.currentItem.height()), r;
    },
    _adjustOffsetFromHelper: function _adjustOffsetFromHelper(t) {
      typeof t == "string" && (t = t.split(" ")), e.isArray(t) && (t = {
        left: +t[0],
        top: +t[1] || 0
      }), "left" in t && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top);
    },
    _getParentOffset: function _getParentOffset() {
      this.offsetParent = this.helper.offsetParent();
      var t = this.offsetParent.offset();
      this.cssPosition == "absolute" && this.scrollParent[0] != document && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop());
      if (this.offsetParent[0] == document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == "html" && e.ui.ie) t = {
        top: 0,
        left: 0
      };
      return {
        top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
      };
    },
    _getRelativeOffset: function _getRelativeOffset() {
      if (this.cssPosition == "relative") {
        var e = this.currentItem.position();
        return {
          top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
          left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
        };
      }

      return {
        top: 0,
        left: 0
      };
    },
    _cacheMargins: function _cacheMargins() {
      this.margins = {
        left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
        top: parseInt(this.currentItem.css("marginTop"), 10) || 0
      };
    },
    _cacheHelperProportions: function _cacheHelperProportions() {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function _setContainment() {
      var t = this.options;
      t.containment == "parent" && (t.containment = this.helper[0].parentNode);
      if (t.containment == "document" || t.containment == "window") this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, e(t.containment == "document" ? document : window).width() - this.helperProportions.width - this.margins.left, (e(t.containment == "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];

      if (!/^(document|window|parent)$/.test(t.containment)) {
        var n = e(t.containment)[0],
            r = e(t.containment).offset(),
            i = e(n).css("overflow") != "hidden";
        this.containment = [r.left + (parseInt(e(n).css("borderLeftWidth"), 10) || 0) + (parseInt(e(n).css("paddingLeft"), 10) || 0) - this.margins.left, r.top + (parseInt(e(n).css("borderTopWidth"), 10) || 0) + (parseInt(e(n).css("paddingTop"), 10) || 0) - this.margins.top, r.left + (i ? Math.max(n.scrollWidth, n.offsetWidth) : n.offsetWidth) - (parseInt(e(n).css("borderLeftWidth"), 10) || 0) - (parseInt(e(n).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, r.top + (i ? Math.max(n.scrollHeight, n.offsetHeight) : n.offsetHeight) - (parseInt(e(n).css("borderTopWidth"), 10) || 0) - (parseInt(e(n).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top];
      }
    },
    _convertPositionTo: function _convertPositionTo(t, n) {
      n || (n = this.position);
      var r = t == "absolute" ? 1 : -1,
          i = this.options,
          s = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          o = /(html|body)/i.test(s[0].tagName);
      return {
        top: n.top + this.offset.relative.top * r + this.offset.parent.top * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : o ? 0 : s.scrollTop()) * r,
        left: n.left + this.offset.relative.left * r + this.offset.parent.left * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : o ? 0 : s.scrollLeft()) * r
      };
    },
    _generatePosition: function _generatePosition(t) {
      var n = this.options,
          r = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          i = /(html|body)/i.test(r[0].tagName);
      this.cssPosition == "relative" && (this.scrollParent[0] == document || this.scrollParent[0] == this.offsetParent[0]) && (this.offset.relative = this._getRelativeOffset());
      var s = t.pageX,
          o = t.pageY;

      if (this.originalPosition) {
        this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (s = this.containment[0] + this.offset.click.left), t.pageY - this.offset.click.top < this.containment[1] && (o = this.containment[1] + this.offset.click.top), t.pageX - this.offset.click.left > this.containment[2] && (s = this.containment[2] + this.offset.click.left), t.pageY - this.offset.click.top > this.containment[3] && (o = this.containment[3] + this.offset.click.top));

        if (n.grid) {
          var u = this.originalPageY + Math.round((o - this.originalPageY) / n.grid[1]) * n.grid[1];
          o = this.containment ? u - this.offset.click.top < this.containment[1] || u - this.offset.click.top > this.containment[3] ? u - this.offset.click.top < this.containment[1] ? u + n.grid[1] : u - n.grid[1] : u : u;
          var a = this.originalPageX + Math.round((s - this.originalPageX) / n.grid[0]) * n.grid[0];
          s = this.containment ? a - this.offset.click.left < this.containment[0] || a - this.offset.click.left > this.containment[2] ? a - this.offset.click.left < this.containment[0] ? a + n.grid[0] : a - n.grid[0] : a : a;
        }
      }

      return {
        top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : i ? 0 : r.scrollTop()),
        left: s - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : i ? 0 : r.scrollLeft())
      };
    },
    _rearrange: function _rearrange(e, t, n, r) {
      n ? n[0].appendChild(this.placeholder[0]) : t.item[0].parentNode.insertBefore(this.placeholder[0], this.direction == "down" ? t.item[0] : t.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
      var i = this.counter;

      this._delay(function () {
        i == this.counter && this.refreshPositions(!r);
      });
    },
    _clear: function _clear(t, n) {
      this.reverting = !1;
      var r = [];
      !this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null;

      if (this.helper[0] == this.currentItem[0]) {
        for (var i in this._storedCSS) {
          if (this._storedCSS[i] == "auto" || this._storedCSS[i] == "static") this._storedCSS[i] = "";
        }

        this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
      } else this.currentItem.show();

      this.fromOutside && !n && r.push(function (e) {
        this._trigger("receive", e, this._uiHash(this.fromOutside));
      }), (this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !n && r.push(function (e) {
        this._trigger("update", e, this._uiHash());
      }), this !== this.currentContainer && (n || (r.push(function (e) {
        this._trigger("remove", e, this._uiHash());
      }), r.push(function (e) {
        return function (t) {
          e._trigger("receive", t, this._uiHash(this));
        };
      }.call(this, this.currentContainer)), r.push(function (e) {
        return function (t) {
          e._trigger("update", t, this._uiHash(this));
        };
      }.call(this, this.currentContainer))));

      for (var i = this.containers.length - 1; i >= 0; i--) {
        n || r.push(function (e) {
          return function (t) {
            e._trigger("deactivate", t, this._uiHash(this));
          };
        }.call(this, this.containers[i])), this.containers[i].containerCache.over && (r.push(function (e) {
          return function (t) {
            e._trigger("out", t, this._uiHash(this));
          };
        }.call(this, this.containers[i])), this.containers[i].containerCache.over = 0);
      }

      this._storedCursor && e("body").css("cursor", this._storedCursor), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", this._storedZIndex == "auto" ? "" : this._storedZIndex), this.dragging = !1;

      if (this.cancelHelperRemoval) {
        if (!n) {
          this._trigger("beforeStop", t, this._uiHash());

          for (var i = 0; i < r.length; i++) {
            r[i].call(this, t);
          }

          this._trigger("stop", t, this._uiHash());
        }

        return this.fromOutside = !1, !1;
      }

      n || this._trigger("beforeStop", t, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.helper[0] != this.currentItem[0] && this.helper.remove(), this.helper = null;

      if (!n) {
        for (var i = 0; i < r.length; i++) {
          r[i].call(this, t);
        }

        this._trigger("stop", t, this._uiHash());
      }

      return this.fromOutside = !1, !0;
    },
    _trigger: function _trigger() {
      e.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel();
    },
    _uiHash: function _uiHash(t) {
      var n = t || this;
      return {
        helper: n.helper,
        placeholder: n.placeholder || e([]),
        position: n.position,
        originalPosition: n.originalPosition,
        offset: n.positionAbs,
        item: n.currentItem,
        sender: t ? t.element : null
      };
    }
  });
}(jQuery), jQuery.effects || function (e, t) {
  var n = e.uiBackCompat !== !1,
      r = "ui-effects-";
  e.effects = {
    effect: {}
  }, function (t, n) {
    function p(e, t, n) {
      var r = a[t.type] || {};
      return e == null ? n || !t.def ? null : t.def : (e = r.floor ? ~~e : parseFloat(e), isNaN(e) ? t.def : r.mod ? (e + r.mod) % r.mod : 0 > e ? 0 : r.max < e ? r.max : e);
    }

    function d(e) {
      var n = o(),
          r = n._rgba = [];
      return e = e.toLowerCase(), h(s, function (t, i) {
        var s,
            o = i.re.exec(e),
            a = o && i.parse(o),
            f = i.space || "rgba";
        if (a) return s = n[f](a), n[u[f].cache] = s[u[f].cache], r = n._rgba = s._rgba, !1;
      }), r.length ? (r.join() === "0,0,0,0" && t.extend(r, c.transparent), n) : c[e];
    }

    function v(e, t, n) {
      return n = (n + 1) % 1, n * 6 < 1 ? e + (t - e) * n * 6 : n * 2 < 1 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e;
    }

    var r = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),
        i = /^([\-+])=\s*(\d+\.?\d*)/,
        s = [{
      re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
      parse: function parse(e) {
        return [e[1], e[2], e[3], e[4]];
      }
    }, {
      re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
      parse: function parse(e) {
        return [e[1] * 2.55, e[2] * 2.55, e[3] * 2.55, e[4]];
      }
    }, {
      re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
      parse: function parse(e) {
        return [parseInt(e[1], 16), parseInt(e[2], 16), parseInt(e[3], 16)];
      }
    }, {
      re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
      parse: function parse(e) {
        return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)];
      }
    }, {
      re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
      space: "hsla",
      parse: function parse(e) {
        return [e[1], e[2] / 100, e[3] / 100, e[4]];
      }
    }],
        o = t.Color = function (e, n, r, i) {
      return new t.Color.fn.parse(e, n, r, i);
    },
        u = {
      rgba: {
        props: {
          red: {
            idx: 0,
            type: "byte"
          },
          green: {
            idx: 1,
            type: "byte"
          },
          blue: {
            idx: 2,
            type: "byte"
          }
        }
      },
      hsla: {
        props: {
          hue: {
            idx: 0,
            type: "degrees"
          },
          saturation: {
            idx: 1,
            type: "percent"
          },
          lightness: {
            idx: 2,
            type: "percent"
          }
        }
      }
    },
        a = {
      "byte": {
        floor: !0,
        max: 255
      },
      percent: {
        max: 1
      },
      degrees: {
        mod: 360,
        floor: !0
      }
    },
        f = o.support = {},
        l = t("<p>")[0],
        c,
        h = t.each;

    l.style.cssText = "background-color:rgba(1,1,1,.5)", f.rgba = l.style.backgroundColor.indexOf("rgba") > -1, h(u, function (e, t) {
      t.cache = "_" + e, t.props.alpha = {
        idx: 3,
        type: "percent",
        def: 1
      };
    }), o.fn = t.extend(o.prototype, {
      parse: function parse(r, i, s, a) {
        if (r === n) return this._rgba = [null, null, null, null], this;
        if (r.jquery || r.nodeType) r = t(r).css(i), i = n;
        var f = this,
            l = t.type(r),
            v = this._rgba = [];
        i !== n && (r = [r, i, s, a], l = "array");
        if (l === "string") return this.parse(d(r) || c._default);
        if (l === "array") return h(u.rgba.props, function (e, t) {
          v[t.idx] = p(r[t.idx], t);
        }), this;
        if (l === "object") return r instanceof o ? h(u, function (e, t) {
          r[t.cache] && (f[t.cache] = r[t.cache].slice());
        }) : h(u, function (t, n) {
          var i = n.cache;
          h(n.props, function (e, t) {
            if (!f[i] && n.to) {
              if (e === "alpha" || r[e] == null) return;
              f[i] = n.to(f._rgba);
            }

            f[i][t.idx] = p(r[e], t, !0);
          }), f[i] && e.inArray(null, f[i].slice(0, 3)) < 0 && (f[i][3] = 1, n.from && (f._rgba = n.from(f[i])));
        }), this;
      },
      is: function is(e) {
        var t = o(e),
            n = !0,
            r = this;
        return h(u, function (e, i) {
          var s,
              o = t[i.cache];
          return o && (s = r[i.cache] || i.to && i.to(r._rgba) || [], h(i.props, function (e, t) {
            if (o[t.idx] != null) return n = o[t.idx] === s[t.idx], n;
          })), n;
        }), n;
      },
      _space: function _space() {
        var e = [],
            t = this;
        return h(u, function (n, r) {
          t[r.cache] && e.push(n);
        }), e.pop();
      },
      transition: function transition(e, t) {
        var n = o(e),
            r = n._space(),
            i = u[r],
            s = this.alpha() === 0 ? o("transparent") : this,
            f = s[i.cache] || i.to(s._rgba),
            l = f.slice();

        return n = n[i.cache], h(i.props, function (e, r) {
          var i = r.idx,
              s = f[i],
              o = n[i],
              u = a[r.type] || {};
          if (o === null) return;
          s === null ? l[i] = o : (u.mod && (o - s > u.mod / 2 ? s += u.mod : s - o > u.mod / 2 && (s -= u.mod)), l[i] = p((o - s) * t + s, r));
        }), this[r](l);
      },
      blend: function blend(e) {
        if (this._rgba[3] === 1) return this;

        var n = this._rgba.slice(),
            r = n.pop(),
            i = o(e)._rgba;

        return o(t.map(n, function (e, t) {
          return (1 - r) * i[t] + r * e;
        }));
      },
      toRgbaString: function toRgbaString() {
        var e = "rgba(",
            n = t.map(this._rgba, function (e, t) {
          return e == null ? t > 2 ? 1 : 0 : e;
        });
        return n[3] === 1 && (n.pop(), e = "rgb("), e + n.join() + ")";
      },
      toHslaString: function toHslaString() {
        var e = "hsla(",
            n = t.map(this.hsla(), function (e, t) {
          return e == null && (e = t > 2 ? 1 : 0), t && t < 3 && (e = Math.round(e * 100) + "%"), e;
        });
        return n[3] === 1 && (n.pop(), e = "hsl("), e + n.join() + ")";
      },
      toHexString: function toHexString(e) {
        var n = this._rgba.slice(),
            r = n.pop();

        return e && n.push(~~(r * 255)), "#" + t.map(n, function (e) {
          return e = (e || 0).toString(16), e.length === 1 ? "0" + e : e;
        }).join("");
      },
      toString: function toString() {
        return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
      }
    }), o.fn.parse.prototype = o.fn, u.hsla.to = function (e) {
      if (e[0] == null || e[1] == null || e[2] == null) return [null, null, null, e[3]];
      var t = e[0] / 255,
          n = e[1] / 255,
          r = e[2] / 255,
          i = e[3],
          s = Math.max(t, n, r),
          o = Math.min(t, n, r),
          u = s - o,
          a = s + o,
          f = a * .5,
          l,
          c;
      return o === s ? l = 0 : t === s ? l = 60 * (n - r) / u + 360 : n === s ? l = 60 * (r - t) / u + 120 : l = 60 * (t - n) / u + 240, f === 0 || f === 1 ? c = f : f <= .5 ? c = u / a : c = u / (2 - a), [Math.round(l) % 360, c, f, i == null ? 1 : i];
    }, u.hsla.from = function (e) {
      if (e[0] == null || e[1] == null || e[2] == null) return [null, null, null, e[3]];
      var t = e[0] / 360,
          n = e[1],
          r = e[2],
          i = e[3],
          s = r <= .5 ? r * (1 + n) : r + n - r * n,
          o = 2 * r - s;
      return [Math.round(v(o, s, t + 1 / 3) * 255), Math.round(v(o, s, t) * 255), Math.round(v(o, s, t - 1 / 3) * 255), i];
    }, h(u, function (e, r) {
      var s = r.props,
          u = r.cache,
          a = r.to,
          f = r.from;
      o.fn[e] = function (e) {
        a && !this[u] && (this[u] = a(this._rgba));
        if (e === n) return this[u].slice();
        var r,
            i = t.type(e),
            l = i === "array" || i === "object" ? e : arguments,
            c = this[u].slice();
        return h(s, function (e, t) {
          var n = l[i === "object" ? e : t.idx];
          n == null && (n = c[t.idx]), c[t.idx] = p(n, t);
        }), f ? (r = o(f(c)), r[u] = c, r) : o(c);
      }, h(s, function (n, r) {
        if (o.fn[n]) return;

        o.fn[n] = function (s) {
          var o = t.type(s),
              u = n === "alpha" ? this._hsla ? "hsla" : "rgba" : e,
              a = this[u](),
              f = a[r.idx],
              l;
          return o === "undefined" ? f : (o === "function" && (s = s.call(this, f), o = t.type(s)), s == null && r.empty ? this : (o === "string" && (l = i.exec(s), l && (s = f + parseFloat(l[2]) * (l[1] === "+" ? 1 : -1))), a[r.idx] = s, this[u](a)));
        };
      });
    }), h(r, function (e, n) {
      t.cssHooks[n] = {
        set: function set(e, r) {
          var i,
              s,
              u = "";

          if (t.type(r) !== "string" || (i = d(r))) {
            r = o(i || r);

            if (!f.rgba && r._rgba[3] !== 1) {
              s = n === "backgroundColor" ? e.parentNode : e;

              while ((u === "" || u === "transparent") && s && s.style) {
                try {
                  u = t.css(s, "backgroundColor"), s = s.parentNode;
                } catch (a) {}
              }

              r = r.blend(u && u !== "transparent" ? u : "_default");
            }

            r = r.toRgbaString();
          }

          try {
            e.style[n] = r;
          } catch (l) {}
        }
      }, t.fx.step[n] = function (e) {
        e.colorInit || (e.start = o(e.elem, n), e.end = o(e.end), e.colorInit = !0), t.cssHooks[n].set(e.elem, e.start.transition(e.end, e.pos));
      };
    }), t.cssHooks.borderColor = {
      expand: function expand(e) {
        var t = {};
        return h(["Top", "Right", "Bottom", "Left"], function (n, r) {
          t["border" + r + "Color"] = e;
        }), t;
      }
    }, c = t.Color.names = {
      aqua: "#00ffff",
      black: "#000000",
      blue: "#0000ff",
      fuchsia: "#ff00ff",
      gray: "#808080",
      green: "#008000",
      lime: "#00ff00",
      maroon: "#800000",
      navy: "#000080",
      olive: "#808000",
      purple: "#800080",
      red: "#ff0000",
      silver: "#c0c0c0",
      teal: "#008080",
      white: "#ffffff",
      yellow: "#ffff00",
      transparent: [null, null, null, 0],
      _default: "#ffffff"
    };
  }(jQuery), function () {
    function i() {
      var t = this.ownerDocument.defaultView ? this.ownerDocument.defaultView.getComputedStyle(this, null) : this.currentStyle,
          n = {},
          r,
          i;

      if (t && t.length && t[0] && t[t[0]]) {
        i = t.length;

        while (i--) {
          r = t[i], typeof t[r] == "string" && (n[e.camelCase(r)] = t[r]);
        }
      } else for (r in t) {
        typeof t[r] == "string" && (n[r] = t[r]);
      }

      return n;
    }

    function s(t, n) {
      var i = {},
          s,
          o;

      for (s in n) {
        o = n[s], t[s] !== o && !r[s] && (e.fx.step[s] || !isNaN(parseFloat(o))) && (i[s] = o);
      }

      return i;
    }

    var n = ["add", "remove", "toggle"],
        r = {
      border: 1,
      borderBottom: 1,
      borderColor: 1,
      borderLeft: 1,
      borderRight: 1,
      borderTop: 1,
      borderWidth: 1,
      margin: 1,
      padding: 1
    };
    e.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (t, n) {
      e.fx.step[n] = function (e) {
        if (e.end !== "none" && !e.setAttr || e.pos === 1 && !e.setAttr) jQuery.style(e.elem, n, e.end), e.setAttr = !0;
      };
    }), e.effects.animateClass = function (t, r, o, u) {
      var a = e.speed(r, o, u);
      return this.queue(function () {
        var r = e(this),
            o = r.attr("class") || "",
            u,
            f = a.children ? r.find("*").andSelf() : r;
        f = f.map(function () {
          var t = e(this);
          return {
            el: t,
            start: i.call(this)
          };
        }), u = function u() {
          e.each(n, function (e, n) {
            t[n] && r[n + "Class"](t[n]);
          });
        }, u(), f = f.map(function () {
          return this.end = i.call(this.el[0]), this.diff = s(this.start, this.end), this;
        }), r.attr("class", o), f = f.map(function () {
          var t = this,
              n = e.Deferred(),
              r = jQuery.extend({}, a, {
            queue: !1,
            complete: function complete() {
              n.resolve(t);
            }
          });
          return this.el.animate(this.diff, r), n.promise();
        }), e.when.apply(e, f.get()).done(function () {
          u(), e.each(arguments, function () {
            var t = this.el;
            e.each(this.diff, function (e) {
              t.css(e, "");
            });
          }), a.complete.call(r[0]);
        });
      });
    }, e.fn.extend({
      _addClass: e.fn.addClass,
      addClass: function addClass(t, n, r, i) {
        return n ? e.effects.animateClass.call(this, {
          add: t
        }, n, r, i) : this._addClass(t);
      },
      _removeClass: e.fn.removeClass,
      removeClass: function removeClass(t, n, r, i) {
        return n ? e.effects.animateClass.call(this, {
          remove: t
        }, n, r, i) : this._removeClass(t);
      },
      _toggleClass: e.fn.toggleClass,
      toggleClass: function toggleClass(n, r, i, s, o) {
        return typeof r == "boolean" || r === t ? i ? e.effects.animateClass.call(this, r ? {
          add: n
        } : {
          remove: n
        }, i, s, o) : this._toggleClass(n, r) : e.effects.animateClass.call(this, {
          toggle: n
        }, r, i, s);
      },
      switchClass: function switchClass(t, n, r, i, s) {
        return e.effects.animateClass.call(this, {
          add: n,
          remove: t
        }, r, i, s);
      }
    });
  }(), function () {
    function i(t, n, r, i) {
      e.isPlainObject(t) && (n = t, t = t.effect), t = {
        effect: t
      }, n == null && (n = {}), e.isFunction(n) && (i = n, r = null, n = {});
      if (typeof n == "number" || e.fx.speeds[n]) i = r, r = n, n = {};
      return e.isFunction(r) && (i = r, r = null), n && e.extend(t, n), r = r || n.duration, t.duration = e.fx.off ? 0 : typeof r == "number" ? r : r in e.fx.speeds ? e.fx.speeds[r] : e.fx.speeds._default, t.complete = i || n.complete, t;
    }

    function s(t) {
      return !t || typeof t == "number" || e.fx.speeds[t] ? !0 : typeof t == "string" && !e.effects.effect[t] ? n && e.effects[t] ? !1 : !0 : !1;
    }

    e.extend(e.effects, {
      version: "1.9.2",
      save: function save(e, t) {
        for (var n = 0; n < t.length; n++) {
          t[n] !== null && e.data(r + t[n], e[0].style[t[n]]);
        }
      },
      restore: function restore(e, n) {
        var i, s;

        for (s = 0; s < n.length; s++) {
          n[s] !== null && (i = e.data(r + n[s]), i === t && (i = ""), e.css(n[s], i));
        }
      },
      setMode: function setMode(e, t) {
        return t === "toggle" && (t = e.is(":hidden") ? "show" : "hide"), t;
      },
      getBaseline: function getBaseline(e, t) {
        var n, r;

        switch (e[0]) {
          case "top":
            n = 0;
            break;

          case "middle":
            n = .5;
            break;

          case "bottom":
            n = 1;
            break;

          default:
            n = e[0] / t.height;
        }

        switch (e[1]) {
          case "left":
            r = 0;
            break;

          case "center":
            r = .5;
            break;

          case "right":
            r = 1;
            break;

          default:
            r = e[1] / t.width;
        }

        return {
          x: r,
          y: n
        };
      },
      createWrapper: function createWrapper(t) {
        if (t.parent().is(".ui-effects-wrapper")) return t.parent();
        var n = {
          width: t.outerWidth(!0),
          height: t.outerHeight(!0),
          "float": t.css("float")
        },
            r = e("<div></div>").addClass("ui-effects-wrapper").css({
          fontSize: "100%",
          background: "transparent",
          border: "none",
          margin: 0,
          padding: 0
        }),
            i = {
          width: t.width(),
          height: t.height()
        },
            s = document.activeElement;

        try {
          s.id;
        } catch (o) {
          s = document.body;
        }

        return t.wrap(r), (t[0] === s || e.contains(t[0], s)) && e(s).focus(), r = t.parent(), t.css("position") === "static" ? (r.css({
          position: "relative"
        }), t.css({
          position: "relative"
        })) : (e.extend(n, {
          position: t.css("position"),
          zIndex: t.css("z-index")
        }), e.each(["top", "left", "bottom", "right"], function (e, r) {
          n[r] = t.css(r), isNaN(parseInt(n[r], 10)) && (n[r] = "auto");
        }), t.css({
          position: "relative",
          top: 0,
          left: 0,
          right: "auto",
          bottom: "auto"
        })), t.css(i), r.css(n).show();
      },
      removeWrapper: function removeWrapper(t) {
        var n = document.activeElement;
        return t.parent().is(".ui-effects-wrapper") && (t.parent().replaceWith(t), (t[0] === n || e.contains(t[0], n)) && e(n).focus()), t;
      },
      setTransition: function setTransition(t, n, r, i) {
        return i = i || {}, e.each(n, function (e, n) {
          var s = t.cssUnit(n);
          s[0] > 0 && (i[n] = s[0] * r + s[1]);
        }), i;
      }
    }), e.fn.extend({
      effect: function effect() {
        function a(n) {
          function u() {
            e.isFunction(i) && i.call(r[0]), e.isFunction(n) && n();
          }

          var r = e(this),
              i = t.complete,
              s = t.mode;
          (r.is(":hidden") ? s === "hide" : s === "show") ? u() : o.call(r[0], t, u);
        }

        var t = i.apply(this, arguments),
            r = t.mode,
            s = t.queue,
            o = e.effects.effect[t.effect],
            u = !o && n && e.effects[t.effect];
        return e.fx.off || !o && !u ? r ? this[r](t.duration, t.complete) : this.each(function () {
          t.complete && t.complete.call(this);
        }) : o ? s === !1 ? this.each(a) : this.queue(s || "fx", a) : u.call(this, {
          options: t,
          duration: t.duration,
          callback: t.complete,
          mode: t.mode
        });
      },
      _show: e.fn.show,
      show: function show(e) {
        if (s(e)) return this._show.apply(this, arguments);
        var t = i.apply(this, arguments);
        return t.mode = "show", this.effect.call(this, t);
      },
      _hide: e.fn.hide,
      hide: function hide(e) {
        if (s(e)) return this._hide.apply(this, arguments);
        var t = i.apply(this, arguments);
        return t.mode = "hide", this.effect.call(this, t);
      },
      __toggle: e.fn.toggle,
      toggle: function toggle(t) {
        if (s(t) || typeof t == "boolean" || e.isFunction(t)) return this.__toggle.apply(this, arguments);
        var n = i.apply(this, arguments);
        return n.mode = "toggle", this.effect.call(this, n);
      },
      cssUnit: function cssUnit(t) {
        var n = this.css(t),
            r = [];
        return e.each(["em", "px", "%", "pt"], function (e, t) {
          n.indexOf(t) > 0 && (r = [parseFloat(n), t]);
        }), r;
      }
    });
  }(), function () {
    var t = {};
    e.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (e, n) {
      t[n] = function (t) {
        return Math.pow(t, e + 2);
      };
    }), e.extend(t, {
      Sine: function Sine(e) {
        return 1 - Math.cos(e * Math.PI / 2);
      },
      Circ: function Circ(e) {
        return 1 - Math.sqrt(1 - e * e);
      },
      Elastic: function Elastic(e) {
        return e === 0 || e === 1 ? e : -Math.pow(2, 8 * (e - 1)) * Math.sin(((e - 1) * 80 - 7.5) * Math.PI / 15);
      },
      Back: function Back(e) {
        return e * e * (3 * e - 2);
      },
      Bounce: function Bounce(e) {
        var t,
            n = 4;

        while (e < ((t = Math.pow(2, --n)) - 1) / 11) {
          ;
        }

        return 1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((t * 3 - 2) / 22 - e, 2);
      }
    }), e.each(t, function (t, n) {
      e.easing["easeIn" + t] = n, e.easing["easeOut" + t] = function (e) {
        return 1 - n(1 - e);
      }, e.easing["easeInOut" + t] = function (e) {
        return e < .5 ? n(e * 2) / 2 : 1 - n(e * -2 + 2) / 2;
      };
    });
  }();
}(jQuery), function (e, t) {
  var n = 0,
      r = {},
      i = {};
  r.height = r.paddingTop = r.paddingBottom = r.borderTopWidth = r.borderBottomWidth = "hide", i.height = i.paddingTop = i.paddingBottom = i.borderTopWidth = i.borderBottomWidth = "show", e.widget("ui.accordion", {
    version: "1.9.2",
    options: {
      active: 0,
      animate: {},
      collapsible: !1,
      event: "click",
      header: "> li > :first-child,> :not(li):even",
      heightStyle: "auto",
      icons: {
        activeHeader: "ui-icon-triangle-1-s",
        header: "ui-icon-triangle-1-e"
      },
      activate: null,
      beforeActivate: null
    },
    _create: function _create() {
      var t = this.accordionId = "ui-accordion-" + (this.element.attr("id") || ++n),
          r = this.options;
      this.prevShow = this.prevHide = e(), this.element.addClass("ui-accordion ui-widget ui-helper-reset"), this.headers = this.element.find(r.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all"), this._hoverable(this.headers), this._focusable(this.headers), this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").hide(), !r.collapsible && (r.active === !1 || r.active == null) && (r.active = 0), r.active < 0 && (r.active += this.headers.length), this.active = this._findActive(r.active).addClass("ui-accordion-header-active ui-state-active").toggleClass("ui-corner-all ui-corner-top"), this.active.next().addClass("ui-accordion-content-active").show(), this._createIcons(), this.refresh(), this.element.attr("role", "tablist"), this.headers.attr("role", "tab").each(function (n) {
        var r = e(this),
            i = r.attr("id"),
            s = r.next(),
            o = s.attr("id");
        i || (i = t + "-header-" + n, r.attr("id", i)), o || (o = t + "-panel-" + n, s.attr("id", o)), r.attr("aria-controls", o), s.attr("aria-labelledby", i);
      }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
        "aria-selected": "false",
        tabIndex: -1
      }).next().attr({
        "aria-expanded": "false",
        "aria-hidden": "true"
      }).hide(), this.active.length ? this.active.attr({
        "aria-selected": "true",
        tabIndex: 0
      }).next().attr({
        "aria-expanded": "true",
        "aria-hidden": "false"
      }) : this.headers.eq(0).attr("tabIndex", 0), this._on(this.headers, {
        keydown: "_keydown"
      }), this._on(this.headers.next(), {
        keydown: "_panelKeyDown"
      }), this._setupEvents(r.event);
    },
    _getCreateEventData: function _getCreateEventData() {
      return {
        header: this.active,
        content: this.active.length ? this.active.next() : e()
      };
    },
    _createIcons: function _createIcons() {
      var t = this.options.icons;
      t && (e("<span>").addClass("ui-accordion-header-icon ui-icon " + t.header).prependTo(this.headers), this.active.children(".ui-accordion-header-icon").removeClass(t.header).addClass(t.activeHeader), this.headers.addClass("ui-accordion-icons"));
    },
    _destroyIcons: function _destroyIcons() {
      this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove();
    },
    _destroy: function _destroy() {
      var e;
      this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"), this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").each(function () {
        /^ui-accordion/.test(this.id) && this.removeAttribute("id");
      }), this._destroyIcons(), e = this.headers.next().css("display", "").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").each(function () {
        /^ui-accordion/.test(this.id) && this.removeAttribute("id");
      }), this.options.heightStyle !== "content" && e.css("height", "");
    },
    _setOption: function _setOption(e, t) {
      if (e === "active") {
        this._activate(t);

        return;
      }

      e === "event" && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(t)), this._super(e, t), e === "collapsible" && !t && this.options.active === !1 && this._activate(0), e === "icons" && (this._destroyIcons(), t && this._createIcons()), e === "disabled" && this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!t);
    },
    _keydown: function _keydown(t) {
      if (t.altKey || t.ctrlKey) return;
      var n = e.ui.keyCode,
          r = this.headers.length,
          i = this.headers.index(t.target),
          s = !1;

      switch (t.keyCode) {
        case n.RIGHT:
        case n.DOWN:
          s = this.headers[(i + 1) % r];
          break;

        case n.LEFT:
        case n.UP:
          s = this.headers[(i - 1 + r) % r];
          break;

        case n.SPACE:
        case n.ENTER:
          this._eventHandler(t);

          break;

        case n.HOME:
          s = this.headers[0];
          break;

        case n.END:
          s = this.headers[r - 1];
      }

      s && (e(t.target).attr("tabIndex", -1), e(s).attr("tabIndex", 0), s.focus(), t.preventDefault());
    },
    _panelKeyDown: function _panelKeyDown(t) {
      t.keyCode === e.ui.keyCode.UP && t.ctrlKey && e(t.currentTarget).prev().focus();
    },
    refresh: function refresh() {
      var t,
          n,
          r = this.options.heightStyle,
          i = this.element.parent();
      r === "fill" ? (e.support.minHeight || (n = i.css("overflow"), i.css("overflow", "hidden")), t = i.height(), this.element.siblings(":visible").each(function () {
        var n = e(this),
            r = n.css("position");
        if (r === "absolute" || r === "fixed") return;
        t -= n.outerHeight(!0);
      }), n && i.css("overflow", n), this.headers.each(function () {
        t -= e(this).outerHeight(!0);
      }), this.headers.next().each(function () {
        e(this).height(Math.max(0, t - e(this).innerHeight() + e(this).height()));
      }).css("overflow", "auto")) : r === "auto" && (t = 0, this.headers.next().each(function () {
        t = Math.max(t, e(this).css("height", "").height());
      }).height(t));
    },
    _activate: function _activate(t) {
      var n = this._findActive(t)[0];

      if (n === this.active[0]) return;
      n = n || this.active[0], this._eventHandler({
        target: n,
        currentTarget: n,
        preventDefault: e.noop
      });
    },
    _findActive: function _findActive(t) {
      return typeof t == "number" ? this.headers.eq(t) : e();
    },
    _setupEvents: function _setupEvents(t) {
      var n = {};
      if (!t) return;
      e.each(t.split(" "), function (e, t) {
        n[t] = "_eventHandler";
      }), this._on(this.headers, n);
    },
    _eventHandler: function _eventHandler(t) {
      var n = this.options,
          r = this.active,
          i = e(t.currentTarget),
          s = i[0] === r[0],
          o = s && n.collapsible,
          u = o ? e() : i.next(),
          a = r.next(),
          f = {
        oldHeader: r,
        oldPanel: a,
        newHeader: o ? e() : i,
        newPanel: u
      };
      t.preventDefault();
      if (s && !n.collapsible || this._trigger("beforeActivate", t, f) === !1) return;
      n.active = o ? !1 : this.headers.index(i), this.active = s ? e() : i, this._toggle(f), r.removeClass("ui-accordion-header-active ui-state-active"), n.icons && r.children(".ui-accordion-header-icon").removeClass(n.icons.activeHeader).addClass(n.icons.header), s || (i.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"), n.icons && i.children(".ui-accordion-header-icon").removeClass(n.icons.header).addClass(n.icons.activeHeader), i.next().addClass("ui-accordion-content-active"));
    },
    _toggle: function _toggle(t) {
      var n = t.newPanel,
          r = this.prevShow.length ? this.prevShow : t.oldPanel;
      this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = n, this.prevHide = r, this.options.animate ? this._animate(n, r, t) : (r.hide(), n.show(), this._toggleComplete(t)), r.attr({
        "aria-expanded": "false",
        "aria-hidden": "true"
      }), r.prev().attr("aria-selected", "false"), n.length && r.length ? r.prev().attr("tabIndex", -1) : n.length && this.headers.filter(function () {
        return e(this).attr("tabIndex") === 0;
      }).attr("tabIndex", -1), n.attr({
        "aria-expanded": "true",
        "aria-hidden": "false"
      }).prev().attr({
        "aria-selected": "true",
        tabIndex: 0
      });
    },
    _animate: function _animate(e, t, n) {
      var s,
          o,
          u,
          a = this,
          f = 0,
          l = e.length && (!t.length || e.index() < t.index()),
          c = this.options.animate || {},
          h = l && c.down || c,
          p = function p() {
        a._toggleComplete(n);
      };

      typeof h == "number" && (u = h), typeof h == "string" && (o = h), o = o || h.easing || c.easing, u = u || h.duration || c.duration;
      if (!t.length) return e.animate(i, u, o, p);
      if (!e.length) return t.animate(r, u, o, p);
      s = e.show().outerHeight(), t.animate(r, {
        duration: u,
        easing: o,
        step: function step(e, t) {
          t.now = Math.round(e);
        }
      }), e.hide().animate(i, {
        duration: u,
        easing: o,
        complete: p,
        step: function step(e, n) {
          n.now = Math.round(e), n.prop !== "height" ? f += n.now : a.options.heightStyle !== "content" && (n.now = Math.round(s - t.outerHeight() - f), f = 0);
        }
      });
    },
    _toggleComplete: function _toggleComplete(e) {
      var t = e.oldPanel;
      t.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"), t.length && (t.parent()[0].className = t.parent()[0].className), this._trigger("activate", null, e);
    }
  }), e.uiBackCompat !== !1 && (function (e, t) {
    e.extend(t.options, {
      navigation: !1,
      navigationFilter: function navigationFilter() {
        return this.href.toLowerCase() === location.href.toLowerCase();
      }
    });
    var n = t._create;

    t._create = function () {
      if (this.options.navigation) {
        var t = this,
            r = this.element.find(this.options.header),
            i = r.next(),
            s = r.add(i).find("a").filter(this.options.navigationFilter)[0];
        s && r.add(i).each(function (n) {
          if (e.contains(this, s)) return t.options.active = Math.floor(n / 2), !1;
        });
      }

      n.call(this);
    };
  }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
    e.extend(t.options, {
      heightStyle: null,
      autoHeight: !0,
      clearStyle: !1,
      fillSpace: !1
    });
    var n = t._create,
        r = t._setOption;
    e.extend(t, {
      _create: function _create() {
        this.options.heightStyle = this.options.heightStyle || this._mergeHeightStyle(), n.call(this);
      },
      _setOption: function _setOption(e) {
        if (e === "autoHeight" || e === "clearStyle" || e === "fillSpace") this.options.heightStyle = this._mergeHeightStyle();
        r.apply(this, arguments);
      },
      _mergeHeightStyle: function _mergeHeightStyle() {
        var e = this.options;
        if (e.fillSpace) return "fill";
        if (e.clearStyle) return "content";
        if (e.autoHeight) return "auto";
      }
    });
  }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
    e.extend(t.options.icons, {
      activeHeader: null,
      headerSelected: "ui-icon-triangle-1-s"
    });
    var n = t._createIcons;

    t._createIcons = function () {
      this.options.icons && (this.options.icons.activeHeader = this.options.icons.activeHeader || this.options.icons.headerSelected), n.call(this);
    };
  }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
    t.activate = t._activate;
    var n = t._findActive;

    t._findActive = function (e) {
      return e === -1 && (e = !1), e && typeof e != "number" && (e = this.headers.index(this.headers.filter(e)), e === -1 && (e = !1)), n.call(this, e);
    };
  }(jQuery, jQuery.ui.accordion.prototype), jQuery.ui.accordion.prototype.resize = jQuery.ui.accordion.prototype.refresh, function (e, t) {
    e.extend(t.options, {
      change: null,
      changestart: null
    });
    var n = t._trigger;

    t._trigger = function (e, t, r) {
      var i = n.apply(this, arguments);
      return i ? (e === "beforeActivate" ? i = n.call(this, "changestart", t, {
        oldHeader: r.oldHeader,
        oldContent: r.oldPanel,
        newHeader: r.newHeader,
        newContent: r.newPanel
      }) : e === "activate" && (i = n.call(this, "change", t, {
        oldHeader: r.oldHeader,
        oldContent: r.oldPanel,
        newHeader: r.newHeader,
        newContent: r.newPanel
      })), i) : !1;
    };
  }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
    e.extend(t.options, {
      animate: null,
      animated: "slide"
    });
    var n = t._create;

    t._create = function () {
      var e = this.options;
      e.animate === null && (e.animated ? e.animated === "slide" ? e.animate = 300 : e.animated === "bounceslide" ? e.animate = {
        duration: 200,
        down: {
          easing: "easeOutBounce",
          duration: 1e3
        }
      } : e.animate = e.animated : e.animate = !1), n.call(this);
    };
  }(jQuery, jQuery.ui.accordion.prototype));
}(jQuery), function (e, t) {
  var n = 0;
  e.widget("ui.autocomplete", {
    version: "1.9.2",
    defaultElement: "<input>",
    options: {
      appendTo: "body",
      autoFocus: !1,
      delay: 300,
      minLength: 1,
      position: {
        my: "left top",
        at: "left bottom",
        collision: "none"
      },
      source: null,
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null
    },
    pending: 0,
    _create: function _create() {
      var t, n, r;
      this.isMultiLine = this._isMultiLine(), this.valueMethod = this.element[this.element.is("input,textarea") ? "val" : "text"], this.isNewMenu = !0, this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off"), this._on(this.element, {
        keydown: function keydown(i) {
          if (this.element.prop("readOnly")) {
            t = !0, r = !0, n = !0;
            return;
          }

          t = !1, r = !1, n = !1;
          var s = e.ui.keyCode;

          switch (i.keyCode) {
            case s.PAGE_UP:
              t = !0, this._move("previousPage", i);
              break;

            case s.PAGE_DOWN:
              t = !0, this._move("nextPage", i);
              break;

            case s.UP:
              t = !0, this._keyEvent("previous", i);
              break;

            case s.DOWN:
              t = !0, this._keyEvent("next", i);
              break;

            case s.ENTER:
            case s.NUMPAD_ENTER:
              this.menu.active && (t = !0, i.preventDefault(), this.menu.select(i));
              break;

            case s.TAB:
              this.menu.active && this.menu.select(i);
              break;

            case s.ESCAPE:
              this.menu.element.is(":visible") && (this._value(this.term), this.close(i), i.preventDefault());
              break;

            default:
              n = !0, this._searchTimeout(i);
          }
        },
        keypress: function keypress(r) {
          if (t) {
            t = !1, r.preventDefault();
            return;
          }

          if (n) return;
          var i = e.ui.keyCode;

          switch (r.keyCode) {
            case i.PAGE_UP:
              this._move("previousPage", r);

              break;

            case i.PAGE_DOWN:
              this._move("nextPage", r);

              break;

            case i.UP:
              this._keyEvent("previous", r);

              break;

            case i.DOWN:
              this._keyEvent("next", r);

          }
        },
        input: function input(e) {
          if (r) {
            r = !1, e.preventDefault();
            return;
          }

          this._searchTimeout(e);
        },
        focus: function focus() {
          this.selectedItem = null, this.previous = this._value();
        },
        blur: function blur(e) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }

          clearTimeout(this.searching), this.close(e), this._change(e);
        }
      }), this._initSource(), this.menu = e("<ul>").addClass("ui-autocomplete").appendTo(this.document.find(this.options.appendTo || "body")[0]).menu({
        input: e(),
        role: null
      }).zIndex(this.element.zIndex() + 1).hide().data("menu"), this._on(this.menu.element, {
        mousedown: function mousedown(t) {
          t.preventDefault(), this.cancelBlur = !0, this._delay(function () {
            delete this.cancelBlur;
          });
          var n = this.menu.element[0];
          e(t.target).closest(".ui-menu-item").length || this._delay(function () {
            var t = this;
            this.document.one("mousedown", function (r) {
              r.target !== t.element[0] && r.target !== n && !e.contains(n, r.target) && t.close();
            });
          });
        },
        menufocus: function menufocus(t, n) {
          if (this.isNewMenu) {
            this.isNewMenu = !1;

            if (t.originalEvent && /^mouse/.test(t.originalEvent.type)) {
              this.menu.blur(), this.document.one("mousemove", function () {
                e(t.target).trigger(t.originalEvent);
              });
              return;
            }
          }

          var r = n.item.data("ui-autocomplete-item") || n.item.data("item.autocomplete");
          !1 !== this._trigger("focus", t, {
            item: r
          }) ? t.originalEvent && /^key/.test(t.originalEvent.type) && this._value(r.value) : this.liveRegion.text(r.value);
        },
        menuselect: function menuselect(e, t) {
          var n = t.item.data("ui-autocomplete-item") || t.item.data("item.autocomplete"),
              r = this.previous;
          this.element[0] !== this.document[0].activeElement && (this.element.focus(), this.previous = r, this._delay(function () {
            this.previous = r, this.selectedItem = n;
          })), !1 !== this._trigger("select", e, {
            item: n
          }) && this._value(n.value), this.term = this._value(), this.close(e), this.selectedItem = n;
        }
      }), this.liveRegion = e("<span>", {
        role: "status",
        "aria-live": "polite"
      }).addClass("ui-helper-hidden-accessible").insertAfter(this.element), e.fn.bgiframe && this.menu.element.bgiframe(), this._on(this.window, {
        beforeunload: function beforeunload() {
          this.element.removeAttr("autocomplete");
        }
      });
    },
    _destroy: function _destroy() {
      clearTimeout(this.searching), this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove();
    },
    _setOption: function _setOption(e, t) {
      this._super(e, t), e === "source" && this._initSource(), e === "appendTo" && this.menu.element.appendTo(this.document.find(t || "body")[0]), e === "disabled" && t && this.xhr && this.xhr.abort();
    },
    _isMultiLine: function _isMultiLine() {
      return this.element.is("textarea") ? !0 : this.element.is("input") ? !1 : this.element.prop("isContentEditable");
    },
    _initSource: function _initSource() {
      var t,
          n,
          r = this;
      e.isArray(this.options.source) ? (t = this.options.source, this.source = function (n, r) {
        r(e.ui.autocomplete.filter(t, n.term));
      }) : typeof this.options.source == "string" ? (n = this.options.source, this.source = function (t, i) {
        r.xhr && r.xhr.abort(), r.xhr = e.ajax({
          url: n,
          data: t,
          dataType: "json",
          success: function success(e) {
            i(e);
          },
          error: function error() {
            i([]);
          }
        });
      }) : this.source = this.options.source;
    },
    _searchTimeout: function _searchTimeout(e) {
      clearTimeout(this.searching), this.searching = this._delay(function () {
        this.term !== this._value() && (this.selectedItem = null, this.search(null, e));
      }, this.options.delay);
    },
    search: function search(e, t) {
      e = e != null ? e : this._value(), this.term = this._value();
      if (e.length < this.options.minLength) return this.close(t);
      if (this._trigger("search", t) === !1) return;
      return this._search(e);
    },
    _search: function _search(e) {
      this.pending++, this.element.addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({
        term: e
      }, this._response());
    },
    _response: function _response() {
      var e = this,
          t = ++n;
      return function (r) {
        t === n && e.__response(r), e.pending--, e.pending || e.element.removeClass("ui-autocomplete-loading");
      };
    },
    __response: function __response(e) {
      e && (e = this._normalize(e)), this._trigger("response", null, {
        content: e
      }), !this.options.disabled && e && e.length && !this.cancelSearch ? (this._suggest(e), this._trigger("open")) : this._close();
    },
    close: function close(e) {
      this.cancelSearch = !0, this._close(e);
    },
    _close: function _close(e) {
      this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", e));
    },
    _change: function _change(e) {
      this.previous !== this._value() && this._trigger("change", e, {
        item: this.selectedItem
      });
    },
    _normalize: function _normalize(t) {
      return t.length && t[0].label && t[0].value ? t : e.map(t, function (t) {
        return typeof t == "string" ? {
          label: t,
          value: t
        } : e.extend({
          label: t.label || t.value,
          value: t.value || t.label
        }, t);
      });
    },
    _suggest: function _suggest(t) {
      var n = this.menu.element.empty().zIndex(this.element.zIndex() + 1);
      this._renderMenu(n, t), this.menu.refresh(), n.show(), this._resizeMenu(), n.position(e.extend({
        of: this.element
      }, this.options.position)), this.options.autoFocus && this.menu.next();
    },
    _resizeMenu: function _resizeMenu() {
      var e = this.menu.element;
      e.outerWidth(Math.max(e.width("").outerWidth() + 1, this.element.outerWidth()));
    },
    _renderMenu: function _renderMenu(t, n) {
      var r = this;
      e.each(n, function (e, n) {
        r._renderItemData(t, n);
      });
    },
    _renderItemData: function _renderItemData(e, t) {
      return this._renderItem(e, t).data("ui-autocomplete-item", t);
    },
    _renderItem: function _renderItem(t, n) {
      return e("<li>").append(e("<a>").text(n.label)).appendTo(t);
    },
    _move: function _move(e, t) {
      if (!this.menu.element.is(":visible")) {
        this.search(null, t);
        return;
      }

      if (this.menu.isFirstItem() && /^previous/.test(e) || this.menu.isLastItem() && /^next/.test(e)) {
        this._value(this.term), this.menu.blur();
        return;
      }

      this.menu[e](t);
    },
    widget: function widget() {
      return this.menu.element;
    },
    _value: function _value() {
      return this.valueMethod.apply(this.element, arguments);
    },
    _keyEvent: function _keyEvent(e, t) {
      if (!this.isMultiLine || this.menu.element.is(":visible")) this._move(e, t), t.preventDefault();
    }
  }), e.extend(e.ui.autocomplete, {
    escapeRegex: function escapeRegex(e) {
      return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    },
    filter: function filter(t, n) {
      var r = new RegExp(e.ui.autocomplete.escapeRegex(n), "i");
      return e.grep(t, function (e) {
        return r.test(e.label || e.value || e);
      });
    }
  }), e.widget("ui.autocomplete", e.ui.autocomplete, {
    options: {
      messages: {
        noResults: "No search results.",
        results: function results(e) {
          return e + (e > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
        }
      }
    },
    __response: function __response(e) {
      var t;

      this._superApply(arguments);

      if (this.options.disabled || this.cancelSearch) return;
      e && e.length ? t = this.options.messages.results(e.length) : t = this.options.messages.noResults, this.liveRegion.text(t);
    }
  });
}(jQuery), function (e, t) {
  var n,
      r,
      i,
      s,
      o = "ui-button ui-widget ui-state-default ui-corner-all",
      u = "ui-state-hover ui-state-active ",
      a = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
      f = function f() {
    var t = e(this).find(":ui-button");
    setTimeout(function () {
      t.button("refresh");
    }, 1);
  },
      l = function l(t) {
    var n = t.name,
        r = t.form,
        i = e([]);
    return n && (r ? i = e(r).find("[name='" + n + "']") : i = e("[name='" + n + "']", t.ownerDocument).filter(function () {
      return !this.form;
    })), i;
  };

  e.widget("ui.button", {
    version: "1.9.2",
    defaultElement: "<button>",
    options: {
      disabled: null,
      text: !0,
      label: null,
      icons: {
        primary: null,
        secondary: null
      }
    },
    _create: function _create() {
      this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, f), typeof this.options.disabled != "boolean" ? this.options.disabled = !!this.element.prop("disabled") : this.element.prop("disabled", this.options.disabled), this._determineButtonType(), this.hasTitle = !!this.buttonElement.attr("title");
      var t = this,
          u = this.options,
          a = this.type === "checkbox" || this.type === "radio",
          c = a ? "" : "ui-state-active",
          h = "ui-state-focus";
      u.label === null && (u.label = this.type === "input" ? this.buttonElement.val() : this.buttonElement.html()), this._hoverable(this.buttonElement), this.buttonElement.addClass(o).attr("role", "button").bind("mouseenter" + this.eventNamespace, function () {
        if (u.disabled) return;
        this === n && e(this).addClass("ui-state-active");
      }).bind("mouseleave" + this.eventNamespace, function () {
        if (u.disabled) return;
        e(this).removeClass(c);
      }).bind("click" + this.eventNamespace, function (e) {
        u.disabled && (e.preventDefault(), e.stopImmediatePropagation());
      }), this.element.bind("focus" + this.eventNamespace, function () {
        t.buttonElement.addClass(h);
      }).bind("blur" + this.eventNamespace, function () {
        t.buttonElement.removeClass(h);
      }), a && (this.element.bind("change" + this.eventNamespace, function () {
        if (s) return;
        t.refresh();
      }), this.buttonElement.bind("mousedown" + this.eventNamespace, function (e) {
        if (u.disabled) return;
        s = !1, r = e.pageX, i = e.pageY;
      }).bind("mouseup" + this.eventNamespace, function (e) {
        if (u.disabled) return;
        if (r !== e.pageX || i !== e.pageY) s = !0;
      })), this.type === "checkbox" ? this.buttonElement.bind("click" + this.eventNamespace, function () {
        if (u.disabled || s) return !1;
        e(this).toggleClass("ui-state-active"), t.buttonElement.attr("aria-pressed", t.element[0].checked);
      }) : this.type === "radio" ? this.buttonElement.bind("click" + this.eventNamespace, function () {
        if (u.disabled || s) return !1;
        e(this).addClass("ui-state-active"), t.buttonElement.attr("aria-pressed", "true");
        var n = t.element[0];
        l(n).not(n).map(function () {
          return e(this).button("widget")[0];
        }).removeClass("ui-state-active").attr("aria-pressed", "false");
      }) : (this.buttonElement.bind("mousedown" + this.eventNamespace, function () {
        if (u.disabled) return !1;
        e(this).addClass("ui-state-active"), n = this, t.document.one("mouseup", function () {
          n = null;
        });
      }).bind("mouseup" + this.eventNamespace, function () {
        if (u.disabled) return !1;
        e(this).removeClass("ui-state-active");
      }).bind("keydown" + this.eventNamespace, function (t) {
        if (u.disabled) return !1;
        (t.keyCode === e.ui.keyCode.SPACE || t.keyCode === e.ui.keyCode.ENTER) && e(this).addClass("ui-state-active");
      }).bind("keyup" + this.eventNamespace, function () {
        e(this).removeClass("ui-state-active");
      }), this.buttonElement.is("a") && this.buttonElement.keyup(function (t) {
        t.keyCode === e.ui.keyCode.SPACE && e(this).click();
      })), this._setOption("disabled", u.disabled), this._resetButton();
    },
    _determineButtonType: function _determineButtonType() {
      var e, t, n;
      this.element.is("[type=checkbox]") ? this.type = "checkbox" : this.element.is("[type=radio]") ? this.type = "radio" : this.element.is("input") ? this.type = "input" : this.type = "button", this.type === "checkbox" || this.type === "radio" ? (e = this.element.parents().last(), t = "label[for='" + this.element.attr("id") + "']", this.buttonElement = e.find(t), this.buttonElement.length || (e = e.length ? e.siblings() : this.element.siblings(), this.buttonElement = e.filter(t), this.buttonElement.length || (this.buttonElement = e.find(t))), this.element.addClass("ui-helper-hidden-accessible"), n = this.element.is(":checked"), n && this.buttonElement.addClass("ui-state-active"), this.buttonElement.prop("aria-pressed", n)) : this.buttonElement = this.element;
    },
    widget: function widget() {
      return this.buttonElement;
    },
    _destroy: function _destroy() {
      this.element.removeClass("ui-helper-hidden-accessible"), this.buttonElement.removeClass(o + " " + u + " " + a).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()), this.hasTitle || this.buttonElement.removeAttr("title");
    },
    _setOption: function _setOption(e, t) {
      this._super(e, t);

      if (e === "disabled") {
        t ? this.element.prop("disabled", !0) : this.element.prop("disabled", !1);
        return;
      }

      this._resetButton();
    },
    refresh: function refresh() {
      var t = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
      t !== this.options.disabled && this._setOption("disabled", t), this.type === "radio" ? l(this.element[0]).each(function () {
        e(this).is(":checked") ? e(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true") : e(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
      }) : this.type === "checkbox" && (this.element.is(":checked") ? this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") : this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false"));
    },
    _resetButton: function _resetButton() {
      if (this.type === "input") {
        this.options.label && this.element.val(this.options.label);
        return;
      }

      var t = this.buttonElement.removeClass(a),
          n = e("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(t.empty()).text(),
          r = this.options.icons,
          i = r.primary && r.secondary,
          s = [];
      r.primary || r.secondary ? (this.options.text && s.push("ui-button-text-icon" + (i ? "s" : r.primary ? "-primary" : "-secondary")), r.primary && t.prepend("<span class='ui-button-icon-primary ui-icon " + r.primary + "'></span>"), r.secondary && t.append("<span class='ui-button-icon-secondary ui-icon " + r.secondary + "'></span>"), this.options.text || (s.push(i ? "ui-button-icons-only" : "ui-button-icon-only"), this.hasTitle || t.attr("title", e.trim(n)))) : s.push("ui-button-text-only"), t.addClass(s.join(" "));
    }
  }), e.widget("ui.buttonset", {
    version: "1.9.2",
    options: {
      items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)"
    },
    _create: function _create() {
      this.element.addClass("ui-buttonset");
    },
    _init: function _init() {
      this.refresh();
    },
    _setOption: function _setOption(e, t) {
      e === "disabled" && this.buttons.button("option", e, t), this._super(e, t);
    },
    refresh: function refresh() {
      var t = this.element.css("direction") === "rtl";
      this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function () {
        return e(this).button("widget")[0];
      }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(t ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(t ? "ui-corner-left" : "ui-corner-right").end().end();
    },
    _destroy: function _destroy() {
      this.element.removeClass("ui-buttonset"), this.buttons.map(function () {
        return e(this).button("widget")[0];
      }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
    }
  });
}(jQuery), function ($, undefined) {
  function Datepicker() {
    this.debug = !1, this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
      closeText: "Done",
      prevText: "Prev",
      nextText: "Next",
      currentText: "Today",
      monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      weekHeader: "Wk",
      dateFormat: "mm/dd/yy",
      firstDay: 0,
      isRTL: !1,
      showMonthAfterYear: !1,
      yearSuffix: ""
    }, this._defaults = {
      showOn: "focus",
      showAnim: "fadeIn",
      showOptions: {},
      defaultDate: null,
      appendText: "",
      buttonText: "...",
      buttonImage: "",
      buttonImageOnly: !1,
      hideIfNoPrevNext: !1,
      navigationAsDateFormat: !1,
      gotoCurrent: !1,
      changeMonth: !1,
      changeYear: !1,
      yearRange: "c-10:c+10",
      showOtherMonths: !1,
      selectOtherMonths: !1,
      showWeek: !1,
      calculateWeek: this.iso8601Week,
      shortYearCutoff: "+10",
      minDate: null,
      maxDate: null,
      duration: "fast",
      beforeShowDay: null,
      beforeShow: null,
      onSelect: null,
      onChangeMonthYear: null,
      onClose: null,
      numberOfMonths: 1,
      showCurrentAtPos: 0,
      stepMonths: 1,
      stepBigMonths: 12,
      altField: "",
      altFormat: "",
      constrainInput: !0,
      showButtonPanel: !1,
      autoSize: !1,
      disabled: !1
    }, $.extend(this._defaults, this.regional[""]), this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
  }

  function bindHover(e) {
    var t = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
    return e.delegate(t, "mouseout", function () {
      $(this).removeClass("ui-state-hover"), this.className.indexOf("ui-datepicker-prev") != -1 && $(this).removeClass("ui-datepicker-prev-hover"), this.className.indexOf("ui-datepicker-next") != -1 && $(this).removeClass("ui-datepicker-next-hover");
    }).delegate(t, "mouseover", function () {
      $.datepicker._isDisabledDatepicker(instActive.inline ? e.parent()[0] : instActive.input[0]) || ($(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), $(this).addClass("ui-state-hover"), this.className.indexOf("ui-datepicker-prev") != -1 && $(this).addClass("ui-datepicker-prev-hover"), this.className.indexOf("ui-datepicker-next") != -1 && $(this).addClass("ui-datepicker-next-hover"));
    });
  }

  function extendRemove(e, t) {
    $.extend(e, t);

    for (var n in t) {
      if (t[n] == null || t[n] == undefined) e[n] = t[n];
    }

    return e;
  }

  $.extend($.ui, {
    datepicker: {
      version: "1.9.2"
    }
  });
  var PROP_NAME = "datepicker",
      dpuuid = new Date().getTime(),
      instActive;
  $.extend(Datepicker.prototype, {
    markerClassName: "hasDatepicker",
    maxRows: 4,
    log: function log() {
      this.debug && console.log.apply("", arguments);
    },
    _widgetDatepicker: function _widgetDatepicker() {
      return this.dpDiv;
    },
    setDefaults: function setDefaults(e) {
      return extendRemove(this._defaults, e || {}), this;
    },
    _attachDatepicker: function _attachDatepicker(target, settings) {
      var inlineSettings = null;

      for (var attrName in this._defaults) {
        var attrValue = target.getAttribute("date:" + attrName);

        if (attrValue) {
          inlineSettings = inlineSettings || {};

          try {
            inlineSettings[attrName] = eval(attrValue);
          } catch (err) {
            inlineSettings[attrName] = attrValue;
          }
        }
      }

      var nodeName = target.nodeName.toLowerCase(),
          inline = nodeName == "div" || nodeName == "span";
      target.id || (this.uuid += 1, target.id = "dp" + this.uuid);

      var inst = this._newInst($(target), inline);

      inst.settings = $.extend({}, settings || {}, inlineSettings || {}), nodeName == "input" ? this._connectDatepicker(target, inst) : inline && this._inlineDatepicker(target, inst);
    },
    _newInst: function _newInst(e, t) {
      var n = e[0].id.replace(/([^A-Za-z0-9_-])/g, "\\\\$1");
      return {
        id: n,
        input: e,
        selectedDay: 0,
        selectedMonth: 0,
        selectedYear: 0,
        drawMonth: 0,
        drawYear: 0,
        inline: t,
        dpDiv: t ? bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')) : this.dpDiv
      };
    },
    _connectDatepicker: function _connectDatepicker(e, t) {
      var n = $(e);
      t.append = $([]), t.trigger = $([]);
      if (n.hasClass(this.markerClassName)) return;
      this._attachments(n, t), n.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker", function (e, n, r) {
        t.settings[n] = r;
      }).bind("getData.datepicker", function (e, n) {
        return this._get(t, n);
      }), this._autoSize(t), $.data(e, PROP_NAME, t), t.settings.disabled && this._disableDatepicker(e);
    },
    _attachments: function _attachments(e, t) {
      var n = this._get(t, "appendText"),
          r = this._get(t, "isRTL");

      t.append && t.append.remove(), n && (t.append = $('<span class="' + this._appendClass + '">' + n + "</span>"), e[r ? "before" : "after"](t.append)), e.unbind("focus", this._showDatepicker), t.trigger && t.trigger.remove();

      var i = this._get(t, "showOn");

      (i == "focus" || i == "both") && e.focus(this._showDatepicker);

      if (i == "button" || i == "both") {
        var s = this._get(t, "buttonText"),
            o = this._get(t, "buttonImage");

        t.trigger = $(this._get(t, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
          src: o,
          alt: s,
          title: s
        }) : $('<button type="button"></button>').addClass(this._triggerClass).html(o == "" ? s : $("<img/>").attr({
          src: o,
          alt: s,
          title: s
        }))), e[r ? "before" : "after"](t.trigger), t.trigger.click(function () {
          return $.datepicker._datepickerShowing && $.datepicker._lastInput == e[0] ? $.datepicker._hideDatepicker() : $.datepicker._datepickerShowing && $.datepicker._lastInput != e[0] ? ($.datepicker._hideDatepicker(), $.datepicker._showDatepicker(e[0])) : $.datepicker._showDatepicker(e[0]), !1;
        });
      }
    },
    _autoSize: function _autoSize(e) {
      if (this._get(e, "autoSize") && !e.inline) {
        var t = new Date(2009, 11, 20),
            n = this._get(e, "dateFormat");

        if (n.match(/[DM]/)) {
          var r = function r(e) {
            var t = 0,
                n = 0;

            for (var r = 0; r < e.length; r++) {
              e[r].length > t && (t = e[r].length, n = r);
            }

            return n;
          };

          t.setMonth(r(this._get(e, n.match(/MM/) ? "monthNames" : "monthNamesShort"))), t.setDate(r(this._get(e, n.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - t.getDay());
        }

        e.input.attr("size", this._formatDate(e, t).length);
      }
    },
    _inlineDatepicker: function _inlineDatepicker(e, t) {
      var n = $(e);
      if (n.hasClass(this.markerClassName)) return;
      n.addClass(this.markerClassName).append(t.dpDiv).bind("setData.datepicker", function (e, n, r) {
        t.settings[n] = r;
      }).bind("getData.datepicker", function (e, n) {
        return this._get(t, n);
      }), $.data(e, PROP_NAME, t), this._setDate(t, this._getDefaultDate(t), !0), this._updateDatepicker(t), this._updateAlternate(t), t.settings.disabled && this._disableDatepicker(e), t.dpDiv.css("display", "block");
    },
    _dialogDatepicker: function _dialogDatepicker(e, t, n, r, i) {
      var s = this._dialogInst;

      if (!s) {
        this.uuid += 1;
        var o = "dp" + this.uuid;
        this._dialogInput = $('<input type="text" id="' + o + '" style="position: absolute; top: -100px; width: 0px;"/>'), this._dialogInput.keydown(this._doKeyDown), $("body").append(this._dialogInput), s = this._dialogInst = this._newInst(this._dialogInput, !1), s.settings = {}, $.data(this._dialogInput[0], PROP_NAME, s);
      }

      extendRemove(s.settings, r || {}), t = t && t.constructor == Date ? this._formatDate(s, t) : t, this._dialogInput.val(t), this._pos = i ? i.length ? i : [i.pageX, i.pageY] : null;

      if (!this._pos) {
        var u = document.documentElement.clientWidth,
            a = document.documentElement.clientHeight,
            f = document.documentElement.scrollLeft || document.body.scrollLeft,
            l = document.documentElement.scrollTop || document.body.scrollTop;
        this._pos = [u / 2 - 100 + f, a / 2 - 150 + l];
      }

      return this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), s.settings.onSelect = n, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), $.blockUI && $.blockUI(this.dpDiv), $.data(this._dialogInput[0], PROP_NAME, s), this;
    },
    _destroyDatepicker: function _destroyDatepicker(e) {
      var t = $(e),
          n = $.data(e, PROP_NAME);
      if (!t.hasClass(this.markerClassName)) return;
      var r = e.nodeName.toLowerCase();
      $.removeData(e, PROP_NAME), r == "input" ? (n.append.remove(), n.trigger.remove(), t.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp)) : (r == "div" || r == "span") && t.removeClass(this.markerClassName).empty();
    },
    _enableDatepicker: function _enableDatepicker(e) {
      var t = $(e),
          n = $.data(e, PROP_NAME);
      if (!t.hasClass(this.markerClassName)) return;
      var r = e.nodeName.toLowerCase();
      if (r == "input") e.disabled = !1, n.trigger.filter("button").each(function () {
        this.disabled = !1;
      }).end().filter("img").css({
        opacity: "1.0",
        cursor: ""
      });else if (r == "div" || r == "span") {
        var i = t.children("." + this._inlineClass);
        i.children().removeClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (t) {
        return t == e ? null : t;
      });
    },
    _disableDatepicker: function _disableDatepicker(e) {
      var t = $(e),
          n = $.data(e, PROP_NAME);
      if (!t.hasClass(this.markerClassName)) return;
      var r = e.nodeName.toLowerCase();
      if (r == "input") e.disabled = !0, n.trigger.filter("button").each(function () {
        this.disabled = !0;
      }).end().filter("img").css({
        opacity: "0.5",
        cursor: "default"
      });else if (r == "div" || r == "span") {
        var i = t.children("." + this._inlineClass);
        i.children().addClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (t) {
        return t == e ? null : t;
      }), this._disabledInputs[this._disabledInputs.length] = e;
    },
    _isDisabledDatepicker: function _isDisabledDatepicker(e) {
      if (!e) return !1;

      for (var t = 0; t < this._disabledInputs.length; t++) {
        if (this._disabledInputs[t] == e) return !0;
      }

      return !1;
    },
    _getInst: function _getInst(e) {
      try {
        return $.data(e, PROP_NAME);
      } catch (t) {
        throw "Missing instance data for this datepicker";
      }
    },
    _optionDatepicker: function _optionDatepicker(e, t, n) {
      var r = this._getInst(e);

      if (arguments.length == 2 && typeof t == "string") return t == "defaults" ? $.extend({}, $.datepicker._defaults) : r ? t == "all" ? $.extend({}, r.settings) : this._get(r, t) : null;
      var i = t || {};
      typeof t == "string" && (i = {}, i[t] = n);

      if (r) {
        this._curInst == r && this._hideDatepicker();

        var s = this._getDateDatepicker(e, !0),
            o = this._getMinMaxDate(r, "min"),
            u = this._getMinMaxDate(r, "max");

        extendRemove(r.settings, i), o !== null && i.dateFormat !== undefined && i.minDate === undefined && (r.settings.minDate = this._formatDate(r, o)), u !== null && i.dateFormat !== undefined && i.maxDate === undefined && (r.settings.maxDate = this._formatDate(r, u)), this._attachments($(e), r), this._autoSize(r), this._setDate(r, s), this._updateAlternate(r), this._updateDatepicker(r);
      }
    },
    _changeDatepicker: function _changeDatepicker(e, t, n) {
      this._optionDatepicker(e, t, n);
    },
    _refreshDatepicker: function _refreshDatepicker(e) {
      var t = this._getInst(e);

      t && this._updateDatepicker(t);
    },
    _setDateDatepicker: function _setDateDatepicker(e, t) {
      var n = this._getInst(e);

      n && (this._setDate(n, t), this._updateDatepicker(n), this._updateAlternate(n));
    },
    _getDateDatepicker: function _getDateDatepicker(e, t) {
      var n = this._getInst(e);

      return n && !n.inline && this._setDateFromField(n, t), n ? this._getDate(n) : null;
    },
    _doKeyDown: function _doKeyDown(e) {
      var t = $.datepicker._getInst(e.target),
          n = !0,
          r = t.dpDiv.is(".ui-datepicker-rtl");

      t._keyEvent = !0;
      if ($.datepicker._datepickerShowing) switch (e.keyCode) {
        case 9:
          $.datepicker._hideDatepicker(), n = !1;
          break;

        case 13:
          var i = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", t.dpDiv);
          i[0] && $.datepicker._selectDay(e.target, t.selectedMonth, t.selectedYear, i[0]);

          var s = $.datepicker._get(t, "onSelect");

          if (s) {
            var o = $.datepicker._formatDate(t);

            s.apply(t.input ? t.input[0] : null, [o, t]);
          } else $.datepicker._hideDatepicker();

          return !1;

        case 27:
          $.datepicker._hideDatepicker();

          break;

        case 33:
          $.datepicker._adjustDate(e.target, e.ctrlKey ? -$.datepicker._get(t, "stepBigMonths") : -$.datepicker._get(t, "stepMonths"), "M");

          break;

        case 34:
          $.datepicker._adjustDate(e.target, e.ctrlKey ? +$.datepicker._get(t, "stepBigMonths") : +$.datepicker._get(t, "stepMonths"), "M");

          break;

        case 35:
          (e.ctrlKey || e.metaKey) && $.datepicker._clearDate(e.target), n = e.ctrlKey || e.metaKey;
          break;

        case 36:
          (e.ctrlKey || e.metaKey) && $.datepicker._gotoToday(e.target), n = e.ctrlKey || e.metaKey;
          break;

        case 37:
          (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, r ? 1 : -1, "D"), n = e.ctrlKey || e.metaKey, e.originalEvent.altKey && $.datepicker._adjustDate(e.target, e.ctrlKey ? -$.datepicker._get(t, "stepBigMonths") : -$.datepicker._get(t, "stepMonths"), "M");
          break;

        case 38:
          (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, -7, "D"), n = e.ctrlKey || e.metaKey;
          break;

        case 39:
          (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, r ? -1 : 1, "D"), n = e.ctrlKey || e.metaKey, e.originalEvent.altKey && $.datepicker._adjustDate(e.target, e.ctrlKey ? +$.datepicker._get(t, "stepBigMonths") : +$.datepicker._get(t, "stepMonths"), "M");
          break;

        case 40:
          (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, 7, "D"), n = e.ctrlKey || e.metaKey;
          break;

        default:
          n = !1;
      } else e.keyCode == 36 && e.ctrlKey ? $.datepicker._showDatepicker(this) : n = !1;
      n && (e.preventDefault(), e.stopPropagation());
    },
    _doKeyPress: function _doKeyPress(e) {
      var t = $.datepicker._getInst(e.target);

      if ($.datepicker._get(t, "constrainInput")) {
        var n = $.datepicker._possibleChars($.datepicker._get(t, "dateFormat")),
            r = String.fromCharCode(e.charCode == undefined ? e.keyCode : e.charCode);

        return e.ctrlKey || e.metaKey || r < " " || !n || n.indexOf(r) > -1;
      }
    },
    _doKeyUp: function _doKeyUp(e) {
      var t = $.datepicker._getInst(e.target);

      if (t.input.val() != t.lastVal) try {
        var n = $.datepicker.parseDate($.datepicker._get(t, "dateFormat"), t.input ? t.input.val() : null, $.datepicker._getFormatConfig(t));
        n && ($.datepicker._setDateFromField(t), $.datepicker._updateAlternate(t), $.datepicker._updateDatepicker(t));
      } catch (r) {
        $.datepicker.log(r);
      }
      return !0;
    },
    _showDatepicker: function _showDatepicker(e) {
      e = e.target || e, e.nodeName.toLowerCase() != "input" && (e = $("input", e.parentNode)[0]);
      if ($.datepicker._isDisabledDatepicker(e) || $.datepicker._lastInput == e) return;

      var t = $.datepicker._getInst(e);

      $.datepicker._curInst && $.datepicker._curInst != t && ($.datepicker._curInst.dpDiv.stop(!0, !0), t && $.datepicker._datepickerShowing && $.datepicker._hideDatepicker($.datepicker._curInst.input[0]));

      var n = $.datepicker._get(t, "beforeShow"),
          r = n ? n.apply(e, [e, t]) : {};

      if (r === !1) return;
      extendRemove(t.settings, r), t.lastVal = null, $.datepicker._lastInput = e, $.datepicker._setDateFromField(t), $.datepicker._inDialog && (e.value = ""), $.datepicker._pos || ($.datepicker._pos = $.datepicker._findPos(e), $.datepicker._pos[1] += e.offsetHeight);
      var i = !1;
      $(e).parents().each(function () {
        return i |= $(this).css("position") == "fixed", !i;
      });
      var s = {
        left: $.datepicker._pos[0],
        top: $.datepicker._pos[1]
      };
      $.datepicker._pos = null, t.dpDiv.empty(), t.dpDiv.css({
        position: "absolute",
        display: "block",
        top: "-1000px"
      }), $.datepicker._updateDatepicker(t), s = $.datepicker._checkOffset(t, s, i), t.dpDiv.css({
        position: $.datepicker._inDialog && $.blockUI ? "static" : i ? "fixed" : "absolute",
        display: "none",
        left: s.left + "px",
        top: s.top + "px"
      });

      if (!t.inline) {
        var o = $.datepicker._get(t, "showAnim"),
            u = $.datepicker._get(t, "duration"),
            a = function a() {
          var e = t.dpDiv.find("iframe.ui-datepicker-cover");

          if (!!e.length) {
            var n = $.datepicker._getBorders(t.dpDiv);

            e.css({
              left: -n[0],
              top: -n[1],
              width: t.dpDiv.outerWidth(),
              height: t.dpDiv.outerHeight()
            });
          }
        };

        t.dpDiv.zIndex($(e).zIndex() + 1), $.datepicker._datepickerShowing = !0, $.effects && ($.effects.effect[o] || $.effects[o]) ? t.dpDiv.show(o, $.datepicker._get(t, "showOptions"), u, a) : t.dpDiv[o || "show"](o ? u : null, a), (!o || !u) && a(), t.input.is(":visible") && !t.input.is(":disabled") && t.input.focus(), $.datepicker._curInst = t;
      }
    },
    _updateDatepicker: function _updateDatepicker(e) {
      this.maxRows = 4;

      var t = $.datepicker._getBorders(e.dpDiv);

      instActive = e, e.dpDiv.empty().append(this._generateHTML(e)), this._attachHandlers(e);
      var n = e.dpDiv.find("iframe.ui-datepicker-cover");
      !n.length || n.css({
        left: -t[0],
        top: -t[1],
        width: e.dpDiv.outerWidth(),
        height: e.dpDiv.outerHeight()
      }), e.dpDiv.find("." + this._dayOverClass + " a").mouseover();

      var r = this._getNumberOfMonths(e),
          i = r[1],
          s = 17;

      e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), i > 1 && e.dpDiv.addClass("ui-datepicker-multi-" + i).css("width", s * i + "em"), e.dpDiv[(r[0] != 1 || r[1] != 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi"), e.dpDiv[(this._get(e, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), e == $.datepicker._curInst && $.datepicker._datepickerShowing && e.input && e.input.is(":visible") && !e.input.is(":disabled") && e.input[0] != document.activeElement && e.input.focus();

      if (e.yearshtml) {
        var o = e.yearshtml;
        setTimeout(function () {
          o === e.yearshtml && e.yearshtml && e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml), o = e.yearshtml = null;
        }, 0);
      }
    },
    _getBorders: function _getBorders(e) {
      var t = function t(e) {
        return {
          thin: 1,
          medium: 2,
          thick: 3
        }[e] || e;
      };

      return [parseFloat(t(e.css("border-left-width"))), parseFloat(t(e.css("border-top-width")))];
    },
    _checkOffset: function _checkOffset(e, t, n) {
      var r = e.dpDiv.outerWidth(),
          i = e.dpDiv.outerHeight(),
          s = e.input ? e.input.outerWidth() : 0,
          o = e.input ? e.input.outerHeight() : 0,
          u = document.documentElement.clientWidth + (n ? 0 : $(document).scrollLeft()),
          a = document.documentElement.clientHeight + (n ? 0 : $(document).scrollTop());
      return t.left -= this._get(e, "isRTL") ? r - s : 0, t.left -= n && t.left == e.input.offset().left ? $(document).scrollLeft() : 0, t.top -= n && t.top == e.input.offset().top + o ? $(document).scrollTop() : 0, t.left -= Math.min(t.left, t.left + r > u && u > r ? Math.abs(t.left + r - u) : 0), t.top -= Math.min(t.top, t.top + i > a && a > i ? Math.abs(i + o) : 0), t;
    },
    _findPos: function _findPos(e) {
      var t = this._getInst(e),
          n = this._get(t, "isRTL");

      while (e && (e.type == "hidden" || e.nodeType != 1 || $.expr.filters.hidden(e))) {
        e = e[n ? "previousSibling" : "nextSibling"];
      }

      var r = $(e).offset();
      return [r.left, r.top];
    },
    _hideDatepicker: function _hideDatepicker(e) {
      var t = this._curInst;
      if (!t || e && t != $.data(e, PROP_NAME)) return;

      if (this._datepickerShowing) {
        var n = this._get(t, "showAnim"),
            r = this._get(t, "duration"),
            i = function i() {
          $.datepicker._tidyDialog(t);
        };

        $.effects && ($.effects.effect[n] || $.effects[n]) ? t.dpDiv.hide(n, $.datepicker._get(t, "showOptions"), r, i) : t.dpDiv[n == "slideDown" ? "slideUp" : n == "fadeIn" ? "fadeOut" : "hide"](n ? r : null, i), n || i(), this._datepickerShowing = !1;

        var s = this._get(t, "onClose");

        s && s.apply(t.input ? t.input[0] : null, [t.input ? t.input.val() : "", t]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
          position: "absolute",
          left: "0",
          top: "-100px"
        }), $.blockUI && ($.unblockUI(), $("body").append(this.dpDiv))), this._inDialog = !1;
      }
    },
    _tidyDialog: function _tidyDialog(e) {
      e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
    },
    _checkExternalClick: function _checkExternalClick(e) {
      if (!$.datepicker._curInst) return;

      var t = $(e.target),
          n = $.datepicker._getInst(t[0]);

      (t[0].id != $.datepicker._mainDivId && t.parents("#" + $.datepicker._mainDivId).length == 0 && !t.hasClass($.datepicker.markerClassName) && !t.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && (!$.datepicker._inDialog || !$.blockUI) || t.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != n) && $.datepicker._hideDatepicker();
    },
    _adjustDate: function _adjustDate(e, t, n) {
      var r = $(e),
          i = this._getInst(r[0]);

      if (this._isDisabledDatepicker(r[0])) return;
      this._adjustInstDate(i, t + (n == "M" ? this._get(i, "showCurrentAtPos") : 0), n), this._updateDatepicker(i);
    },
    _gotoToday: function _gotoToday(e) {
      var t = $(e),
          n = this._getInst(t[0]);

      if (this._get(n, "gotoCurrent") && n.currentDay) n.selectedDay = n.currentDay, n.drawMonth = n.selectedMonth = n.currentMonth, n.drawYear = n.selectedYear = n.currentYear;else {
        var r = new Date();
        n.selectedDay = r.getDate(), n.drawMonth = n.selectedMonth = r.getMonth(), n.drawYear = n.selectedYear = r.getFullYear();
      }
      this._notifyChange(n), this._adjustDate(t);
    },
    _selectMonthYear: function _selectMonthYear(e, t, n) {
      var r = $(e),
          i = this._getInst(r[0]);

      i["selected" + (n == "M" ? "Month" : "Year")] = i["draw" + (n == "M" ? "Month" : "Year")] = parseInt(t.options[t.selectedIndex].value, 10), this._notifyChange(i), this._adjustDate(r);
    },
    _selectDay: function _selectDay(e, t, n, r) {
      var i = $(e);
      if ($(r).hasClass(this._unselectableClass) || this._isDisabledDatepicker(i[0])) return;

      var s = this._getInst(i[0]);

      s.selectedDay = s.currentDay = $("a", r).html(), s.selectedMonth = s.currentMonth = t, s.selectedYear = s.currentYear = n, this._selectDate(e, this._formatDate(s, s.currentDay, s.currentMonth, s.currentYear));
    },
    _clearDate: function _clearDate(e) {
      var t = $(e),
          n = this._getInst(t[0]);

      this._selectDate(t, "");
    },
    _selectDate: function _selectDate(e, t) {
      var n = $(e),
          r = this._getInst(n[0]);

      t = t != null ? t : this._formatDate(r), r.input && r.input.val(t), this._updateAlternate(r);

      var i = this._get(r, "onSelect");

      i ? i.apply(r.input ? r.input[0] : null, [t, r]) : r.input && r.input.trigger("change"), r.inline ? this._updateDatepicker(r) : (this._hideDatepicker(), this._lastInput = r.input[0], _typeof(r.input[0]) != "object" && r.input.focus(), this._lastInput = null);
    },
    _updateAlternate: function _updateAlternate(e) {
      var t = this._get(e, "altField");

      if (t) {
        var n = this._get(e, "altFormat") || this._get(e, "dateFormat"),
            r = this._getDate(e),
            i = this.formatDate(n, r, this._getFormatConfig(e));

        $(t).each(function () {
          $(this).val(i);
        });
      }
    },
    noWeekends: function noWeekends(e) {
      var t = e.getDay();
      return [t > 0 && t < 6, ""];
    },
    iso8601Week: function iso8601Week(e) {
      var t = new Date(e.getTime());
      t.setDate(t.getDate() + 4 - (t.getDay() || 7));
      var n = t.getTime();
      return t.setMonth(0), t.setDate(1), Math.floor(Math.round((n - t) / 864e5) / 7) + 1;
    },
    parseDate: function parseDate(e, t, n) {
      if (e == null || t == null) throw "Invalid arguments";
      t = _typeof(t) == "object" ? t.toString() : t + "";
      if (t == "") return null;
      var r = (n ? n.shortYearCutoff : null) || this._defaults.shortYearCutoff;
      r = typeof r != "string" ? r : new Date().getFullYear() % 100 + parseInt(r, 10);

      var i = (n ? n.dayNamesShort : null) || this._defaults.dayNamesShort,
          s = (n ? n.dayNames : null) || this._defaults.dayNames,
          o = (n ? n.monthNamesShort : null) || this._defaults.monthNamesShort,
          u = (n ? n.monthNames : null) || this._defaults.monthNames,
          a = -1,
          f = -1,
          l = -1,
          c = -1,
          h = !1,
          p = function p(t) {
        var n = y + 1 < e.length && e.charAt(y + 1) == t;
        return n && y++, n;
      },
          d = function d(e) {
        var n = p(e),
            r = e == "@" ? 14 : e == "!" ? 20 : e == "y" && n ? 4 : e == "o" ? 3 : 2,
            i = new RegExp("^\\d{1," + r + "}"),
            s = t.substring(g).match(i);
        if (!s) throw "Missing number at position " + g;
        return g += s[0].length, parseInt(s[0], 10);
      },
          v = function v(e, n, r) {
        var i = $.map(p(e) ? r : n, function (e, t) {
          return [[t, e]];
        }).sort(function (e, t) {
          return -(e[1].length - t[1].length);
        }),
            s = -1;
        $.each(i, function (e, n) {
          var r = n[1];
          if (t.substr(g, r.length).toLowerCase() == r.toLowerCase()) return s = n[0], g += r.length, !1;
        });
        if (s != -1) return s + 1;
        throw "Unknown name at position " + g;
      },
          m = function m() {
        if (t.charAt(g) != e.charAt(y)) throw "Unexpected literal at position " + g;
        g++;
      },
          g = 0;

      for (var y = 0; y < e.length; y++) {
        if (h) e.charAt(y) == "'" && !p("'") ? h = !1 : m();else switch (e.charAt(y)) {
          case "d":
            l = d("d");
            break;

          case "D":
            v("D", i, s);
            break;

          case "o":
            c = d("o");
            break;

          case "m":
            f = d("m");
            break;

          case "M":
            f = v("M", o, u);
            break;

          case "y":
            a = d("y");
            break;

          case "@":
            var b = new Date(d("@"));
            a = b.getFullYear(), f = b.getMonth() + 1, l = b.getDate();
            break;

          case "!":
            var b = new Date((d("!") - this._ticksTo1970) / 1e4);
            a = b.getFullYear(), f = b.getMonth() + 1, l = b.getDate();
            break;

          case "'":
            p("'") ? m() : h = !0;
            break;

          default:
            m();
        }
      }

      if (g < t.length) {
        var w = t.substr(g);
        if (!/^\s+/.test(w)) throw "Extra/unparsed characters found in date: " + w;
      }

      a == -1 ? a = new Date().getFullYear() : a < 100 && (a += new Date().getFullYear() - new Date().getFullYear() % 100 + (a <= r ? 0 : -100));

      if (c > -1) {
        f = 1, l = c;

        do {
          var E = this._getDaysInMonth(a, f - 1);

          if (l <= E) break;
          f++, l -= E;
        } while (!0);
      }

      var b = this._daylightSavingAdjust(new Date(a, f - 1, l));

      if (b.getFullYear() != a || b.getMonth() + 1 != f || b.getDate() != l) throw "Invalid date";
      return b;
    },
    ATOM: "yy-mm-dd",
    COOKIE: "D, dd M yy",
    ISO_8601: "yy-mm-dd",
    RFC_822: "D, d M y",
    RFC_850: "DD, dd-M-y",
    RFC_1036: "D, d M y",
    RFC_1123: "D, d M yy",
    RFC_2822: "D, d M yy",
    RSS: "D, d M y",
    TICKS: "!",
    TIMESTAMP: "@",
    W3C: "yy-mm-dd",
    _ticksTo1970: (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 24 * 60 * 60 * 1e7,
    formatDate: function formatDate(e, t, n) {
      if (!t) return "";

      var r = (n ? n.dayNamesShort : null) || this._defaults.dayNamesShort,
          i = (n ? n.dayNames : null) || this._defaults.dayNames,
          s = (n ? n.monthNamesShort : null) || this._defaults.monthNamesShort,
          o = (n ? n.monthNames : null) || this._defaults.monthNames,
          u = function u(t) {
        var n = h + 1 < e.length && e.charAt(h + 1) == t;
        return n && h++, n;
      },
          a = function a(e, t, n) {
        var r = "" + t;
        if (u(e)) while (r.length < n) {
          r = "0" + r;
        }
        return r;
      },
          f = function f(e, t, n, r) {
        return u(e) ? r[t] : n[t];
      },
          l = "",
          c = !1;

      if (t) for (var h = 0; h < e.length; h++) {
        if (c) e.charAt(h) == "'" && !u("'") ? c = !1 : l += e.charAt(h);else switch (e.charAt(h)) {
          case "d":
            l += a("d", t.getDate(), 2);
            break;

          case "D":
            l += f("D", t.getDay(), r, i);
            break;

          case "o":
            l += a("o", Math.round((new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() - new Date(t.getFullYear(), 0, 0).getTime()) / 864e5), 3);
            break;

          case "m":
            l += a("m", t.getMonth() + 1, 2);
            break;

          case "M":
            l += f("M", t.getMonth(), s, o);
            break;

          case "y":
            l += u("y") ? t.getFullYear() : (t.getYear() % 100 < 10 ? "0" : "") + t.getYear() % 100;
            break;

          case "@":
            l += t.getTime();
            break;

          case "!":
            l += t.getTime() * 1e4 + this._ticksTo1970;
            break;

          case "'":
            u("'") ? l += "'" : c = !0;
            break;

          default:
            l += e.charAt(h);
        }
      }
      return l;
    },
    _possibleChars: function _possibleChars(e) {
      var t = "",
          n = !1,
          r = function r(t) {
        var n = i + 1 < e.length && e.charAt(i + 1) == t;
        return n && i++, n;
      };

      for (var i = 0; i < e.length; i++) {
        if (n) e.charAt(i) == "'" && !r("'") ? n = !1 : t += e.charAt(i);else switch (e.charAt(i)) {
          case "d":
          case "m":
          case "y":
          case "@":
            t += "0123456789";
            break;

          case "D":
          case "M":
            return null;

          case "'":
            r("'") ? t += "'" : n = !0;
            break;

          default:
            t += e.charAt(i);
        }
      }

      return t;
    },
    _get: function _get(e, t) {
      return e.settings[t] !== undefined ? e.settings[t] : this._defaults[t];
    },
    _setDateFromField: function _setDateFromField(e, t) {
      if (e.input.val() == e.lastVal) return;

      var n = this._get(e, "dateFormat"),
          r = e.lastVal = e.input ? e.input.val() : null,
          i,
          s;

      i = s = this._getDefaultDate(e);

      var o = this._getFormatConfig(e);

      try {
        i = this.parseDate(n, r, o) || s;
      } catch (u) {
        this.log(u), r = t ? "" : r;
      }

      e.selectedDay = i.getDate(), e.drawMonth = e.selectedMonth = i.getMonth(), e.drawYear = e.selectedYear = i.getFullYear(), e.currentDay = r ? i.getDate() : 0, e.currentMonth = r ? i.getMonth() : 0, e.currentYear = r ? i.getFullYear() : 0, this._adjustInstDate(e);
    },
    _getDefaultDate: function _getDefaultDate(e) {
      return this._restrictMinMax(e, this._determineDate(e, this._get(e, "defaultDate"), new Date()));
    },
    _determineDate: function _determineDate(e, t, n) {
      var r = function r(e) {
        var t = new Date();
        return t.setDate(t.getDate() + e), t;
      },
          i = function i(t) {
        try {
          return $.datepicker.parseDate($.datepicker._get(e, "dateFormat"), t, $.datepicker._getFormatConfig(e));
        } catch (n) {}

        var r = (t.toLowerCase().match(/^c/) ? $.datepicker._getDate(e) : null) || new Date(),
            i = r.getFullYear(),
            s = r.getMonth(),
            o = r.getDate(),
            u = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
            a = u.exec(t);

        while (a) {
          switch (a[2] || "d") {
            case "d":
            case "D":
              o += parseInt(a[1], 10);
              break;

            case "w":
            case "W":
              o += parseInt(a[1], 10) * 7;
              break;

            case "m":
            case "M":
              s += parseInt(a[1], 10), o = Math.min(o, $.datepicker._getDaysInMonth(i, s));
              break;

            case "y":
            case "Y":
              i += parseInt(a[1], 10), o = Math.min(o, $.datepicker._getDaysInMonth(i, s));
          }

          a = u.exec(t);
        }

        return new Date(i, s, o);
      },
          s = t == null || t === "" ? n : typeof t == "string" ? i(t) : typeof t == "number" ? isNaN(t) ? n : r(t) : new Date(t.getTime());

      return s = s && s.toString() == "Invalid Date" ? n : s, s && (s.setHours(0), s.setMinutes(0), s.setSeconds(0), s.setMilliseconds(0)), this._daylightSavingAdjust(s);
    },
    _daylightSavingAdjust: function _daylightSavingAdjust(e) {
      return e ? (e.setHours(e.getHours() > 12 ? e.getHours() + 2 : 0), e) : null;
    },
    _setDate: function _setDate(e, t, n) {
      var r = !t,
          i = e.selectedMonth,
          s = e.selectedYear,
          o = this._restrictMinMax(e, this._determineDate(e, t, new Date()));

      e.selectedDay = e.currentDay = o.getDate(), e.drawMonth = e.selectedMonth = e.currentMonth = o.getMonth(), e.drawYear = e.selectedYear = e.currentYear = o.getFullYear(), (i != e.selectedMonth || s != e.selectedYear) && !n && this._notifyChange(e), this._adjustInstDate(e), e.input && e.input.val(r ? "" : this._formatDate(e));
    },
    _getDate: function _getDate(e) {
      var t = !e.currentYear || e.input && e.input.val() == "" ? null : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay));
      return t;
    },
    _attachHandlers: function _attachHandlers(e) {
      var t = this._get(e, "stepMonths"),
          n = "#" + e.id.replace(/\\\\/g, "\\");

      e.dpDiv.find("[data-handler]").map(function () {
        var e = {
          prev: function prev() {
            window["DP_jQuery_" + dpuuid].datepicker._adjustDate(n, -t, "M");
          },
          next: function next() {
            window["DP_jQuery_" + dpuuid].datepicker._adjustDate(n, +t, "M");
          },
          hide: function hide() {
            window["DP_jQuery_" + dpuuid].datepicker._hideDatepicker();
          },
          today: function today() {
            window["DP_jQuery_" + dpuuid].datepicker._gotoToday(n);
          },
          selectDay: function selectDay() {
            return window["DP_jQuery_" + dpuuid].datepicker._selectDay(n, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1;
          },
          selectMonth: function selectMonth() {
            return window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(n, this, "M"), !1;
          },
          selectYear: function selectYear() {
            return window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(n, this, "Y"), !1;
          }
        };
        $(this).bind(this.getAttribute("data-event"), e[this.getAttribute("data-handler")]);
      });
    },
    _generateHTML: function _generateHTML(e) {
      var t = new Date();
      t = this._daylightSavingAdjust(new Date(t.getFullYear(), t.getMonth(), t.getDate()));

      var n = this._get(e, "isRTL"),
          r = this._get(e, "showButtonPanel"),
          i = this._get(e, "hideIfNoPrevNext"),
          s = this._get(e, "navigationAsDateFormat"),
          o = this._getNumberOfMonths(e),
          u = this._get(e, "showCurrentAtPos"),
          a = this._get(e, "stepMonths"),
          f = o[0] != 1 || o[1] != 1,
          l = this._daylightSavingAdjust(e.currentDay ? new Date(e.currentYear, e.currentMonth, e.currentDay) : new Date(9999, 9, 9)),
          c = this._getMinMaxDate(e, "min"),
          h = this._getMinMaxDate(e, "max"),
          p = e.drawMonth - u,
          d = e.drawYear;

      p < 0 && (p += 12, d--);

      if (h) {
        var v = this._daylightSavingAdjust(new Date(h.getFullYear(), h.getMonth() - o[0] * o[1] + 1, h.getDate()));

        v = c && v < c ? c : v;

        while (this._daylightSavingAdjust(new Date(d, p, 1)) > v) {
          p--, p < 0 && (p = 11, d--);
        }
      }

      e.drawMonth = p, e.drawYear = d;

      var m = this._get(e, "prevText");

      m = s ? this.formatDate(m, this._daylightSavingAdjust(new Date(d, p - a, 1)), this._getFormatConfig(e)) : m;

      var g = this._canAdjustMonth(e, -1, d, p) ? '<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click" title="' + m + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "e" : "w") + '">' + m + "</span></a>" : i ? "" : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="' + m + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "e" : "w") + '">' + m + "</span></a>",
          y = this._get(e, "nextText");

      y = s ? this.formatDate(y, this._daylightSavingAdjust(new Date(d, p + a, 1)), this._getFormatConfig(e)) : y;

      var b = this._canAdjustMonth(e, 1, d, p) ? '<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click" title="' + y + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "w" : "e") + '">' + y + "</span></a>" : i ? "" : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="' + y + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "w" : "e") + '">' + y + "</span></a>",
          w = this._get(e, "currentText"),
          E = this._get(e, "gotoCurrent") && e.currentDay ? l : t;

      w = s ? this.formatDate(w, E, this._getFormatConfig(e)) : w;
      var S = e.inline ? "" : '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">' + this._get(e, "closeText") + "</button>",
          x = r ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (n ? S : "") + (this._isInRange(e, E) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click">' + w + "</button>" : "") + (n ? "" : S) + "</div>" : "",
          T = parseInt(this._get(e, "firstDay"), 10);
      T = isNaN(T) ? 0 : T;

      var N = this._get(e, "showWeek"),
          C = this._get(e, "dayNames"),
          k = this._get(e, "dayNamesShort"),
          L = this._get(e, "dayNamesMin"),
          A = this._get(e, "monthNames"),
          O = this._get(e, "monthNamesShort"),
          M = this._get(e, "beforeShowDay"),
          _ = this._get(e, "showOtherMonths"),
          D = this._get(e, "selectOtherMonths"),
          P = this._get(e, "calculateWeek") || this.iso8601Week,
          H = this._getDefaultDate(e),
          B = "";

      for (var j = 0; j < o[0]; j++) {
        var F = "";
        this.maxRows = 4;

        for (var I = 0; I < o[1]; I++) {
          var q = this._daylightSavingAdjust(new Date(d, p, e.selectedDay)),
              R = " ui-corner-all",
              U = "";

          if (f) {
            U += '<div class="ui-datepicker-group';
            if (o[1] > 1) switch (I) {
              case 0:
                U += " ui-datepicker-group-first", R = " ui-corner-" + (n ? "right" : "left");
                break;

              case o[1] - 1:
                U += " ui-datepicker-group-last", R = " ui-corner-" + (n ? "left" : "right");
                break;

              default:
                U += " ui-datepicker-group-middle", R = "";
            }
            U += '">';
          }

          U += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + R + '">' + (/all|left/.test(R) && j == 0 ? n ? b : g : "") + (/all|right/.test(R) && j == 0 ? n ? g : b : "") + this._generateMonthYearHeader(e, p, d, c, h, j > 0 || I > 0, A, O) + '</div><table class="ui-datepicker-calendar"><thead>' + "<tr>";
          var z = N ? '<th class="ui-datepicker-week-col">' + this._get(e, "weekHeader") + "</th>" : "";

          for (var W = 0; W < 7; W++) {
            var X = (W + T) % 7;
            z += "<th" + ((W + T + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : "") + ">" + '<span title="' + C[X] + '">' + L[X] + "</span></th>";
          }

          U += z + "</tr></thead><tbody>";

          var V = this._getDaysInMonth(d, p);

          d == e.selectedYear && p == e.selectedMonth && (e.selectedDay = Math.min(e.selectedDay, V));
          var J = (this._getFirstDayOfMonth(d, p) - T + 7) % 7,
              K = Math.ceil((J + V) / 7),
              Q = f ? this.maxRows > K ? this.maxRows : K : K;
          this.maxRows = Q;

          var G = this._daylightSavingAdjust(new Date(d, p, 1 - J));

          for (var Y = 0; Y < Q; Y++) {
            U += "<tr>";
            var Z = N ? '<td class="ui-datepicker-week-col">' + this._get(e, "calculateWeek")(G) + "</td>" : "";

            for (var W = 0; W < 7; W++) {
              var et = M ? M.apply(e.input ? e.input[0] : null, [G]) : [!0, ""],
                  tt = G.getMonth() != p,
                  nt = tt && !D || !et[0] || c && G < c || h && G > h;
              Z += '<td class="' + ((W + T + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (tt ? " ui-datepicker-other-month" : "") + (G.getTime() == q.getTime() && p == e.selectedMonth && e._keyEvent || H.getTime() == G.getTime() && H.getTime() == q.getTime() ? " " + this._dayOverClass : "") + (nt ? " " + this._unselectableClass + " ui-state-disabled" : "") + (tt && !_ ? "" : " " + et[1] + (G.getTime() == l.getTime() ? " " + this._currentClass : "") + (G.getTime() == t.getTime() ? " ui-datepicker-today" : "")) + '"' + ((!tt || _) && et[2] ? ' title="' + et[2] + '"' : "") + (nt ? "" : ' data-handler="selectDay" data-event="click" data-month="' + G.getMonth() + '" data-year="' + G.getFullYear() + '"') + ">" + (tt && !_ ? "&#xa0;" : nt ? '<span class="ui-state-default">' + G.getDate() + "</span>" : '<a class="ui-state-default' + (G.getTime() == t.getTime() ? " ui-state-highlight" : "") + (G.getTime() == l.getTime() ? " ui-state-active" : "") + (tt ? " ui-priority-secondary" : "") + '" href="#">' + G.getDate() + "</a>") + "</td>", G.setDate(G.getDate() + 1), G = this._daylightSavingAdjust(G);
            }

            U += Z + "</tr>";
          }

          p++, p > 11 && (p = 0, d++), U += "</tbody></table>" + (f ? "</div>" + (o[0] > 0 && I == o[1] - 1 ? '<div class="ui-datepicker-row-break"></div>' : "") : ""), F += U;
        }

        B += F;
      }

      return B += x + ($.ui.ie6 && !e.inline ? '<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : ""), e._keyEvent = !1, B;
    },
    _generateMonthYearHeader: function _generateMonthYearHeader(e, t, n, r, i, s, o, u) {
      var a = this._get(e, "changeMonth"),
          f = this._get(e, "changeYear"),
          l = this._get(e, "showMonthAfterYear"),
          c = '<div class="ui-datepicker-title">',
          h = "";

      if (s || !a) h += '<span class="ui-datepicker-month">' + o[t] + "</span>";else {
        var p = r && r.getFullYear() == n,
            d = i && i.getFullYear() == n;
        h += '<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';

        for (var v = 0; v < 12; v++) {
          (!p || v >= r.getMonth()) && (!d || v <= i.getMonth()) && (h += '<option value="' + v + '"' + (v == t ? ' selected="selected"' : "") + ">" + u[v] + "</option>");
        }

        h += "</select>";
      }
      l || (c += h + (s || !a || !f ? "&#xa0;" : ""));

      if (!e.yearshtml) {
        e.yearshtml = "";
        if (s || !f) c += '<span class="ui-datepicker-year">' + n + "</span>";else {
          var m = this._get(e, "yearRange").split(":"),
              g = new Date().getFullYear(),
              y = function y(e) {
            var t = e.match(/c[+-].*/) ? n + parseInt(e.substring(1), 10) : e.match(/[+-].*/) ? g + parseInt(e, 10) : parseInt(e, 10);
            return isNaN(t) ? g : t;
          },
              b = y(m[0]),
              w = Math.max(b, y(m[1] || ""));

          b = r ? Math.max(b, r.getFullYear()) : b, w = i ? Math.min(w, i.getFullYear()) : w, e.yearshtml += '<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';

          for (; b <= w; b++) {
            e.yearshtml += '<option value="' + b + '"' + (b == n ? ' selected="selected"' : "") + ">" + b + "</option>";
          }

          e.yearshtml += "</select>", c += e.yearshtml, e.yearshtml = null;
        }
      }

      return c += this._get(e, "yearSuffix"), l && (c += (s || !a || !f ? "&#xa0;" : "") + h), c += "</div>", c;
    },
    _adjustInstDate: function _adjustInstDate(e, t, n) {
      var r = e.drawYear + (n == "Y" ? t : 0),
          i = e.drawMonth + (n == "M" ? t : 0),
          s = Math.min(e.selectedDay, this._getDaysInMonth(r, i)) + (n == "D" ? t : 0),
          o = this._restrictMinMax(e, this._daylightSavingAdjust(new Date(r, i, s)));

      e.selectedDay = o.getDate(), e.drawMonth = e.selectedMonth = o.getMonth(), e.drawYear = e.selectedYear = o.getFullYear(), (n == "M" || n == "Y") && this._notifyChange(e);
    },
    _restrictMinMax: function _restrictMinMax(e, t) {
      var n = this._getMinMaxDate(e, "min"),
          r = this._getMinMaxDate(e, "max"),
          i = n && t < n ? n : t;

      return i = r && i > r ? r : i, i;
    },
    _notifyChange: function _notifyChange(e) {
      var t = this._get(e, "onChangeMonthYear");

      t && t.apply(e.input ? e.input[0] : null, [e.selectedYear, e.selectedMonth + 1, e]);
    },
    _getNumberOfMonths: function _getNumberOfMonths(e) {
      var t = this._get(e, "numberOfMonths");

      return t == null ? [1, 1] : typeof t == "number" ? [1, t] : t;
    },
    _getMinMaxDate: function _getMinMaxDate(e, t) {
      return this._determineDate(e, this._get(e, t + "Date"), null);
    },
    _getDaysInMonth: function _getDaysInMonth(e, t) {
      return 32 - this._daylightSavingAdjust(new Date(e, t, 32)).getDate();
    },
    _getFirstDayOfMonth: function _getFirstDayOfMonth(e, t) {
      return new Date(e, t, 1).getDay();
    },
    _canAdjustMonth: function _canAdjustMonth(e, t, n, r) {
      var i = this._getNumberOfMonths(e),
          s = this._daylightSavingAdjust(new Date(n, r + (t < 0 ? t : i[0] * i[1]), 1));

      return t < 0 && s.setDate(this._getDaysInMonth(s.getFullYear(), s.getMonth())), this._isInRange(e, s);
    },
    _isInRange: function _isInRange(e, t) {
      var n = this._getMinMaxDate(e, "min"),
          r = this._getMinMaxDate(e, "max");

      return (!n || t.getTime() >= n.getTime()) && (!r || t.getTime() <= r.getTime());
    },
    _getFormatConfig: function _getFormatConfig(e) {
      var t = this._get(e, "shortYearCutoff");

      return t = typeof t != "string" ? t : new Date().getFullYear() % 100 + parseInt(t, 10), {
        shortYearCutoff: t,
        dayNamesShort: this._get(e, "dayNamesShort"),
        dayNames: this._get(e, "dayNames"),
        monthNamesShort: this._get(e, "monthNamesShort"),
        monthNames: this._get(e, "monthNames")
      };
    },
    _formatDate: function _formatDate(e, t, n, r) {
      t || (e.currentDay = e.selectedDay, e.currentMonth = e.selectedMonth, e.currentYear = e.selectedYear);
      var i = t ? _typeof(t) == "object" ? t : this._daylightSavingAdjust(new Date(r, n, t)) : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay));
      return this.formatDate(this._get(e, "dateFormat"), i, this._getFormatConfig(e));
    }
  }), $.fn.datepicker = function (e) {
    if (!this.length) return this;
    $.datepicker.initialized || ($(document).mousedown($.datepicker._checkExternalClick).find(document.body).append($.datepicker.dpDiv), $.datepicker.initialized = !0);
    var t = Array.prototype.slice.call(arguments, 1);
    return typeof e != "string" || e != "isDisabled" && e != "getDate" && e != "widget" ? e == "option" && arguments.length == 2 && typeof arguments[1] == "string" ? $.datepicker["_" + e + "Datepicker"].apply($.datepicker, [this[0]].concat(t)) : this.each(function () {
      typeof e == "string" ? $.datepicker["_" + e + "Datepicker"].apply($.datepicker, [this].concat(t)) : $.datepicker._attachDatepicker(this, e);
    }) : $.datepicker["_" + e + "Datepicker"].apply($.datepicker, [this[0]].concat(t));
  }, $.datepicker = new Datepicker(), $.datepicker.initialized = !1, $.datepicker.uuid = new Date().getTime(), $.datepicker.version = "1.9.2", window["DP_jQuery_" + dpuuid] = $;
}(jQuery), function (e, t) {
  var n = "ui-dialog ui-widget ui-widget-content ui-corner-all ",
      r = {
    buttons: !0,
    height: !0,
    maxHeight: !0,
    maxWidth: !0,
    minHeight: !0,
    minWidth: !0,
    width: !0
  },
      i = {
    maxHeight: !0,
    maxWidth: !0,
    minHeight: !0,
    minWidth: !0
  };
  e.widget("ui.dialog", {
    version: "1.9.2",
    options: {
      autoOpen: !0,
      buttons: {},
      closeOnEscape: !0,
      closeText: "close",
      dialogClass: "",
      draggable: !0,
      hide: null,
      height: "auto",
      maxHeight: !1,
      maxWidth: !1,
      minHeight: 150,
      minWidth: 150,
      modal: !1,
      position: {
        my: "center",
        at: "center",
        of: window,
        collision: "fit",
        using: function using(t) {
          var n = e(this).css(t).offset().top;
          n < 0 && e(this).css("top", t.top - n);
        }
      },
      resizable: !0,
      show: null,
      stack: !0,
      title: "",
      width: 300,
      zIndex: 1e3
    },
    _create: function _create() {
      this.originalTitle = this.element.attr("title"), typeof this.originalTitle != "string" && (this.originalTitle = ""), this.oldPosition = {
        parent: this.element.parent(),
        index: this.element.parent().children().index(this.element)
      }, this.options.title = this.options.title || this.originalTitle;
      var t = this,
          r = this.options,
          i = r.title || "&#160;",
          s,
          o,
          u,
          a,
          f;
      s = (this.uiDialog = e("<div>")).addClass(n + r.dialogClass).css({
        display: "none",
        outline: 0,
        zIndex: r.zIndex
      }).attr("tabIndex", -1).keydown(function (n) {
        r.closeOnEscape && !n.isDefaultPrevented() && n.keyCode && n.keyCode === e.ui.keyCode.ESCAPE && (t.close(n), n.preventDefault());
      }).mousedown(function (e) {
        t.moveToTop(!1, e);
      }).appendTo("body"), this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(s), o = (this.uiDialogTitlebar = e("<div>")).addClass("ui-dialog-titlebar  ui-widget-header  ui-corner-all  ui-helper-clearfix").bind("mousedown", function () {
        s.focus();
      }).prependTo(s), u = e("<a href='#'></a>").addClass("ui-dialog-titlebar-close  ui-corner-all").attr("role", "button").click(function (e) {
        e.preventDefault(), t.close(e);
      }).appendTo(o), (this.uiDialogTitlebarCloseText = e("<span>")).addClass("ui-icon ui-icon-closethick").text(r.closeText).appendTo(u), a = e("<span>").uniqueId().addClass("ui-dialog-title").html(i).prependTo(o), f = (this.uiDialogButtonPane = e("<div>")).addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"), (this.uiButtonSet = e("<div>")).addClass("ui-dialog-buttonset").appendTo(f), s.attr({
        role: "dialog",
        "aria-labelledby": a.attr("id")
      }), o.find("*").add(o).disableSelection(), this._hoverable(u), this._focusable(u), r.draggable && e.fn.draggable && this._makeDraggable(), r.resizable && e.fn.resizable && this._makeResizable(), this._createButtons(r.buttons), this._isOpen = !1, e.fn.bgiframe && s.bgiframe(), this._on(s, {
        keydown: function keydown(t) {
          if (!r.modal || t.keyCode !== e.ui.keyCode.TAB) return;
          var n = e(":tabbable", s),
              i = n.filter(":first"),
              o = n.filter(":last");
          if (t.target === o[0] && !t.shiftKey) return i.focus(1), !1;
          if (t.target === i[0] && t.shiftKey) return o.focus(1), !1;
        }
      });
    },
    _init: function _init() {
      this.options.autoOpen && this.open();
    },
    _destroy: function _destroy() {
      var e,
          t = this.oldPosition;
      this.overlay && this.overlay.destroy(), this.uiDialog.hide(), this.element.removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body"), this.uiDialog.remove(), this.originalTitle && this.element.attr("title", this.originalTitle), e = t.parent.children().eq(t.index), e.length && e[0] !== this.element[0] ? e.before(this.element) : t.parent.append(this.element);
    },
    widget: function widget() {
      return this.uiDialog;
    },
    close: function close(t) {
      var n = this,
          r,
          i;
      if (!this._isOpen) return;
      if (!1 === this._trigger("beforeClose", t)) return;
      return this._isOpen = !1, this.overlay && this.overlay.destroy(), this.options.hide ? this._hide(this.uiDialog, this.options.hide, function () {
        n._trigger("close", t);
      }) : (this.uiDialog.hide(), this._trigger("close", t)), e.ui.dialog.overlay.resize(), this.options.modal && (r = 0, e(".ui-dialog").each(function () {
        this !== n.uiDialog[0] && (i = e(this).css("z-index"), isNaN(i) || (r = Math.max(r, i)));
      }), e.ui.dialog.maxZ = r), this;
    },
    isOpen: function isOpen() {
      return this._isOpen;
    },
    moveToTop: function moveToTop(t, n) {
      var r = this.options,
          i;
      return r.modal && !t || !r.stack && !r.modal ? this._trigger("focus", n) : (r.zIndex > e.ui.dialog.maxZ && (e.ui.dialog.maxZ = r.zIndex), this.overlay && (e.ui.dialog.maxZ += 1, e.ui.dialog.overlay.maxZ = e.ui.dialog.maxZ, this.overlay.$el.css("z-index", e.ui.dialog.overlay.maxZ)), i = {
        scrollTop: this.element.scrollTop(),
        scrollLeft: this.element.scrollLeft()
      }, e.ui.dialog.maxZ += 1, this.uiDialog.css("z-index", e.ui.dialog.maxZ), this.element.attr(i), this._trigger("focus", n), this);
    },
    open: function open() {
      if (this._isOpen) return;
      var t,
          n = this.options,
          r = this.uiDialog;
      return this._size(), this._position(n.position), r.show(n.show), this.overlay = n.modal ? new e.ui.dialog.overlay(this) : null, this.moveToTop(!0), t = this.element.find(":tabbable"), t.length || (t = this.uiDialogButtonPane.find(":tabbable"), t.length || (t = r)), t.eq(0).focus(), this._isOpen = !0, this._trigger("open"), this;
    },
    _createButtons: function _createButtons(t) {
      var n = this,
          r = !1;
      this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), _typeof(t) == "object" && t !== null && e.each(t, function () {
        return !(r = !0);
      }), r ? (e.each(t, function (t, r) {
        var i, s;
        r = e.isFunction(r) ? {
          click: r,
          text: t
        } : r, r = e.extend({
          type: "button"
        }, r), s = r.click, r.click = function () {
          s.apply(n.element[0], arguments);
        }, i = e("<button></button>", r).appendTo(n.uiButtonSet), e.fn.button && i.button();
      }), this.uiDialog.addClass("ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog)) : this.uiDialog.removeClass("ui-dialog-buttons");
    },
    _makeDraggable: function _makeDraggable() {
      function r(e) {
        return {
          position: e.position,
          offset: e.offset
        };
      }

      var t = this,
          n = this.options;
      this.uiDialog.draggable({
        cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
        handle: ".ui-dialog-titlebar",
        containment: "document",
        start: function start(n, i) {
          e(this).addClass("ui-dialog-dragging"), t._trigger("dragStart", n, r(i));
        },
        drag: function drag(e, n) {
          t._trigger("drag", e, r(n));
        },
        stop: function stop(i, s) {
          n.position = [s.position.left - t.document.scrollLeft(), s.position.top - t.document.scrollTop()], e(this).removeClass("ui-dialog-dragging"), t._trigger("dragStop", i, r(s)), e.ui.dialog.overlay.resize();
        }
      });
    },
    _makeResizable: function _makeResizable(n) {
      function u(e) {
        return {
          originalPosition: e.originalPosition,
          originalSize: e.originalSize,
          position: e.position,
          size: e.size
        };
      }

      n = n === t ? this.options.resizable : n;
      var r = this,
          i = this.options,
          s = this.uiDialog.css("position"),
          o = typeof n == "string" ? n : "n,e,s,w,se,sw,ne,nw";
      this.uiDialog.resizable({
        cancel: ".ui-dialog-content",
        containment: "document",
        alsoResize: this.element,
        maxWidth: i.maxWidth,
        maxHeight: i.maxHeight,
        minWidth: i.minWidth,
        minHeight: this._minHeight(),
        handles: o,
        start: function start(t, n) {
          e(this).addClass("ui-dialog-resizing"), r._trigger("resizeStart", t, u(n));
        },
        resize: function resize(e, t) {
          r._trigger("resize", e, u(t));
        },
        stop: function stop(t, n) {
          e(this).removeClass("ui-dialog-resizing"), i.height = e(this).height(), i.width = e(this).width(), r._trigger("resizeStop", t, u(n)), e.ui.dialog.overlay.resize();
        }
      }).css("position", s).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se");
    },
    _minHeight: function _minHeight() {
      var e = this.options;
      return e.height === "auto" ? e.minHeight : Math.min(e.minHeight, e.height);
    },
    _position: function _position(t) {
      var n = [],
          r = [0, 0],
          i;

      if (t) {
        if (typeof t == "string" || _typeof(t) == "object" && "0" in t) n = t.split ? t.split(" ") : [t[0], t[1]], n.length === 1 && (n[1] = n[0]), e.each(["left", "top"], function (e, t) {
          +n[e] === n[e] && (r[e] = n[e], n[e] = t);
        }), t = {
          my: n[0] + (r[0] < 0 ? r[0] : "+" + r[0]) + " " + n[1] + (r[1] < 0 ? r[1] : "+" + r[1]),
          at: n.join(" ")
        };
        t = e.extend({}, e.ui.dialog.prototype.options.position, t);
      } else t = e.ui.dialog.prototype.options.position;

      i = this.uiDialog.is(":visible"), i || this.uiDialog.show(), this.uiDialog.position(t), i || this.uiDialog.hide();
    },
    _setOptions: function _setOptions(t) {
      var n = this,
          s = {},
          o = !1;
      e.each(t, function (e, t) {
        n._setOption(e, t), e in r && (o = !0), e in i && (s[e] = t);
      }), o && this._size(), this.uiDialog.is(":data(resizable)") && this.uiDialog.resizable("option", s);
    },
    _setOption: function _setOption(t, r) {
      var i,
          s,
          o = this.uiDialog;

      switch (t) {
        case "buttons":
          this._createButtons(r);

          break;

        case "closeText":
          this.uiDialogTitlebarCloseText.text("" + r);
          break;

        case "dialogClass":
          o.removeClass(this.options.dialogClass).addClass(n + r);
          break;

        case "disabled":
          r ? o.addClass("ui-dialog-disabled") : o.removeClass("ui-dialog-disabled");
          break;

        case "draggable":
          i = o.is(":data(draggable)"), i && !r && o.draggable("destroy"), !i && r && this._makeDraggable();
          break;

        case "position":
          this._position(r);

          break;

        case "resizable":
          s = o.is(":data(resizable)"), s && !r && o.resizable("destroy"), s && typeof r == "string" && o.resizable("option", "handles", r), !s && r !== !1 && this._makeResizable(r);
          break;

        case "title":
          e(".ui-dialog-title", this.uiDialogTitlebar).html("" + (r || "&#160;"));
      }

      this._super(t, r);
    },
    _size: function _size() {
      var t,
          n,
          r,
          i = this.options,
          s = this.uiDialog.is(":visible");
      this.element.show().css({
        width: "auto",
        minHeight: 0,
        height: 0
      }), i.minWidth > i.width && (i.width = i.minWidth), t = this.uiDialog.css({
        height: "auto",
        width: i.width
      }).outerHeight(), n = Math.max(0, i.minHeight - t), i.height === "auto" ? e.support.minHeight ? this.element.css({
        minHeight: n,
        height: "auto"
      }) : (this.uiDialog.show(), r = this.element.css("height", "auto").height(), s || this.uiDialog.hide(), this.element.height(Math.max(r, n))) : this.element.height(Math.max(i.height - t, 0)), this.uiDialog.is(":data(resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight());
    }
  }), e.extend(e.ui.dialog, {
    uuid: 0,
    maxZ: 0,
    getTitleId: function getTitleId(e) {
      var t = e.attr("id");
      return t || (this.uuid += 1, t = this.uuid), "ui-dialog-title-" + t;
    },
    overlay: function overlay(t) {
      this.$el = e.ui.dialog.overlay.create(t);
    }
  }), e.extend(e.ui.dialog.overlay, {
    instances: [],
    oldInstances: [],
    maxZ: 0,
    events: e.map("focus,mousedown,mouseup,keydown,keypress,click".split(","), function (e) {
      return e + ".dialog-overlay";
    }).join(" "),
    create: function create(t) {
      this.instances.length === 0 && (setTimeout(function () {
        e.ui.dialog.overlay.instances.length && e(document).bind(e.ui.dialog.overlay.events, function (t) {
          if (e(t.target).zIndex() < e.ui.dialog.overlay.maxZ) return !1;
        });
      }, 1), e(window).bind("resize.dialog-overlay", e.ui.dialog.overlay.resize));
      var n = this.oldInstances.pop() || e("<div>").addClass("ui-widget-overlay");
      return e(document).bind("keydown.dialog-overlay", function (r) {
        var i = e.ui.dialog.overlay.instances;
        i.length !== 0 && i[i.length - 1] === n && t.options.closeOnEscape && !r.isDefaultPrevented() && r.keyCode && r.keyCode === e.ui.keyCode.ESCAPE && (t.close(r), r.preventDefault());
      }), n.appendTo(document.body).css({
        width: this.width(),
        height: this.height()
      }), e.fn.bgiframe && n.bgiframe(), this.instances.push(n), n;
    },
    destroy: function destroy(t) {
      var n = e.inArray(t, this.instances),
          r = 0;
      n !== -1 && this.oldInstances.push(this.instances.splice(n, 1)[0]), this.instances.length === 0 && e([document, window]).unbind(".dialog-overlay"), t.height(0).width(0).remove(), e.each(this.instances, function () {
        r = Math.max(r, this.css("z-index"));
      }), this.maxZ = r;
    },
    height: function height() {
      var t, n;
      return e.ui.ie ? (t = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight), n = Math.max(document.documentElement.offsetHeight, document.body.offsetHeight), t < n ? e(window).height() + "px" : t + "px") : e(document).height() + "px";
    },
    width: function width() {
      var t, n;
      return e.ui.ie ? (t = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth), n = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth), t < n ? e(window).width() + "px" : t + "px") : e(document).width() + "px";
    },
    resize: function resize() {
      var t = e([]);
      e.each(e.ui.dialog.overlay.instances, function () {
        t = t.add(this);
      }), t.css({
        width: 0,
        height: 0
      }).css({
        width: e.ui.dialog.overlay.width(),
        height: e.ui.dialog.overlay.height()
      });
    }
  }), e.extend(e.ui.dialog.overlay.prototype, {
    destroy: function destroy() {
      e.ui.dialog.overlay.destroy(this.$el);
    }
  });
}(jQuery), function (e, t) {
  var n = /up|down|vertical/,
      r = /up|left|vertical|horizontal/;

  e.effects.effect.blind = function (t, i) {
    var s = e(this),
        o = ["position", "top", "bottom", "left", "right", "height", "width"],
        u = e.effects.setMode(s, t.mode || "hide"),
        a = t.direction || "up",
        f = n.test(a),
        l = f ? "height" : "width",
        c = f ? "top" : "left",
        h = r.test(a),
        p = {},
        d = u === "show",
        v,
        m,
        g;
    s.parent().is(".ui-effects-wrapper") ? e.effects.save(s.parent(), o) : e.effects.save(s, o), s.show(), v = e.effects.createWrapper(s).css({
      overflow: "hidden"
    }), m = v[l](), g = parseFloat(v.css(c)) || 0, p[l] = d ? m : 0, h || (s.css(f ? "bottom" : "right", 0).css(f ? "top" : "left", "auto").css({
      position: "absolute"
    }), p[c] = d ? g : m + g), d && (v.css(l, 0), h || v.css(c, g + m)), v.animate(p, {
      duration: t.duration,
      easing: t.easing,
      queue: !1,
      complete: function complete() {
        u === "hide" && s.hide(), e.effects.restore(s, o), e.effects.removeWrapper(s), i();
      }
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.bounce = function (t, n) {
    var r = e(this),
        i = ["position", "top", "bottom", "left", "right", "height", "width"],
        s = e.effects.setMode(r, t.mode || "effect"),
        o = s === "hide",
        u = s === "show",
        a = t.direction || "up",
        f = t.distance,
        l = t.times || 5,
        c = l * 2 + (u || o ? 1 : 0),
        h = t.duration / c,
        p = t.easing,
        d = a === "up" || a === "down" ? "top" : "left",
        v = a === "up" || a === "left",
        m,
        g,
        y,
        b = r.queue(),
        w = b.length;
    (u || o) && i.push("opacity"), e.effects.save(r, i), r.show(), e.effects.createWrapper(r), f || (f = r[d === "top" ? "outerHeight" : "outerWidth"]() / 3), u && (y = {
      opacity: 1
    }, y[d] = 0, r.css("opacity", 0).css(d, v ? -f * 2 : f * 2).animate(y, h, p)), o && (f /= Math.pow(2, l - 1)), y = {}, y[d] = 0;

    for (m = 0; m < l; m++) {
      g = {}, g[d] = (v ? "-=" : "+=") + f, r.animate(g, h, p).animate(y, h, p), f = o ? f * 2 : f / 2;
    }

    o && (g = {
      opacity: 0
    }, g[d] = (v ? "-=" : "+=") + f, r.animate(g, h, p)), r.queue(function () {
      o && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n();
    }), w > 1 && b.splice.apply(b, [1, 0].concat(b.splice(w, c + 1))), r.dequeue();
  };
}(jQuery), function (e, t) {
  e.effects.effect.clip = function (t, n) {
    var r = e(this),
        i = ["position", "top", "bottom", "left", "right", "height", "width"],
        s = e.effects.setMode(r, t.mode || "hide"),
        o = s === "show",
        u = t.direction || "vertical",
        a = u === "vertical",
        f = a ? "height" : "width",
        l = a ? "top" : "left",
        c = {},
        h,
        p,
        d;
    e.effects.save(r, i), r.show(), h = e.effects.createWrapper(r).css({
      overflow: "hidden"
    }), p = r[0].tagName === "IMG" ? h : r, d = p[f](), o && (p.css(f, 0), p.css(l, d / 2)), c[f] = o ? d : 0, c[l] = o ? 0 : d / 2, p.animate(c, {
      queue: !1,
      duration: t.duration,
      easing: t.easing,
      complete: function complete() {
        o || r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n();
      }
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.drop = function (t, n) {
    var r = e(this),
        i = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
        s = e.effects.setMode(r, t.mode || "hide"),
        o = s === "show",
        u = t.direction || "left",
        a = u === "up" || u === "down" ? "top" : "left",
        f = u === "up" || u === "left" ? "pos" : "neg",
        l = {
      opacity: o ? 1 : 0
    },
        c;
    e.effects.save(r, i), r.show(), e.effects.createWrapper(r), c = t.distance || r[a === "top" ? "outerHeight" : "outerWidth"](!0) / 2, o && r.css("opacity", 0).css(a, f === "pos" ? -c : c), l[a] = (o ? f === "pos" ? "+=" : "-=" : f === "pos" ? "-=" : "+=") + c, r.animate(l, {
      queue: !1,
      duration: t.duration,
      easing: t.easing,
      complete: function complete() {
        s === "hide" && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n();
      }
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.explode = function (t, n) {
    function y() {
      c.push(this), c.length === r * i && b();
    }

    function b() {
      s.css({
        visibility: "visible"
      }), e(c).remove(), u || s.hide(), n();
    }

    var r = t.pieces ? Math.round(Math.sqrt(t.pieces)) : 3,
        i = r,
        s = e(this),
        o = e.effects.setMode(s, t.mode || "hide"),
        u = o === "show",
        a = s.show().css("visibility", "hidden").offset(),
        f = Math.ceil(s.outerWidth() / i),
        l = Math.ceil(s.outerHeight() / r),
        c = [],
        h,
        p,
        d,
        v,
        m,
        g;

    for (h = 0; h < r; h++) {
      v = a.top + h * l, g = h - (r - 1) / 2;

      for (p = 0; p < i; p++) {
        d = a.left + p * f, m = p - (i - 1) / 2, s.clone().appendTo("body").wrap("<div></div>").css({
          position: "absolute",
          visibility: "visible",
          left: -p * f,
          top: -h * l
        }).parent().addClass("ui-effects-explode").css({
          position: "absolute",
          overflow: "hidden",
          width: f,
          height: l,
          left: d + (u ? m * f : 0),
          top: v + (u ? g * l : 0),
          opacity: u ? 0 : 1
        }).animate({
          left: d + (u ? 0 : m * f),
          top: v + (u ? 0 : g * l),
          opacity: u ? 1 : 0
        }, t.duration || 500, t.easing, y);
      }
    }
  };
}(jQuery), function (e, t) {
  e.effects.effect.fade = function (t, n) {
    var r = e(this),
        i = e.effects.setMode(r, t.mode || "toggle");
    r.animate({
      opacity: i
    }, {
      queue: !1,
      duration: t.duration,
      easing: t.easing,
      complete: n
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.fold = function (t, n) {
    var r = e(this),
        i = ["position", "top", "bottom", "left", "right", "height", "width"],
        s = e.effects.setMode(r, t.mode || "hide"),
        o = s === "show",
        u = s === "hide",
        a = t.size || 15,
        f = /([0-9]+)%/.exec(a),
        l = !!t.horizFirst,
        c = o !== l,
        h = c ? ["width", "height"] : ["height", "width"],
        p = t.duration / 2,
        d,
        v,
        m = {},
        g = {};
    e.effects.save(r, i), r.show(), d = e.effects.createWrapper(r).css({
      overflow: "hidden"
    }), v = c ? [d.width(), d.height()] : [d.height(), d.width()], f && (a = parseInt(f[1], 10) / 100 * v[u ? 0 : 1]), o && d.css(l ? {
      height: 0,
      width: a
    } : {
      height: a,
      width: 0
    }), m[h[0]] = o ? v[0] : a, g[h[1]] = o ? v[1] : 0, d.animate(m, p, t.easing).animate(g, p, t.easing, function () {
      u && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n();
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.highlight = function (t, n) {
    var r = e(this),
        i = ["backgroundImage", "backgroundColor", "opacity"],
        s = e.effects.setMode(r, t.mode || "show"),
        o = {
      backgroundColor: r.css("backgroundColor")
    };
    s === "hide" && (o.opacity = 0), e.effects.save(r, i), r.show().css({
      backgroundImage: "none",
      backgroundColor: t.color || "#ffff99"
    }).animate(o, {
      queue: !1,
      duration: t.duration,
      easing: t.easing,
      complete: function complete() {
        s === "hide" && r.hide(), e.effects.restore(r, i), n();
      }
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.pulsate = function (t, n) {
    var r = e(this),
        i = e.effects.setMode(r, t.mode || "show"),
        s = i === "show",
        o = i === "hide",
        u = s || i === "hide",
        a = (t.times || 5) * 2 + (u ? 1 : 0),
        f = t.duration / a,
        l = 0,
        c = r.queue(),
        h = c.length,
        p;
    if (s || !r.is(":visible")) r.css("opacity", 0).show(), l = 1;

    for (p = 1; p < a; p++) {
      r.animate({
        opacity: l
      }, f, t.easing), l = 1 - l;
    }

    r.animate({
      opacity: l
    }, f, t.easing), r.queue(function () {
      o && r.hide(), n();
    }), h > 1 && c.splice.apply(c, [1, 0].concat(c.splice(h, a + 1))), r.dequeue();
  };
}(jQuery), function (e, t) {
  e.effects.effect.puff = function (t, n) {
    var r = e(this),
        i = e.effects.setMode(r, t.mode || "hide"),
        s = i === "hide",
        o = parseInt(t.percent, 10) || 150,
        u = o / 100,
        a = {
      height: r.height(),
      width: r.width(),
      outerHeight: r.outerHeight(),
      outerWidth: r.outerWidth()
    };
    e.extend(t, {
      effect: "scale",
      queue: !1,
      fade: !0,
      mode: i,
      complete: n,
      percent: s ? o : 100,
      from: s ? a : {
        height: a.height * u,
        width: a.width * u,
        outerHeight: a.outerHeight * u,
        outerWidth: a.outerWidth * u
      }
    }), r.effect(t);
  }, e.effects.effect.scale = function (t, n) {
    var r = e(this),
        i = e.extend(!0, {}, t),
        s = e.effects.setMode(r, t.mode || "effect"),
        o = parseInt(t.percent, 10) || (parseInt(t.percent, 10) === 0 ? 0 : s === "hide" ? 0 : 100),
        u = t.direction || "both",
        a = t.origin,
        f = {
      height: r.height(),
      width: r.width(),
      outerHeight: r.outerHeight(),
      outerWidth: r.outerWidth()
    },
        l = {
      y: u !== "horizontal" ? o / 100 : 1,
      x: u !== "vertical" ? o / 100 : 1
    };
    i.effect = "size", i.queue = !1, i.complete = n, s !== "effect" && (i.origin = a || ["middle", "center"], i.restore = !0), i.from = t.from || (s === "show" ? {
      height: 0,
      width: 0,
      outerHeight: 0,
      outerWidth: 0
    } : f), i.to = {
      height: f.height * l.y,
      width: f.width * l.x,
      outerHeight: f.outerHeight * l.y,
      outerWidth: f.outerWidth * l.x
    }, i.fade && (s === "show" && (i.from.opacity = 0, i.to.opacity = 1), s === "hide" && (i.from.opacity = 1, i.to.opacity = 0)), r.effect(i);
  }, e.effects.effect.size = function (t, n) {
    var r,
        i,
        s,
        o = e(this),
        u = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],
        a = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],
        f = ["width", "height", "overflow"],
        l = ["fontSize"],
        c = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
        h = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
        p = e.effects.setMode(o, t.mode || "effect"),
        d = t.restore || p !== "effect",
        v = t.scale || "both",
        m = t.origin || ["middle", "center"],
        g = o.css("position"),
        y = d ? u : a,
        b = {
      height: 0,
      width: 0,
      outerHeight: 0,
      outerWidth: 0
    };
    p === "show" && o.show(), r = {
      height: o.height(),
      width: o.width(),
      outerHeight: o.outerHeight(),
      outerWidth: o.outerWidth()
    }, t.mode === "toggle" && p === "show" ? (o.from = t.to || b, o.to = t.from || r) : (o.from = t.from || (p === "show" ? b : r), o.to = t.to || (p === "hide" ? b : r)), s = {
      from: {
        y: o.from.height / r.height,
        x: o.from.width / r.width
      },
      to: {
        y: o.to.height / r.height,
        x: o.to.width / r.width
      }
    };
    if (v === "box" || v === "both") s.from.y !== s.to.y && (y = y.concat(c), o.from = e.effects.setTransition(o, c, s.from.y, o.from), o.to = e.effects.setTransition(o, c, s.to.y, o.to)), s.from.x !== s.to.x && (y = y.concat(h), o.from = e.effects.setTransition(o, h, s.from.x, o.from), o.to = e.effects.setTransition(o, h, s.to.x, o.to));
    (v === "content" || v === "both") && s.from.y !== s.to.y && (y = y.concat(l).concat(f), o.from = e.effects.setTransition(o, l, s.from.y, o.from), o.to = e.effects.setTransition(o, l, s.to.y, o.to)), e.effects.save(o, y), o.show(), e.effects.createWrapper(o), o.css("overflow", "hidden").css(o.from), m && (i = e.effects.getBaseline(m, r), o.from.top = (r.outerHeight - o.outerHeight()) * i.y, o.from.left = (r.outerWidth - o.outerWidth()) * i.x, o.to.top = (r.outerHeight - o.to.outerHeight) * i.y, o.to.left = (r.outerWidth - o.to.outerWidth) * i.x), o.css(o.from);
    if (v === "content" || v === "both") c = c.concat(["marginTop", "marginBottom"]).concat(l), h = h.concat(["marginLeft", "marginRight"]), f = u.concat(c).concat(h), o.find("*[width]").each(function () {
      var n = e(this),
          r = {
        height: n.height(),
        width: n.width(),
        outerHeight: n.outerHeight(),
        outerWidth: n.outerWidth()
      };
      d && e.effects.save(n, f), n.from = {
        height: r.height * s.from.y,
        width: r.width * s.from.x,
        outerHeight: r.outerHeight * s.from.y,
        outerWidth: r.outerWidth * s.from.x
      }, n.to = {
        height: r.height * s.to.y,
        width: r.width * s.to.x,
        outerHeight: r.height * s.to.y,
        outerWidth: r.width * s.to.x
      }, s.from.y !== s.to.y && (n.from = e.effects.setTransition(n, c, s.from.y, n.from), n.to = e.effects.setTransition(n, c, s.to.y, n.to)), s.from.x !== s.to.x && (n.from = e.effects.setTransition(n, h, s.from.x, n.from), n.to = e.effects.setTransition(n, h, s.to.x, n.to)), n.css(n.from), n.animate(n.to, t.duration, t.easing, function () {
        d && e.effects.restore(n, f);
      });
    });
    o.animate(o.to, {
      queue: !1,
      duration: t.duration,
      easing: t.easing,
      complete: function complete() {
        o.to.opacity === 0 && o.css("opacity", o.from.opacity), p === "hide" && o.hide(), e.effects.restore(o, y), d || (g === "static" ? o.css({
          position: "relative",
          top: o.to.top,
          left: o.to.left
        }) : e.each(["top", "left"], function (e, t) {
          o.css(t, function (t, n) {
            var r = parseInt(n, 10),
                i = e ? o.to.left : o.to.top;
            return n === "auto" ? i + "px" : r + i + "px";
          });
        })), e.effects.removeWrapper(o), n();
      }
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.shake = function (t, n) {
    var r = e(this),
        i = ["position", "top", "bottom", "left", "right", "height", "width"],
        s = e.effects.setMode(r, t.mode || "effect"),
        o = t.direction || "left",
        u = t.distance || 20,
        a = t.times || 3,
        f = a * 2 + 1,
        l = Math.round(t.duration / f),
        c = o === "up" || o === "down" ? "top" : "left",
        h = o === "up" || o === "left",
        p = {},
        d = {},
        v = {},
        m,
        g = r.queue(),
        y = g.length;
    e.effects.save(r, i), r.show(), e.effects.createWrapper(r), p[c] = (h ? "-=" : "+=") + u, d[c] = (h ? "+=" : "-=") + u * 2, v[c] = (h ? "-=" : "+=") + u * 2, r.animate(p, l, t.easing);

    for (m = 1; m < a; m++) {
      r.animate(d, l, t.easing).animate(v, l, t.easing);
    }

    r.animate(d, l, t.easing).animate(p, l / 2, t.easing).queue(function () {
      s === "hide" && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n();
    }), y > 1 && g.splice.apply(g, [1, 0].concat(g.splice(y, f + 1))), r.dequeue();
  };
}(jQuery), function (e, t) {
  e.effects.effect.slide = function (t, n) {
    var r = e(this),
        i = ["position", "top", "bottom", "left", "right", "width", "height"],
        s = e.effects.setMode(r, t.mode || "show"),
        o = s === "show",
        u = t.direction || "left",
        a = u === "up" || u === "down" ? "top" : "left",
        f = u === "up" || u === "left",
        l,
        c = {};
    e.effects.save(r, i), r.show(), l = t.distance || r[a === "top" ? "outerHeight" : "outerWidth"](!0), e.effects.createWrapper(r).css({
      overflow: "hidden"
    }), o && r.css(a, f ? isNaN(l) ? "-" + l : -l : l), c[a] = (o ? f ? "+=" : "-=" : f ? "-=" : "+=") + l, r.animate(c, {
      queue: !1,
      duration: t.duration,
      easing: t.easing,
      complete: function complete() {
        s === "hide" && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n();
      }
    });
  };
}(jQuery), function (e, t) {
  e.effects.effect.transfer = function (t, n) {
    var r = e(this),
        i = e(t.to),
        s = i.css("position") === "fixed",
        o = e("body"),
        u = s ? o.scrollTop() : 0,
        a = s ? o.scrollLeft() : 0,
        f = i.offset(),
        l = {
      top: f.top - u,
      left: f.left - a,
      height: i.innerHeight(),
      width: i.innerWidth()
    },
        c = r.offset(),
        h = e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(t.className).css({
      top: c.top - u,
      left: c.left - a,
      height: r.innerHeight(),
      width: r.innerWidth(),
      position: s ? "fixed" : "absolute"
    }).animate(l, t.duration, t.easing, function () {
      h.remove(), n();
    });
  };
}(jQuery), function (e, t) {
  var n = !1;
  e.widget("ui.menu", {
    version: "1.9.2",
    defaultElement: "<ul>",
    delay: 300,
    options: {
      icons: {
        submenu: "ui-icon-carat-1-e"
      },
      menus: "ul",
      position: {
        my: "left top",
        at: "right top"
      },
      role: "menu",
      blur: null,
      focus: null,
      select: null
    },
    _create: function _create() {
      this.activeMenu = this.element, this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content ui-corner-all").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
        role: this.options.role,
        tabIndex: 0
      }).bind("click" + this.eventNamespace, e.proxy(function (e) {
        this.options.disabled && e.preventDefault();
      }, this)), this.options.disabled && this.element.addClass("ui-state-disabled").attr("aria-disabled", "true"), this._on({
        "mousedown .ui-menu-item > a": function mousedownUiMenuItemA(e) {
          e.preventDefault();
        },
        "click .ui-state-disabled > a": function clickUiStateDisabledA(e) {
          e.preventDefault();
        },
        "click .ui-menu-item:has(a)": function clickUiMenuItemHasA(t) {
          var r = e(t.target).closest(".ui-menu-item");
          !n && r.not(".ui-state-disabled").length && (n = !0, this.select(t), r.has(".ui-menu").length ? this.expand(t) : this.element.is(":focus") || (this.element.trigger("focus", [!0]), this.active && this.active.parents(".ui-menu").length === 1 && clearTimeout(this.timer)));
        },
        "mouseenter .ui-menu-item": function mouseenterUiMenuItem(t) {
          var n = e(t.currentTarget);
          n.siblings().children(".ui-state-active").removeClass("ui-state-active"), this.focus(t, n);
        },
        mouseleave: "collapseAll",
        "mouseleave .ui-menu": "collapseAll",
        focus: function focus(e, t) {
          var n = this.active || this.element.children(".ui-menu-item").eq(0);
          t || this.focus(e, n);
        },
        blur: function blur(t) {
          this._delay(function () {
            e.contains(this.element[0], this.document[0].activeElement) || this.collapseAll(t);
          });
        },
        keydown: "_keydown"
      }), this.refresh(), this._on(this.document, {
        click: function click(t) {
          e(t.target).closest(".ui-menu").length || this.collapseAll(t), n = !1;
        }
      });
    },
    _destroy: function _destroy() {
      this.element.removeAttr("aria-activedescendant").find(".ui-menu").andSelf().removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(), this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").children("a").removeUniqueId().removeClass("ui-corner-all ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function () {
        var t = e(this);
        t.data("ui-menu-submenu-carat") && t.remove();
      }), this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
    },
    _keydown: function _keydown(t) {
      function a(e) {
        return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }

      var n,
          r,
          i,
          s,
          o,
          u = !0;

      switch (t.keyCode) {
        case e.ui.keyCode.PAGE_UP:
          this.previousPage(t);
          break;

        case e.ui.keyCode.PAGE_DOWN:
          this.nextPage(t);
          break;

        case e.ui.keyCode.HOME:
          this._move("first", "first", t);

          break;

        case e.ui.keyCode.END:
          this._move("last", "last", t);

          break;

        case e.ui.keyCode.UP:
          this.previous(t);
          break;

        case e.ui.keyCode.DOWN:
          this.next(t);
          break;

        case e.ui.keyCode.LEFT:
          this.collapse(t);
          break;

        case e.ui.keyCode.RIGHT:
          this.active && !this.active.is(".ui-state-disabled") && this.expand(t);
          break;

        case e.ui.keyCode.ENTER:
        case e.ui.keyCode.SPACE:
          this._activate(t);

          break;

        case e.ui.keyCode.ESCAPE:
          this.collapse(t);
          break;

        default:
          u = !1, r = this.previousFilter || "", i = String.fromCharCode(t.keyCode), s = !1, clearTimeout(this.filterTimer), i === r ? s = !0 : i = r + i, o = new RegExp("^" + a(i), "i"), n = this.activeMenu.children(".ui-menu-item").filter(function () {
            return o.test(e(this).children("a").text());
          }), n = s && n.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : n, n.length || (i = String.fromCharCode(t.keyCode), o = new RegExp("^" + a(i), "i"), n = this.activeMenu.children(".ui-menu-item").filter(function () {
            return o.test(e(this).children("a").text());
          })), n.length ? (this.focus(t, n), n.length > 1 ? (this.previousFilter = i, this.filterTimer = this._delay(function () {
            delete this.previousFilter;
          }, 1e3)) : delete this.previousFilter) : delete this.previousFilter;
      }

      u && t.preventDefault();
    },
    _activate: function _activate(e) {
      this.active.is(".ui-state-disabled") || (this.active.children("a[aria-haspopup='true']").length ? this.expand(e) : this.select(e));
    },
    refresh: function refresh() {
      var t,
          n = this.options.icons.submenu,
          r = this.element.find(this.options.menus);
      r.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-corner-all").hide().attr({
        role: this.options.role,
        "aria-hidden": "true",
        "aria-expanded": "false"
      }).each(function () {
        var t = e(this),
            r = t.prev("a"),
            i = e("<span>").addClass("ui-menu-icon ui-icon " + n).data("ui-menu-submenu-carat", !0);
        r.attr("aria-haspopup", "true").prepend(i), t.attr("aria-labelledby", r.attr("id"));
      }), t = r.add(this.element), t.children(":not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role", "presentation").children("a").uniqueId().addClass("ui-corner-all").attr({
        tabIndex: -1,
        role: this._itemRole()
      }), t.children(":not(.ui-menu-item)").each(function () {
        var t = e(this);
        /[^\-\s]/.test(t.text()) || t.addClass("ui-widget-content ui-menu-divider");
      }), t.children(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !e.contains(this.element[0], this.active[0]) && this.blur();
    },
    _itemRole: function _itemRole() {
      return {
        menu: "menuitem",
        listbox: "option"
      }[this.options.role];
    },
    focus: function focus(e, t) {
      var n, r;
      this.blur(e, e && e.type === "focus"), this._scrollIntoView(t), this.active = t.first(), r = this.active.children("a").addClass("ui-state-focus"), this.options.role && this.element.attr("aria-activedescendant", r.attr("id")), this.active.parent().closest(".ui-menu-item").children("a:first").addClass("ui-state-active"), e && e.type === "keydown" ? this._close() : this.timer = this._delay(function () {
        this._close();
      }, this.delay), n = t.children(".ui-menu"), n.length && /^mouse/.test(e.type) && this._startOpening(n), this.activeMenu = t.parent(), this._trigger("focus", e, {
        item: t
      });
    },
    _scrollIntoView: function _scrollIntoView(t) {
      var n, r, i, s, o, u;
      this._hasScroll() && (n = parseFloat(e.css(this.activeMenu[0], "borderTopWidth")) || 0, r = parseFloat(e.css(this.activeMenu[0], "paddingTop")) || 0, i = t.offset().top - this.activeMenu.offset().top - n - r, s = this.activeMenu.scrollTop(), o = this.activeMenu.height(), u = t.height(), i < 0 ? this.activeMenu.scrollTop(s + i) : i + u > o && this.activeMenu.scrollTop(s + i - o + u));
    },
    blur: function blur(e, t) {
      t || clearTimeout(this.timer);
      if (!this.active) return;
      this.active.children("a").removeClass("ui-state-focus"), this.active = null, this._trigger("blur", e, {
        item: this.active
      });
    },
    _startOpening: function _startOpening(e) {
      clearTimeout(this.timer);
      if (e.attr("aria-hidden") !== "true") return;
      this.timer = this._delay(function () {
        this._close(), this._open(e);
      }, this.delay);
    },
    _open: function _open(t) {
      var n = e.extend({
        of: this.active
      }, this.options.position);
      clearTimeout(this.timer), this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden", "true"), t.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(n);
    },
    collapseAll: function collapseAll(t, n) {
      clearTimeout(this.timer), this.timer = this._delay(function () {
        var r = n ? this.element : e(t && t.target).closest(this.element.find(".ui-menu"));
        r.length || (r = this.element), this._close(r), this.blur(t), this.activeMenu = r;
      }, this.delay);
    },
    _close: function _close(e) {
      e || (e = this.active ? this.active.parent() : this.element), e.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find("a.ui-state-active").removeClass("ui-state-active");
    },
    collapse: function collapse(e) {
      var t = this.active && this.active.parent().closest(".ui-menu-item", this.element);
      t && t.length && (this._close(), this.focus(e, t));
    },
    expand: function expand(e) {
      var t = this.active && this.active.children(".ui-menu ").children(".ui-menu-item").first();
      t && t.length && (this._open(t.parent()), this._delay(function () {
        this.focus(e, t);
      }));
    },
    next: function next(e) {
      this._move("next", "first", e);
    },
    previous: function previous(e) {
      this._move("prev", "last", e);
    },
    isFirstItem: function isFirstItem() {
      return this.active && !this.active.prevAll(".ui-menu-item").length;
    },
    isLastItem: function isLastItem() {
      return this.active && !this.active.nextAll(".ui-menu-item").length;
    },
    _move: function _move(e, t, n) {
      var r;
      this.active && (e === "first" || e === "last" ? r = this.active[e === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : r = this.active[e + "All"](".ui-menu-item").eq(0));
      if (!r || !r.length || !this.active) r = this.activeMenu.children(".ui-menu-item")[t]();
      this.focus(n, r);
    },
    nextPage: function nextPage(t) {
      var n, r, i;

      if (!this.active) {
        this.next(t);
        return;
      }

      if (this.isLastItem()) return;
      this._hasScroll() ? (r = this.active.offset().top, i = this.element.height(), this.active.nextAll(".ui-menu-item").each(function () {
        return n = e(this), n.offset().top - r - i < 0;
      }), this.focus(t, n)) : this.focus(t, this.activeMenu.children(".ui-menu-item")[this.active ? "last" : "first"]());
    },
    previousPage: function previousPage(t) {
      var n, r, i;

      if (!this.active) {
        this.next(t);
        return;
      }

      if (this.isFirstItem()) return;
      this._hasScroll() ? (r = this.active.offset().top, i = this.element.height(), this.active.prevAll(".ui-menu-item").each(function () {
        return n = e(this), n.offset().top - r + i > 0;
      }), this.focus(t, n)) : this.focus(t, this.activeMenu.children(".ui-menu-item").first());
    },
    _hasScroll: function _hasScroll() {
      return this.element.outerHeight() < this.element.prop("scrollHeight");
    },
    select: function select(t) {
      this.active = this.active || e(t.target).closest(".ui-menu-item");
      var n = {
        item: this.active
      };
      this.active.has(".ui-menu").length || this.collapseAll(t, !0), this._trigger("select", t, n);
    }
  });
}(jQuery), function (e, t) {
  function h(e, t, n) {
    return [parseInt(e[0], 10) * (l.test(e[0]) ? t / 100 : 1), parseInt(e[1], 10) * (l.test(e[1]) ? n / 100 : 1)];
  }

  function p(t, n) {
    return parseInt(e.css(t, n), 10) || 0;
  }

  e.ui = e.ui || {};
  var n,
      r = Math.max,
      i = Math.abs,
      s = Math.round,
      o = /left|center|right/,
      u = /top|center|bottom/,
      a = /[\+\-]\d+%?/,
      f = /^\w+/,
      l = /%$/,
      c = e.fn.position;
  e.position = {
    scrollbarWidth: function scrollbarWidth() {
      if (n !== t) return n;
      var r,
          i,
          s = e("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
          o = s.children()[0];
      return e("body").append(s), r = o.offsetWidth, s.css("overflow", "scroll"), i = o.offsetWidth, r === i && (i = s[0].clientWidth), s.remove(), n = r - i;
    },
    getScrollInfo: function getScrollInfo(t) {
      var n = t.isWindow ? "" : t.element.css("overflow-x"),
          r = t.isWindow ? "" : t.element.css("overflow-y"),
          i = n === "scroll" || n === "auto" && t.width < t.element[0].scrollWidth,
          s = r === "scroll" || r === "auto" && t.height < t.element[0].scrollHeight;
      return {
        width: i ? e.position.scrollbarWidth() : 0,
        height: s ? e.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function getWithinInfo(t) {
      var n = e(t || window),
          r = e.isWindow(n[0]);
      return {
        element: n,
        isWindow: r,
        offset: n.offset() || {
          left: 0,
          top: 0
        },
        scrollLeft: n.scrollLeft(),
        scrollTop: n.scrollTop(),
        width: r ? n.width() : n.outerWidth(),
        height: r ? n.height() : n.outerHeight()
      };
    }
  }, e.fn.position = function (t) {
    if (!t || !t.of) return c.apply(this, arguments);
    t = e.extend({}, t);
    var n,
        l,
        d,
        v,
        m,
        g = e(t.of),
        y = e.position.getWithinInfo(t.within),
        b = e.position.getScrollInfo(y),
        w = g[0],
        E = (t.collision || "flip").split(" "),
        S = {};
    return w.nodeType === 9 ? (l = g.width(), d = g.height(), v = {
      top: 0,
      left: 0
    }) : e.isWindow(w) ? (l = g.width(), d = g.height(), v = {
      top: g.scrollTop(),
      left: g.scrollLeft()
    }) : w.preventDefault ? (t.at = "left top", l = d = 0, v = {
      top: w.pageY,
      left: w.pageX
    }) : (l = g.outerWidth(), d = g.outerHeight(), v = g.offset()), m = e.extend({}, v), e.each(["my", "at"], function () {
      var e = (t[this] || "").split(" "),
          n,
          r;
      e.length === 1 && (e = o.test(e[0]) ? e.concat(["center"]) : u.test(e[0]) ? ["center"].concat(e) : ["center", "center"]), e[0] = o.test(e[0]) ? e[0] : "center", e[1] = u.test(e[1]) ? e[1] : "center", n = a.exec(e[0]), r = a.exec(e[1]), S[this] = [n ? n[0] : 0, r ? r[0] : 0], t[this] = [f.exec(e[0])[0], f.exec(e[1])[0]];
    }), E.length === 1 && (E[1] = E[0]), t.at[0] === "right" ? m.left += l : t.at[0] === "center" && (m.left += l / 2), t.at[1] === "bottom" ? m.top += d : t.at[1] === "center" && (m.top += d / 2), n = h(S.at, l, d), m.left += n[0], m.top += n[1], this.each(function () {
      var o,
          u,
          a = e(this),
          f = a.outerWidth(),
          c = a.outerHeight(),
          w = p(this, "marginLeft"),
          x = p(this, "marginTop"),
          T = f + w + p(this, "marginRight") + b.width,
          N = c + x + p(this, "marginBottom") + b.height,
          C = e.extend({}, m),
          k = h(S.my, a.outerWidth(), a.outerHeight());
      t.my[0] === "right" ? C.left -= f : t.my[0] === "center" && (C.left -= f / 2), t.my[1] === "bottom" ? C.top -= c : t.my[1] === "center" && (C.top -= c / 2), C.left += k[0], C.top += k[1], e.support.offsetFractions || (C.left = s(C.left), C.top = s(C.top)), o = {
        marginLeft: w,
        marginTop: x
      }, e.each(["left", "top"], function (r, i) {
        e.ui.position[E[r]] && e.ui.position[E[r]][i](C, {
          targetWidth: l,
          targetHeight: d,
          elemWidth: f,
          elemHeight: c,
          collisionPosition: o,
          collisionWidth: T,
          collisionHeight: N,
          offset: [n[0] + k[0], n[1] + k[1]],
          my: t.my,
          at: t.at,
          within: y,
          elem: a
        });
      }), e.fn.bgiframe && a.bgiframe(), t.using && (u = function u(e) {
        var n = v.left - C.left,
            s = n + l - f,
            o = v.top - C.top,
            u = o + d - c,
            h = {
          target: {
            element: g,
            left: v.left,
            top: v.top,
            width: l,
            height: d
          },
          element: {
            element: a,
            left: C.left,
            top: C.top,
            width: f,
            height: c
          },
          horizontal: s < 0 ? "left" : n > 0 ? "right" : "center",
          vertical: u < 0 ? "top" : o > 0 ? "bottom" : "middle"
        };
        l < f && i(n + s) < l && (h.horizontal = "center"), d < c && i(o + u) < d && (h.vertical = "middle"), r(i(n), i(s)) > r(i(o), i(u)) ? h.important = "horizontal" : h.important = "vertical", t.using.call(this, e, h);
      }), a.offset(e.extend(C, {
        using: u
      }));
    });
  }, e.ui.position = {
    fit: {
      left: function left(e, t) {
        var n = t.within,
            i = n.isWindow ? n.scrollLeft : n.offset.left,
            s = n.width,
            o = e.left - t.collisionPosition.marginLeft,
            u = i - o,
            a = o + t.collisionWidth - s - i,
            f;
        t.collisionWidth > s ? u > 0 && a <= 0 ? (f = e.left + u + t.collisionWidth - s - i, e.left += u - f) : a > 0 && u <= 0 ? e.left = i : u > a ? e.left = i + s - t.collisionWidth : e.left = i : u > 0 ? e.left += u : a > 0 ? e.left -= a : e.left = r(e.left - o, e.left);
      },
      top: function top(e, t) {
        var n = t.within,
            i = n.isWindow ? n.scrollTop : n.offset.top,
            s = t.within.height,
            o = e.top - t.collisionPosition.marginTop,
            u = i - o,
            a = o + t.collisionHeight - s - i,
            f;
        t.collisionHeight > s ? u > 0 && a <= 0 ? (f = e.top + u + t.collisionHeight - s - i, e.top += u - f) : a > 0 && u <= 0 ? e.top = i : u > a ? e.top = i + s - t.collisionHeight : e.top = i : u > 0 ? e.top += u : a > 0 ? e.top -= a : e.top = r(e.top - o, e.top);
      }
    },
    flip: {
      left: function left(e, t) {
        var n = t.within,
            r = n.offset.left + n.scrollLeft,
            s = n.width,
            o = n.isWindow ? n.scrollLeft : n.offset.left,
            u = e.left - t.collisionPosition.marginLeft,
            a = u - o,
            f = u + t.collisionWidth - s - o,
            l = t.my[0] === "left" ? -t.elemWidth : t.my[0] === "right" ? t.elemWidth : 0,
            c = t.at[0] === "left" ? t.targetWidth : t.at[0] === "right" ? -t.targetWidth : 0,
            h = -2 * t.offset[0],
            p,
            d;

        if (a < 0) {
          p = e.left + l + c + h + t.collisionWidth - s - r;
          if (p < 0 || p < i(a)) e.left += l + c + h;
        } else if (f > 0) {
          d = e.left - t.collisionPosition.marginLeft + l + c + h - o;
          if (d > 0 || i(d) < f) e.left += l + c + h;
        }
      },
      top: function top(e, t) {
        var n = t.within,
            r = n.offset.top + n.scrollTop,
            s = n.height,
            o = n.isWindow ? n.scrollTop : n.offset.top,
            u = e.top - t.collisionPosition.marginTop,
            a = u - o,
            f = u + t.collisionHeight - s - o,
            l = t.my[1] === "top",
            c = l ? -t.elemHeight : t.my[1] === "bottom" ? t.elemHeight : 0,
            h = t.at[1] === "top" ? t.targetHeight : t.at[1] === "bottom" ? -t.targetHeight : 0,
            p = -2 * t.offset[1],
            d,
            v;
        a < 0 ? (v = e.top + c + h + p + t.collisionHeight - s - r, e.top + c + h + p > a && (v < 0 || v < i(a)) && (e.top += c + h + p)) : f > 0 && (d = e.top - t.collisionPosition.marginTop + c + h + p - o, e.top + c + h + p > f && (d > 0 || i(d) < f) && (e.top += c + h + p));
      }
    },
    flipfit: {
      left: function left() {
        e.ui.position.flip.left.apply(this, arguments), e.ui.position.fit.left.apply(this, arguments);
      },
      top: function top() {
        e.ui.position.flip.top.apply(this, arguments), e.ui.position.fit.top.apply(this, arguments);
      }
    }
  }, function () {
    var t,
        n,
        r,
        i,
        s,
        o = document.getElementsByTagName("body")[0],
        u = document.createElement("div");
    t = document.createElement(o ? "div" : "body"), r = {
      visibility: "hidden",
      width: 0,
      height: 0,
      border: 0,
      margin: 0,
      background: "none"
    }, o && e.extend(r, {
      position: "absolute",
      left: "-1000px",
      top: "-1000px"
    });

    for (s in r) {
      t.style[s] = r[s];
    }

    t.appendChild(u), n = o || document.documentElement, n.insertBefore(t, n.firstChild), u.style.cssText = "position: absolute; left: 10.7432222px;", i = e(u).offset().left, e.support.offsetFractions = i > 10 && i < 11, t.innerHTML = "", n.removeChild(t);
  }(), e.uiBackCompat !== !1 && function (e) {
    var n = e.fn.position;

    e.fn.position = function (r) {
      if (!r || !r.offset) return n.call(this, r);
      var i = r.offset.split(" "),
          s = r.at.split(" ");
      return i.length === 1 && (i[1] = i[0]), /^\d/.test(i[0]) && (i[0] = "+" + i[0]), /^\d/.test(i[1]) && (i[1] = "+" + i[1]), s.length === 1 && (/left|center|right/.test(s[0]) ? s[1] = "center" : (s[1] = s[0], s[0] = "center")), n.call(this, e.extend(r, {
        at: s[0] + i[0] + " " + s[1] + i[1],
        offset: t
      }));
    };
  }(jQuery);
}(jQuery), function (e, t) {
  e.widget("ui.progressbar", {
    version: "1.9.2",
    options: {
      value: 0,
      max: 100
    },
    min: 0,
    _create: function _create() {
      this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
        role: "progressbar",
        "aria-valuemin": this.min,
        "aria-valuemax": this.options.max,
        "aria-valuenow": this._value()
      }), this.valueDiv = e("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element), this.oldValue = this._value(), this._refreshValue();
    },
    _destroy: function _destroy() {
      this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.valueDiv.remove();
    },
    value: function value(e) {
      return e === t ? this._value() : (this._setOption("value", e), this);
    },
    _setOption: function _setOption(e, t) {
      e === "value" && (this.options.value = t, this._refreshValue(), this._value() === this.options.max && this._trigger("complete")), this._super(e, t);
    },
    _value: function _value() {
      var e = this.options.value;
      return typeof e != "number" && (e = 0), Math.min(this.options.max, Math.max(this.min, e));
    },
    _percentage: function _percentage() {
      return 100 * this._value() / this.options.max;
    },
    _refreshValue: function _refreshValue() {
      var e = this.value(),
          t = this._percentage();

      this.oldValue !== e && (this.oldValue = e, this._trigger("change")), this.valueDiv.toggle(e > this.min).toggleClass("ui-corner-right", e === this.options.max).width(t.toFixed(0) + "%"), this.element.attr("aria-valuenow", e);
    }
  });
}(jQuery), function (e, t) {
  var n = 5;
  e.widget("ui.slider", e.ui.mouse, {
    version: "1.9.2",
    widgetEventPrefix: "slide",
    options: {
      animate: !1,
      distance: 0,
      max: 100,
      min: 0,
      orientation: "horizontal",
      range: !1,
      step: 1,
      value: 0,
      values: null
    },
    _create: function _create() {
      var t,
          r,
          i = this.options,
          s = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
          o = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
          u = [];
      this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all" + (i.disabled ? " ui-slider-disabled ui-disabled" : "")), this.range = e([]), i.range && (i.range === !0 && (i.values || (i.values = [this._valueMin(), this._valueMin()]), i.values.length && i.values.length !== 2 && (i.values = [i.values[0], i.values[0]])), this.range = e("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header" + (i.range === "min" || i.range === "max" ? " ui-slider-range-" + i.range : ""))), r = i.values && i.values.length || 1;

      for (t = s.length; t < r; t++) {
        u.push(o);
      }

      this.handles = s.add(e(u.join("")).appendTo(this.element)), this.handle = this.handles.eq(0), this.handles.add(this.range).filter("a").click(function (e) {
        e.preventDefault();
      }).mouseenter(function () {
        i.disabled || e(this).addClass("ui-state-hover");
      }).mouseleave(function () {
        e(this).removeClass("ui-state-hover");
      }).focus(function () {
        i.disabled ? e(this).blur() : (e(".ui-slider .ui-state-focus").removeClass("ui-state-focus"), e(this).addClass("ui-state-focus"));
      }).blur(function () {
        e(this).removeClass("ui-state-focus");
      }), this.handles.each(function (t) {
        e(this).data("ui-slider-handle-index", t);
      }), this._on(this.handles, {
        keydown: function keydown(t) {
          var r,
              i,
              s,
              o,
              u = e(t.target).data("ui-slider-handle-index");

          switch (t.keyCode) {
            case e.ui.keyCode.HOME:
            case e.ui.keyCode.END:
            case e.ui.keyCode.PAGE_UP:
            case e.ui.keyCode.PAGE_DOWN:
            case e.ui.keyCode.UP:
            case e.ui.keyCode.RIGHT:
            case e.ui.keyCode.DOWN:
            case e.ui.keyCode.LEFT:
              t.preventDefault();

              if (!this._keySliding) {
                this._keySliding = !0, e(t.target).addClass("ui-state-active"), r = this._start(t, u);
                if (r === !1) return;
              }

          }

          o = this.options.step, this.options.values && this.options.values.length ? i = s = this.values(u) : i = s = this.value();

          switch (t.keyCode) {
            case e.ui.keyCode.HOME:
              s = this._valueMin();
              break;

            case e.ui.keyCode.END:
              s = this._valueMax();
              break;

            case e.ui.keyCode.PAGE_UP:
              s = this._trimAlignValue(i + (this._valueMax() - this._valueMin()) / n);
              break;

            case e.ui.keyCode.PAGE_DOWN:
              s = this._trimAlignValue(i - (this._valueMax() - this._valueMin()) / n);
              break;

            case e.ui.keyCode.UP:
            case e.ui.keyCode.RIGHT:
              if (i === this._valueMax()) return;
              s = this._trimAlignValue(i + o);
              break;

            case e.ui.keyCode.DOWN:
            case e.ui.keyCode.LEFT:
              if (i === this._valueMin()) return;
              s = this._trimAlignValue(i - o);
          }

          this._slide(t, u, s);
        },
        keyup: function keyup(t) {
          var n = e(t.target).data("ui-slider-handle-index");
          this._keySliding && (this._keySliding = !1, this._stop(t, n), this._change(t, n), e(t.target).removeClass("ui-state-active"));
        }
      }), this._refreshValue(), this._animateOff = !1;
    },
    _destroy: function _destroy() {
      this.handles.remove(), this.range.remove(), this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all"), this._mouseDestroy();
    },
    _mouseCapture: function _mouseCapture(t) {
      var n,
          r,
          i,
          s,
          o,
          u,
          a,
          f,
          l = this,
          c = this.options;
      return c.disabled ? !1 : (this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      }, this.elementOffset = this.element.offset(), n = {
        x: t.pageX,
        y: t.pageY
      }, r = this._normValueFromMouse(n), i = this._valueMax() - this._valueMin() + 1, this.handles.each(function (t) {
        var n = Math.abs(r - l.values(t));
        i > n && (i = n, s = e(this), o = t);
      }), c.range === !0 && this.values(1) === c.min && (o += 1, s = e(this.handles[o])), u = this._start(t, o), u === !1 ? !1 : (this._mouseSliding = !0, this._handleIndex = o, s.addClass("ui-state-active").focus(), a = s.offset(), f = !e(t.target).parents().andSelf().is(".ui-slider-handle"), this._clickOffset = f ? {
        left: 0,
        top: 0
      } : {
        left: t.pageX - a.left - s.width() / 2,
        top: t.pageY - a.top - s.height() / 2 - (parseInt(s.css("borderTopWidth"), 10) || 0) - (parseInt(s.css("borderBottomWidth"), 10) || 0) + (parseInt(s.css("marginTop"), 10) || 0)
      }, this.handles.hasClass("ui-state-hover") || this._slide(t, o, r), this._animateOff = !0, !0));
    },
    _mouseStart: function _mouseStart() {
      return !0;
    },
    _mouseDrag: function _mouseDrag(e) {
      var t = {
        x: e.pageX,
        y: e.pageY
      },
          n = this._normValueFromMouse(t);

      return this._slide(e, this._handleIndex, n), !1;
    },
    _mouseStop: function _mouseStop(e) {
      return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1, this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1, !1;
    },
    _detectOrientation: function _detectOrientation() {
      this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal";
    },
    _normValueFromMouse: function _normValueFromMouse(e) {
      var t, n, r, i, s;
      return this.orientation === "horizontal" ? (t = this.elementSize.width, n = e.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (t = this.elementSize.height, n = e.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), r = n / t, r > 1 && (r = 1), r < 0 && (r = 0), this.orientation === "vertical" && (r = 1 - r), i = this._valueMax() - this._valueMin(), s = this._valueMin() + r * i, this._trimAlignValue(s);
    },
    _start: function _start(e, t) {
      var n = {
        handle: this.handles[t],
        value: this.value()
      };
      return this.options.values && this.options.values.length && (n.value = this.values(t), n.values = this.values()), this._trigger("start", e, n);
    },
    _slide: function _slide(e, t, n) {
      var r, i, s;
      this.options.values && this.options.values.length ? (r = this.values(t ? 0 : 1), this.options.values.length === 2 && this.options.range === !0 && (t === 0 && n > r || t === 1 && n < r) && (n = r), n !== this.values(t) && (i = this.values(), i[t] = n, s = this._trigger("slide", e, {
        handle: this.handles[t],
        value: n,
        values: i
      }), r = this.values(t ? 0 : 1), s !== !1 && this.values(t, n, !0))) : n !== this.value() && (s = this._trigger("slide", e, {
        handle: this.handles[t],
        value: n
      }), s !== !1 && this.value(n));
    },
    _stop: function _stop(e, t) {
      var n = {
        handle: this.handles[t],
        value: this.value()
      };
      this.options.values && this.options.values.length && (n.value = this.values(t), n.values = this.values()), this._trigger("stop", e, n);
    },
    _change: function _change(e, t) {
      if (!this._keySliding && !this._mouseSliding) {
        var n = {
          handle: this.handles[t],
          value: this.value()
        };
        this.options.values && this.options.values.length && (n.value = this.values(t), n.values = this.values()), this._trigger("change", e, n);
      }
    },
    value: function value(e) {
      if (arguments.length) {
        this.options.value = this._trimAlignValue(e), this._refreshValue(), this._change(null, 0);
        return;
      }

      return this._value();
    },
    values: function values(t, n) {
      var r, i, s;

      if (arguments.length > 1) {
        this.options.values[t] = this._trimAlignValue(n), this._refreshValue(), this._change(null, t);
        return;
      }

      if (!arguments.length) return this._values();
      if (!e.isArray(arguments[0])) return this.options.values && this.options.values.length ? this._values(t) : this.value();
      r = this.options.values, i = arguments[0];

      for (s = 0; s < r.length; s += 1) {
        r[s] = this._trimAlignValue(i[s]), this._change(null, s);
      }

      this._refreshValue();
    },
    _setOption: function _setOption(t, n) {
      var r,
          i = 0;
      e.isArray(this.options.values) && (i = this.options.values.length), e.Widget.prototype._setOption.apply(this, arguments);

      switch (t) {
        case "disabled":
          n ? (this.handles.filter(".ui-state-focus").blur(), this.handles.removeClass("ui-state-hover"), this.handles.prop("disabled", !0), this.element.addClass("ui-disabled")) : (this.handles.prop("disabled", !1), this.element.removeClass("ui-disabled"));
          break;

        case "orientation":
          this._detectOrientation(), this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation), this._refreshValue();
          break;

        case "value":
          this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
          break;

        case "values":
          this._animateOff = !0, this._refreshValue();

          for (r = 0; r < i; r += 1) {
            this._change(null, r);
          }

          this._animateOff = !1;
          break;

        case "min":
        case "max":
          this._animateOff = !0, this._refreshValue(), this._animateOff = !1;
      }
    },
    _value: function _value() {
      var e = this.options.value;
      return e = this._trimAlignValue(e), e;
    },
    _values: function _values(e) {
      var t, n, r;
      if (arguments.length) return t = this.options.values[e], t = this._trimAlignValue(t), t;
      n = this.options.values.slice();

      for (r = 0; r < n.length; r += 1) {
        n[r] = this._trimAlignValue(n[r]);
      }

      return n;
    },
    _trimAlignValue: function _trimAlignValue(e) {
      if (e <= this._valueMin()) return this._valueMin();
      if (e >= this._valueMax()) return this._valueMax();
      var t = this.options.step > 0 ? this.options.step : 1,
          n = (e - this._valueMin()) % t,
          r = e - n;
      return Math.abs(n) * 2 >= t && (r += n > 0 ? t : -t), parseFloat(r.toFixed(5));
    },
    _valueMin: function _valueMin() {
      return this.options.min;
    },
    _valueMax: function _valueMax() {
      return this.options.max;
    },
    _refreshValue: function _refreshValue() {
      var t,
          n,
          r,
          i,
          s,
          o = this.options.range,
          u = this.options,
          a = this,
          f = this._animateOff ? !1 : u.animate,
          l = {};
      this.options.values && this.options.values.length ? this.handles.each(function (r) {
        n = (a.values(r) - a._valueMin()) / (a._valueMax() - a._valueMin()) * 100, l[a.orientation === "horizontal" ? "left" : "bottom"] = n + "%", e(this).stop(1, 1)[f ? "animate" : "css"](l, u.animate), a.options.range === !0 && (a.orientation === "horizontal" ? (r === 0 && a.range.stop(1, 1)[f ? "animate" : "css"]({
          left: n + "%"
        }, u.animate), r === 1 && a.range[f ? "animate" : "css"]({
          width: n - t + "%"
        }, {
          queue: !1,
          duration: u.animate
        })) : (r === 0 && a.range.stop(1, 1)[f ? "animate" : "css"]({
          bottom: n + "%"
        }, u.animate), r === 1 && a.range[f ? "animate" : "css"]({
          height: n - t + "%"
        }, {
          queue: !1,
          duration: u.animate
        }))), t = n;
      }) : (r = this.value(), i = this._valueMin(), s = this._valueMax(), n = s !== i ? (r - i) / (s - i) * 100 : 0, l[this.orientation === "horizontal" ? "left" : "bottom"] = n + "%", this.handle.stop(1, 1)[f ? "animate" : "css"](l, u.animate), o === "min" && this.orientation === "horizontal" && this.range.stop(1, 1)[f ? "animate" : "css"]({
        width: n + "%"
      }, u.animate), o === "max" && this.orientation === "horizontal" && this.range[f ? "animate" : "css"]({
        width: 100 - n + "%"
      }, {
        queue: !1,
        duration: u.animate
      }), o === "min" && this.orientation === "vertical" && this.range.stop(1, 1)[f ? "animate" : "css"]({
        height: n + "%"
      }, u.animate), o === "max" && this.orientation === "vertical" && this.range[f ? "animate" : "css"]({
        height: 100 - n + "%"
      }, {
        queue: !1,
        duration: u.animate
      }));
    }
  });
}(jQuery), function (e) {
  function t(e) {
    return function () {
      var t = this.element.val();
      e.apply(this, arguments), this._refresh(), t !== this.element.val() && this._trigger("change");
    };
  }

  e.widget("ui.spinner", {
    version: "1.9.2",
    defaultElement: "<input>",
    widgetEventPrefix: "spin",
    options: {
      culture: null,
      icons: {
        down: "ui-icon-triangle-1-s",
        up: "ui-icon-triangle-1-n"
      },
      incremental: !0,
      max: null,
      min: null,
      numberFormat: null,
      page: 10,
      step: 1,
      change: null,
      spin: null,
      start: null,
      stop: null
    },
    _create: function _create() {
      this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
        beforeunload: function beforeunload() {
          this.element.removeAttr("autocomplete");
        }
      });
    },
    _getCreateOptions: function _getCreateOptions() {
      var t = {},
          n = this.element;
      return e.each(["min", "max", "step"], function (e, r) {
        var i = n.attr(r);
        i !== undefined && i.length && (t[r] = i);
      }), t;
    },
    _events: {
      keydown: function keydown(e) {
        this._start(e) && this._keydown(e) && e.preventDefault();
      },
      keyup: "_stop",
      focus: function focus() {
        this.previous = this.element.val();
      },
      blur: function blur(e) {
        if (this.cancelBlur) {
          delete this.cancelBlur;
          return;
        }

        this._refresh(), this.previous !== this.element.val() && this._trigger("change", e);
      },
      mousewheel: function mousewheel(e, t) {
        if (!t) return;
        if (!this.spinning && !this._start(e)) return !1;
        this._spin((t > 0 ? 1 : -1) * this.options.step, e), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function () {
          this.spinning && this._stop(e);
        }, 100), e.preventDefault();
      },
      "mousedown .ui-spinner-button": function mousedownUiSpinnerButton(t) {
        function r() {
          var e = this.element[0] === this.document[0].activeElement;
          e || (this.element.focus(), this.previous = n, this._delay(function () {
            this.previous = n;
          }));
        }

        var n;
        n = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val(), t.preventDefault(), r.call(this), this.cancelBlur = !0, this._delay(function () {
          delete this.cancelBlur, r.call(this);
        });
        if (this._start(t) === !1) return;

        this._repeat(null, e(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t);
      },
      "mouseup .ui-spinner-button": "_stop",
      "mouseenter .ui-spinner-button": function mouseenterUiSpinnerButton(t) {
        if (!e(t.currentTarget).hasClass("ui-state-active")) return;
        if (this._start(t) === !1) return !1;

        this._repeat(null, e(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t);
      },
      "mouseleave .ui-spinner-button": "_stop"
    },
    _draw: function _draw() {
      var e = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
      this.element.attr("role", "spinbutton"), this.buttons = e.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all"), this.buttons.height() > Math.ceil(e.height() * .5) && e.height() > 0 && e.height(e.height()), this.options.disabled && this.disable();
    },
    _keydown: function _keydown(t) {
      var n = this.options,
          r = e.ui.keyCode;

      switch (t.keyCode) {
        case r.UP:
          return this._repeat(null, 1, t), !0;

        case r.DOWN:
          return this._repeat(null, -1, t), !0;

        case r.PAGE_UP:
          return this._repeat(null, n.page, t), !0;

        case r.PAGE_DOWN:
          return this._repeat(null, -n.page, t), !0;
      }

      return !1;
    },
    _uiSpinnerHtml: function _uiSpinnerHtml() {
      return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
    },
    _buttonHtml: function _buttonHtml() {
      return "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>";
    },
    _start: function _start(e) {
      return !this.spinning && this._trigger("start", e) === !1 ? !1 : (this.counter || (this.counter = 1), this.spinning = !0, !0);
    },
    _repeat: function _repeat(e, t, n) {
      e = e || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
        this._repeat(40, t, n);
      }, e), this._spin(t * this.options.step, n);
    },
    _spin: function _spin(e, t) {
      var n = this.value() || 0;
      this.counter || (this.counter = 1), n = this._adjustValue(n + e * this._increment(this.counter));
      if (!this.spinning || this._trigger("spin", t, {
        value: n
      }) !== !1) this._value(n), this.counter++;
    },
    _increment: function _increment(t) {
      var n = this.options.incremental;
      return n ? e.isFunction(n) ? n(t) : Math.floor(t * t * t / 5e4 - t * t / 500 + 17 * t / 200 + 1) : 1;
    },
    _precision: function _precision() {
      var e = this._precisionOf(this.options.step);

      return this.options.min !== null && (e = Math.max(e, this._precisionOf(this.options.min))), e;
    },
    _precisionOf: function _precisionOf(e) {
      var t = e.toString(),
          n = t.indexOf(".");
      return n === -1 ? 0 : t.length - n - 1;
    },
    _adjustValue: function _adjustValue(e) {
      var t,
          n,
          r = this.options;
      return t = r.min !== null ? r.min : 0, n = e - t, n = Math.round(n / r.step) * r.step, e = t + n, e = parseFloat(e.toFixed(this._precision())), r.max !== null && e > r.max ? r.max : r.min !== null && e < r.min ? r.min : e;
    },
    _stop: function _stop(e) {
      if (!this.spinning) return;
      clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", e);
    },
    _setOption: function _setOption(e, t) {
      if (e === "culture" || e === "numberFormat") {
        var n = this._parse(this.element.val());

        this.options[e] = t, this.element.val(this._format(n));
        return;
      }

      (e === "max" || e === "min" || e === "step") && typeof t == "string" && (t = this._parse(t)), this._super(e, t), e === "disabled" && (t ? (this.element.prop("disabled", !0), this.buttons.button("disable")) : (this.element.prop("disabled", !1), this.buttons.button("enable")));
    },
    _setOptions: t(function (e) {
      this._super(e), this._value(this.element.val());
    }),
    _parse: function _parse(e) {
      return typeof e == "string" && e !== "" && (e = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(e, 10, this.options.culture) : +e), e === "" || isNaN(e) ? null : e;
    },
    _format: function _format(e) {
      return e === "" ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(e, this.options.numberFormat, this.options.culture) : e;
    },
    _refresh: function _refresh() {
      this.element.attr({
        "aria-valuemin": this.options.min,
        "aria-valuemax": this.options.max,
        "aria-valuenow": this._parse(this.element.val())
      });
    },
    _value: function _value(e, t) {
      var n;
      e !== "" && (n = this._parse(e), n !== null && (t || (n = this._adjustValue(n)), e = this._format(n))), this.element.val(e), this._refresh();
    },
    _destroy: function _destroy() {
      this.element.removeClass("ui-spinner-input").prop("disabled", !1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.uiSpinner.replaceWith(this.element);
    },
    stepUp: t(function (e) {
      this._stepUp(e);
    }),
    _stepUp: function _stepUp(e) {
      this._spin((e || 1) * this.options.step);
    },
    stepDown: t(function (e) {
      this._stepDown(e);
    }),
    _stepDown: function _stepDown(e) {
      this._spin((e || 1) * -this.options.step);
    },
    pageUp: t(function (e) {
      this._stepUp((e || 1) * this.options.page);
    }),
    pageDown: t(function (e) {
      this._stepDown((e || 1) * this.options.page);
    }),
    value: function value(e) {
      if (!arguments.length) return this._parse(this.element.val());
      t(this._value).call(this, e);
    },
    widget: function widget() {
      return this.uiSpinner;
    }
  });
}(jQuery), function (e, t) {
  function i() {
    return ++n;
  }

  function s(e) {
    return e.hash.length > 1 && e.href.replace(r, "") === location.href.replace(r, "").replace(/\s/g, "%20");
  }

  var n = 0,
      r = /#.*$/;
  e.widget("ui.tabs", {
    version: "1.9.2",
    delay: 300,
    options: {
      active: null,
      collapsible: !1,
      event: "click",
      heightStyle: "content",
      hide: null,
      show: null,
      activate: null,
      beforeActivate: null,
      beforeLoad: null,
      load: null
    },
    _create: function _create() {
      var t = this,
          n = this.options,
          r = n.active,
          i = location.hash.substring(1);
      this.running = !1, this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", n.collapsible).delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function (t) {
        e(this).is(".ui-state-disabled") && t.preventDefault();
      }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function () {
        e(this).closest("li").is(".ui-state-disabled") && this.blur();
      }), this._processTabs();

      if (r === null) {
        i && this.tabs.each(function (t, n) {
          if (e(n).attr("aria-controls") === i) return r = t, !1;
        }), r === null && (r = this.tabs.index(this.tabs.filter(".ui-tabs-active")));
        if (r === null || r === -1) r = this.tabs.length ? 0 : !1;
      }

      r !== !1 && (r = this.tabs.index(this.tabs.eq(r)), r === -1 && (r = n.collapsible ? !1 : 0)), n.active = r, !n.collapsible && n.active === !1 && this.anchors.length && (n.active = 0), e.isArray(n.disabled) && (n.disabled = e.unique(n.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"), function (e) {
        return t.tabs.index(e);
      }))).sort()), this.options.active !== !1 && this.anchors.length ? this.active = this._findActive(this.options.active) : this.active = e(), this._refresh(), this.active.length && this.load(n.active);
    },
    _getCreateEventData: function _getCreateEventData() {
      return {
        tab: this.active,
        panel: this.active.length ? this._getPanelForTab(this.active) : e()
      };
    },
    _tabKeydown: function _tabKeydown(t) {
      var n = e(this.document[0].activeElement).closest("li"),
          r = this.tabs.index(n),
          i = !0;
      if (this._handlePageNav(t)) return;

      switch (t.keyCode) {
        case e.ui.keyCode.RIGHT:
        case e.ui.keyCode.DOWN:
          r++;
          break;

        case e.ui.keyCode.UP:
        case e.ui.keyCode.LEFT:
          i = !1, r--;
          break;

        case e.ui.keyCode.END:
          r = this.anchors.length - 1;
          break;

        case e.ui.keyCode.HOME:
          r = 0;
          break;

        case e.ui.keyCode.SPACE:
          t.preventDefault(), clearTimeout(this.activating), this._activate(r);
          return;

        case e.ui.keyCode.ENTER:
          t.preventDefault(), clearTimeout(this.activating), this._activate(r === this.options.active ? !1 : r);
          return;

        default:
          return;
      }

      t.preventDefault(), clearTimeout(this.activating), r = this._focusNextTab(r, i), t.ctrlKey || (n.attr("aria-selected", "false"), this.tabs.eq(r).attr("aria-selected", "true"), this.activating = this._delay(function () {
        this.option("active", r);
      }, this.delay));
    },
    _panelKeydown: function _panelKeydown(t) {
      if (this._handlePageNav(t)) return;
      t.ctrlKey && t.keyCode === e.ui.keyCode.UP && (t.preventDefault(), this.active.focus());
    },
    _handlePageNav: function _handlePageNav(t) {
      if (t.altKey && t.keyCode === e.ui.keyCode.PAGE_UP) return this._activate(this._focusNextTab(this.options.active - 1, !1)), !0;
      if (t.altKey && t.keyCode === e.ui.keyCode.PAGE_DOWN) return this._activate(this._focusNextTab(this.options.active + 1, !0)), !0;
    },
    _findNextTab: function _findNextTab(t, n) {
      function i() {
        return t > r && (t = 0), t < 0 && (t = r), t;
      }

      var r = this.tabs.length - 1;

      while (e.inArray(i(), this.options.disabled) !== -1) {
        t = n ? t + 1 : t - 1;
      }

      return t;
    },
    _focusNextTab: function _focusNextTab(e, t) {
      return e = this._findNextTab(e, t), this.tabs.eq(e).focus(), e;
    },
    _setOption: function _setOption(e, t) {
      if (e === "active") {
        this._activate(t);

        return;
      }

      if (e === "disabled") {
        this._setupDisabled(t);

        return;
      }

      this._super(e, t), e === "collapsible" && (this.element.toggleClass("ui-tabs-collapsible", t), !t && this.options.active === !1 && this._activate(0)), e === "event" && this._setupEvents(t), e === "heightStyle" && this._setupHeightStyle(t);
    },
    _tabId: function _tabId(e) {
      return e.attr("aria-controls") || "ui-tabs-" + i();
    },
    _sanitizeSelector: function _sanitizeSelector(e) {
      return e ? e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
    },
    refresh: function refresh() {
      var t = this.options,
          n = this.tablist.children(":has(a[href])");
      t.disabled = e.map(n.filter(".ui-state-disabled"), function (e) {
        return n.index(e);
      }), this._processTabs(), t.active === !1 || !this.anchors.length ? (t.active = !1, this.active = e()) : this.active.length && !e.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1, this.active = e()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active), this._refresh();
    },
    _refresh: function _refresh() {
      this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
        "aria-selected": "false",
        tabIndex: -1
      }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
        "aria-expanded": "false",
        "aria-hidden": "true"
      }), this.active.length ? (this.active.addClass("ui-tabs-active ui-state-active").attr({
        "aria-selected": "true",
        tabIndex: 0
      }), this._getPanelForTab(this.active).show().attr({
        "aria-expanded": "true",
        "aria-hidden": "false"
      })) : this.tabs.eq(0).attr("tabIndex", 0);
    },
    _processTabs: function _processTabs() {
      var t = this;
      this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist"), this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
        role: "tab",
        tabIndex: -1
      }), this.anchors = this.tabs.map(function () {
        return e("a", this)[0];
      }).addClass("ui-tabs-anchor").attr({
        role: "presentation",
        tabIndex: -1
      }), this.panels = e(), this.anchors.each(function (n, r) {
        var i,
            o,
            u,
            a = e(r).uniqueId().attr("id"),
            f = e(r).closest("li"),
            l = f.attr("aria-controls");
        s(r) ? (i = r.hash, o = t.element.find(t._sanitizeSelector(i))) : (u = t._tabId(f), i = "#" + u, o = t.element.find(i), o.length || (o = t._createPanel(u), o.insertAfter(t.panels[n - 1] || t.tablist)), o.attr("aria-live", "polite")), o.length && (t.panels = t.panels.add(o)), l && f.data("ui-tabs-aria-controls", l), f.attr({
          "aria-controls": i.substring(1),
          "aria-labelledby": a
        }), o.attr("aria-labelledby", a);
      }), this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel");
    },
    _getList: function _getList() {
      return this.element.find("ol,ul").eq(0);
    },
    _createPanel: function _createPanel(t) {
      return e("<div>").attr("id", t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0);
    },
    _setupDisabled: function _setupDisabled(t) {
      e.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1);

      for (var n = 0, r; r = this.tabs[n]; n++) {
        t === !0 || e.inArray(n, t) !== -1 ? e(r).addClass("ui-state-disabled").attr("aria-disabled", "true") : e(r).removeClass("ui-state-disabled").removeAttr("aria-disabled");
      }

      this.options.disabled = t;
    },
    _setupEvents: function _setupEvents(t) {
      var n = {
        click: function click(e) {
          e.preventDefault();
        }
      };
      t && e.each(t.split(" "), function (e, t) {
        n[t] = "_eventHandler";
      }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(this.anchors, n), this._on(this.tabs, {
        keydown: "_tabKeydown"
      }), this._on(this.panels, {
        keydown: "_panelKeydown"
      }), this._focusable(this.tabs), this._hoverable(this.tabs);
    },
    _setupHeightStyle: function _setupHeightStyle(t) {
      var n,
          r,
          i = this.element.parent();
      t === "fill" ? (e.support.minHeight || (r = i.css("overflow"), i.css("overflow", "hidden")), n = i.height(), this.element.siblings(":visible").each(function () {
        var t = e(this),
            r = t.css("position");
        if (r === "absolute" || r === "fixed") return;
        n -= t.outerHeight(!0);
      }), r && i.css("overflow", r), this.element.children().not(this.panels).each(function () {
        n -= e(this).outerHeight(!0);
      }), this.panels.each(function () {
        e(this).height(Math.max(0, n - e(this).innerHeight() + e(this).height()));
      }).css("overflow", "auto")) : t === "auto" && (n = 0, this.panels.each(function () {
        n = Math.max(n, e(this).height("").height());
      }).height(n));
    },
    _eventHandler: function _eventHandler(t) {
      var n = this.options,
          r = this.active,
          i = e(t.currentTarget),
          s = i.closest("li"),
          o = s[0] === r[0],
          u = o && n.collapsible,
          a = u ? e() : this._getPanelForTab(s),
          f = r.length ? this._getPanelForTab(r) : e(),
          l = {
        oldTab: r,
        oldPanel: f,
        newTab: u ? e() : s,
        newPanel: a
      };
      t.preventDefault();
      if (s.hasClass("ui-state-disabled") || s.hasClass("ui-tabs-loading") || this.running || o && !n.collapsible || this._trigger("beforeActivate", t, l) === !1) return;
      n.active = u ? !1 : this.tabs.index(s), this.active = o ? e() : s, this.xhr && this.xhr.abort(), !f.length && !a.length && e.error("jQuery UI Tabs: Mismatching fragment identifier."), a.length && this.load(this.tabs.index(s), t), this._toggle(t, l);
    },
    _toggle: function _toggle(t, n) {
      function o() {
        r.running = !1, r._trigger("activate", t, n);
      }

      function u() {
        n.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), i.length && r.options.show ? r._show(i, r.options.show, o) : (i.show(), o());
      }

      var r = this,
          i = n.newPanel,
          s = n.oldPanel;
      this.running = !0, s.length && this.options.hide ? this._hide(s, this.options.hide, function () {
        n.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), u();
      }) : (n.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), s.hide(), u()), s.attr({
        "aria-expanded": "false",
        "aria-hidden": "true"
      }), n.oldTab.attr("aria-selected", "false"), i.length && s.length ? n.oldTab.attr("tabIndex", -1) : i.length && this.tabs.filter(function () {
        return e(this).attr("tabIndex") === 0;
      }).attr("tabIndex", -1), i.attr({
        "aria-expanded": "true",
        "aria-hidden": "false"
      }), n.newTab.attr({
        "aria-selected": "true",
        tabIndex: 0
      });
    },
    _activate: function _activate(t) {
      var n,
          r = this._findActive(t);

      if (r[0] === this.active[0]) return;
      r.length || (r = this.active), n = r.find(".ui-tabs-anchor")[0], this._eventHandler({
        target: n,
        currentTarget: n,
        preventDefault: e.noop
      });
    },
    _findActive: function _findActive(t) {
      return t === !1 ? e() : this.tabs.eq(t);
    },
    _getIndex: function _getIndex(e) {
      return typeof e == "string" && (e = this.anchors.index(this.anchors.filter("[href$='" + e + "']"))), e;
    },
    _destroy: function _destroy() {
      this.xhr && this.xhr.abort(), this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"), this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"), this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeData("href.tabs").removeData("load.tabs").removeUniqueId(), this.tabs.add(this.panels).each(function () {
        e.data(this, "ui-tabs-destroy") ? e(this).remove() : e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
      }), this.tabs.each(function () {
        var t = e(this),
            n = t.data("ui-tabs-aria-controls");
        n ? t.attr("aria-controls", n) : t.removeAttr("aria-controls");
      }), this.panels.show(), this.options.heightStyle !== "content" && this.panels.css("height", "");
    },
    enable: function enable(n) {
      var r = this.options.disabled;
      if (r === !1) return;
      n === t ? r = !1 : (n = this._getIndex(n), e.isArray(r) ? r = e.map(r, function (e) {
        return e !== n ? e : null;
      }) : r = e.map(this.tabs, function (e, t) {
        return t !== n ? t : null;
      })), this._setupDisabled(r);
    },
    disable: function disable(n) {
      var r = this.options.disabled;
      if (r === !0) return;
      if (n === t) r = !0;else {
        n = this._getIndex(n);
        if (e.inArray(n, r) !== -1) return;
        e.isArray(r) ? r = e.merge([n], r).sort() : r = [n];
      }

      this._setupDisabled(r);
    },
    load: function load(t, n) {
      t = this._getIndex(t);

      var r = this,
          i = this.tabs.eq(t),
          o = i.find(".ui-tabs-anchor"),
          u = this._getPanelForTab(i),
          a = {
        tab: i,
        panel: u
      };

      if (s(o[0])) return;
      this.xhr = e.ajax(this._ajaxSettings(o, n, a)), this.xhr && this.xhr.statusText !== "canceled" && (i.addClass("ui-tabs-loading"), u.attr("aria-busy", "true"), this.xhr.success(function (e) {
        setTimeout(function () {
          u.html(e), r._trigger("load", n, a);
        }, 1);
      }).complete(function (e, t) {
        setTimeout(function () {
          t === "abort" && r.panels.stop(!1, !0), i.removeClass("ui-tabs-loading"), u.removeAttr("aria-busy"), e === r.xhr && delete r.xhr;
        }, 1);
      }));
    },
    _ajaxSettings: function _ajaxSettings(t, n, r) {
      var i = this;
      return {
        url: t.attr("href"),
        beforeSend: function beforeSend(t, s) {
          return i._trigger("beforeLoad", n, e.extend({
            jqXHR: t,
            ajaxSettings: s
          }, r));
        }
      };
    },
    _getPanelForTab: function _getPanelForTab(t) {
      var n = e(t).attr("aria-controls");
      return this.element.find(this._sanitizeSelector("#" + n));
    }
  }), e.uiBackCompat !== !1 && (e.ui.tabs.prototype._ui = function (e, t) {
    return {
      tab: e,
      panel: t,
      index: this.anchors.index(e)
    };
  }, e.widget("ui.tabs", e.ui.tabs, {
    url: function url(e, t) {
      this.anchors.eq(e).attr("href", t);
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      ajaxOptions: null,
      cache: !1
    },
    _create: function _create() {
      this._super();

      var t = this;

      this._on({
        tabsbeforeload: function tabsbeforeload(n, r) {
          if (e.data(r.tab[0], "cache.tabs")) {
            n.preventDefault();
            return;
          }

          r.jqXHR.success(function () {
            t.options.cache && e.data(r.tab[0], "cache.tabs", !0);
          });
        }
      });
    },
    _ajaxSettings: function _ajaxSettings(t, n, r) {
      var i = this.options.ajaxOptions;
      return e.extend({}, i, {
        error: function error(e, t) {
          try {
            i.error(e, t, r.tab.closest("li").index(), r.tab[0]);
          } catch (n) {}
        }
      }, this._superApply(arguments));
    },
    _setOption: function _setOption(e, t) {
      e === "cache" && t === !1 && this.anchors.removeData("cache.tabs"), this._super(e, t);
    },
    _destroy: function _destroy() {
      this.anchors.removeData("cache.tabs"), this._super();
    },
    url: function url(e) {
      this.anchors.eq(e).removeData("cache.tabs"), this._superApply(arguments);
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    abort: function abort() {
      this.xhr && this.xhr.abort();
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      spinner: "<em>Loading&#8230;</em>"
    },
    _create: function _create() {
      this._super(), this._on({
        tabsbeforeload: function tabsbeforeload(e, t) {
          if (e.target !== this.element[0] || !this.options.spinner) return;
          var n = t.tab.find("span"),
              r = n.html();
          n.html(this.options.spinner), t.jqXHR.complete(function () {
            n.html(r);
          });
        }
      });
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      enable: null,
      disable: null
    },
    enable: function enable(t) {
      var n = this.options,
          r;
      if (t && n.disabled === !0 || e.isArray(n.disabled) && e.inArray(t, n.disabled) !== -1) r = !0;
      this._superApply(arguments), r && this._trigger("enable", null, this._ui(this.anchors[t], this.panels[t]));
    },
    disable: function disable(t) {
      var n = this.options,
          r;
      if (t && n.disabled === !1 || e.isArray(n.disabled) && e.inArray(t, n.disabled) === -1) r = !0;
      this._superApply(arguments), r && this._trigger("disable", null, this._ui(this.anchors[t], this.panels[t]));
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      add: null,
      remove: null,
      tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
    },
    add: function add(n, r, i) {
      i === t && (i = this.anchors.length);
      var s,
          o,
          u = this.options,
          a = e(u.tabTemplate.replace(/#\{href\}/g, n).replace(/#\{label\}/g, r)),
          f = n.indexOf("#") ? this._tabId(a) : n.replace("#", "");
      return a.addClass("ui-state-default ui-corner-top").data("ui-tabs-destroy", !0), a.attr("aria-controls", f), s = i >= this.tabs.length, o = this.element.find("#" + f), o.length || (o = this._createPanel(f), s ? i > 0 ? o.insertAfter(this.panels.eq(-1)) : o.appendTo(this.element) : o.insertBefore(this.panels[i])), o.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").hide(), s ? a.appendTo(this.tablist) : a.insertBefore(this.tabs[i]), u.disabled = e.map(u.disabled, function (e) {
        return e >= i ? ++e : e;
      }), this.refresh(), this.tabs.length === 1 && u.active === !1 && this.option("active", 0), this._trigger("add", null, this._ui(this.anchors[i], this.panels[i])), this;
    },
    remove: function remove(t) {
      t = this._getIndex(t);

      var n = this.options,
          r = this.tabs.eq(t).remove(),
          i = this._getPanelForTab(r).remove();

      return r.hasClass("ui-tabs-active") && this.anchors.length > 2 && this._activate(t + (t + 1 < this.anchors.length ? 1 : -1)), n.disabled = e.map(e.grep(n.disabled, function (e) {
        return e !== t;
      }), function (e) {
        return e >= t ? --e : e;
      }), this.refresh(), this._trigger("remove", null, this._ui(r.find("a")[0], i[0])), this;
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    length: function length() {
      return this.anchors.length;
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      idPrefix: "ui-tabs-"
    },
    _tabId: function _tabId(t) {
      var n = t.is("li") ? t.find("a[href]") : t;
      return n = n[0], e(n).closest("li").attr("aria-controls") || n.title && n.title.replace(/\s/g, "_").replace(/[^\w\u00c0-\uFFFF\-]/g, "") || this.options.idPrefix + i();
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      panelTemplate: "<div></div>"
    },
    _createPanel: function _createPanel(t) {
      return e(this.options.panelTemplate).attr("id", t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0);
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    _create: function _create() {
      var e = this.options;
      e.active === null && e.selected !== t && (e.active = e.selected === -1 ? !1 : e.selected), this._super(), e.selected = e.active, e.selected === !1 && (e.selected = -1);
    },
    _setOption: function _setOption(e, t) {
      if (e !== "selected") return this._super(e, t);
      var n = this.options;
      this._super("active", t === -1 ? !1 : t), n.selected = n.active, n.selected === !1 && (n.selected = -1);
    },
    _eventHandler: function _eventHandler() {
      this._superApply(arguments), this.options.selected = this.options.active, this.options.selected === !1 && (this.options.selected = -1);
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      show: null,
      select: null
    },
    _create: function _create() {
      this._super(), this.options.active !== !1 && this._trigger("show", null, this._ui(this.active.find(".ui-tabs-anchor")[0], this._getPanelForTab(this.active)[0]));
    },
    _trigger: function _trigger(e, t, n) {
      var r,
          i,
          s = this._superApply(arguments);

      return s ? (e === "beforeActivate" ? (r = n.newTab.length ? n.newTab : n.oldTab, i = n.newPanel.length ? n.newPanel : n.oldPanel, s = this._super("select", t, {
        tab: r.find(".ui-tabs-anchor")[0],
        panel: i[0],
        index: r.closest("li").index()
      })) : e === "activate" && n.newTab.length && (s = this._super("show", t, {
        tab: n.newTab.find(".ui-tabs-anchor")[0],
        panel: n.newPanel[0],
        index: n.newTab.closest("li").index()
      })), s) : !1;
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    select: function select(e) {
      e = this._getIndex(e);

      if (e === -1) {
        if (!this.options.collapsible || this.options.selected === -1) return;
        e = this.options.selected;
      }

      this.anchors.eq(e).trigger(this.options.event + this.eventNamespace);
    }
  }), function () {
    var t = 0;
    e.widget("ui.tabs", e.ui.tabs, {
      options: {
        cookie: null
      },
      _create: function _create() {
        var e = this.options,
            t;
        e.active == null && e.cookie && (t = parseInt(this._cookie(), 10), t === -1 && (t = !1), e.active = t), this._super();
      },
      _cookie: function _cookie(n) {
        var r = [this.cookie || (this.cookie = this.options.cookie.name || "ui-tabs-" + ++t)];
        return arguments.length && (r.push(n === !1 ? -1 : n), r.push(this.options.cookie)), e.cookie.apply(null, r);
      },
      _refresh: function _refresh() {
        this._super(), this.options.cookie && this._cookie(this.options.active, this.options.cookie);
      },
      _eventHandler: function _eventHandler() {
        this._superApply(arguments), this.options.cookie && this._cookie(this.options.active, this.options.cookie);
      },
      _destroy: function _destroy() {
        this._super(), this.options.cookie && this._cookie(null, this.options.cookie);
      }
    });
  }(), e.widget("ui.tabs", e.ui.tabs, {
    _trigger: function _trigger(t, n, r) {
      var i = e.extend({}, r);
      return t === "load" && (i.panel = i.panel[0], i.tab = i.tab.find(".ui-tabs-anchor")[0]), this._super(t, n, i);
    }
  }), e.widget("ui.tabs", e.ui.tabs, {
    options: {
      fx: null
    },
    _getFx: function _getFx() {
      var t,
          n,
          r = this.options.fx;
      return r && (e.isArray(r) ? (t = r[0], n = r[1]) : t = n = r), r ? {
        show: n,
        hide: t
      } : null;
    },
    _toggle: function _toggle(e, t) {
      function o() {
        n.running = !1, n._trigger("activate", e, t);
      }

      function u() {
        t.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), r.length && s.show ? r.animate(s.show, s.show.duration, function () {
          o();
        }) : (r.show(), o());
      }

      var n = this,
          r = t.newPanel,
          i = t.oldPanel,
          s = this._getFx();

      if (!s) return this._super(e, t);
      n.running = !0, i.length && s.hide ? i.animate(s.hide, s.hide.duration, function () {
        t.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), u();
      }) : (t.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), i.hide(), u());
    }
  }));
}(jQuery), function (e) {
  function n(t, n) {
    var r = (t.attr("aria-describedby") || "").split(/\s+/);
    r.push(n), t.data("ui-tooltip-id", n).attr("aria-describedby", e.trim(r.join(" ")));
  }

  function r(t) {
    var n = t.data("ui-tooltip-id"),
        r = (t.attr("aria-describedby") || "").split(/\s+/),
        i = e.inArray(n, r);
    i !== -1 && r.splice(i, 1), t.removeData("ui-tooltip-id"), r = e.trim(r.join(" ")), r ? t.attr("aria-describedby", r) : t.removeAttr("aria-describedby");
  }

  var t = 0;
  e.widget("ui.tooltip", {
    version: "1.9.2",
    options: {
      content: function content() {
        return e(this).attr("title");
      },
      hide: !0,
      items: "[title]:not([disabled])",
      position: {
        my: "left top+15",
        at: "left bottom",
        collision: "flipfit flip"
      },
      show: !0,
      tooltipClass: null,
      track: !1,
      close: null,
      open: null
    },
    _create: function _create() {
      this._on({
        mouseover: "open",
        focusin: "open"
      }), this.tooltips = {}, this.parents = {}, this.options.disabled && this._disable();
    },
    _setOption: function _setOption(t, n) {
      var r = this;

      if (t === "disabled") {
        this[n ? "_disable" : "_enable"](), this.options[t] = n;
        return;
      }

      this._super(t, n), t === "content" && e.each(this.tooltips, function (e, t) {
        r._updateContent(t);
      });
    },
    _disable: function _disable() {
      var t = this;
      e.each(this.tooltips, function (n, r) {
        var i = e.Event("blur");
        i.target = i.currentTarget = r[0], t.close(i, !0);
      }), this.element.find(this.options.items).andSelf().each(function () {
        var t = e(this);
        t.is("[title]") && t.data("ui-tooltip-title", t.attr("title")).attr("title", "");
      });
    },
    _enable: function _enable() {
      this.element.find(this.options.items).andSelf().each(function () {
        var t = e(this);
        t.data("ui-tooltip-title") && t.attr("title", t.data("ui-tooltip-title"));
      });
    },
    open: function open(t) {
      var n = this,
          r = e(t ? t.target : this.element).closest(this.options.items);
      if (!r.length || r.data("ui-tooltip-id")) return;
      r.attr("title") && r.data("ui-tooltip-title", r.attr("title")), r.data("ui-tooltip-open", !0), t && t.type === "mouseover" && r.parents().each(function () {
        var t = e(this),
            r;
        t.data("ui-tooltip-open") && (r = e.Event("blur"), r.target = r.currentTarget = this, n.close(r, !0)), t.attr("title") && (t.uniqueId(), n.parents[this.id] = {
          element: this,
          title: t.attr("title")
        }, t.attr("title", ""));
      }), this._updateContent(r, t);
    },
    _updateContent: function _updateContent(e, t) {
      var n,
          r = this.options.content,
          i = this,
          s = t ? t.type : null;
      if (typeof r == "string") return this._open(t, e, r);
      n = r.call(e[0], function (n) {
        if (!e.data("ui-tooltip-open")) return;

        i._delay(function () {
          t && (t.type = s), this._open(t, e, n);
        });
      }), n && this._open(t, e, n);
    },
    _open: function _open(t, r, i) {
      function f(e) {
        a.of = e;
        if (s.is(":hidden")) return;
        s.position(a);
      }

      var s,
          o,
          u,
          a = e.extend({}, this.options.position);
      if (!i) return;
      s = this._find(r);

      if (s.length) {
        s.find(".ui-tooltip-content").html(i);
        return;
      }

      r.is("[title]") && (t && t.type === "mouseover" ? r.attr("title", "") : r.removeAttr("title")), s = this._tooltip(r), n(r, s.attr("id")), s.find(".ui-tooltip-content").html(i), this.options.track && t && /^mouse/.test(t.type) ? (this._on(this.document, {
        mousemove: f
      }), f(t)) : s.position(e.extend({
        of: r
      }, this.options.position)), s.hide(), this._show(s, this.options.show), this.options.show && this.options.show.delay && (u = setInterval(function () {
        s.is(":visible") && (f(a.of), clearInterval(u));
      }, e.fx.interval)), this._trigger("open", t, {
        tooltip: s
      }), o = {
        keyup: function keyup(t) {
          if (t.keyCode === e.ui.keyCode.ESCAPE) {
            var n = e.Event(t);
            n.currentTarget = r[0], this.close(n, !0);
          }
        },
        remove: function remove() {
          this._removeTooltip(s);
        }
      };
      if (!t || t.type === "mouseover") o.mouseleave = "close";
      if (!t || t.type === "focusin") o.focusout = "close";

      this._on(!0, r, o);
    },
    close: function close(t) {
      var n = this,
          i = e(t ? t.currentTarget : this.element),
          s = this._find(i);

      if (this.closing) return;
      i.data("ui-tooltip-title") && i.attr("title", i.data("ui-tooltip-title")), r(i), s.stop(!0), this._hide(s, this.options.hide, function () {
        n._removeTooltip(e(this));
      }), i.removeData("ui-tooltip-open"), this._off(i, "mouseleave focusout keyup"), i[0] !== this.element[0] && this._off(i, "remove"), this._off(this.document, "mousemove"), t && t.type === "mouseleave" && e.each(this.parents, function (t, r) {
        e(r.element).attr("title", r.title), delete n.parents[t];
      }), this.closing = !0, this._trigger("close", t, {
        tooltip: s
      }), this.closing = !1;
    },
    _tooltip: function _tooltip(n) {
      var r = "ui-tooltip-" + t++,
          i = e("<div>").attr({
        id: r,
        role: "tooltip"
      }).addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || ""));
      return e("<div>").addClass("ui-tooltip-content").appendTo(i), i.appendTo(this.document[0].body), e.fn.bgiframe && i.bgiframe(), this.tooltips[r] = n, i;
    },
    _find: function _find(t) {
      var n = t.data("ui-tooltip-id");
      return n ? e("#" + n) : e();
    },
    _removeTooltip: function _removeTooltip(e) {
      e.remove(), delete this.tooltips[e.attr("id")];
    },
    _destroy: function _destroy() {
      var t = this;
      e.each(this.tooltips, function (n, r) {
        var i = e.Event("blur");
        i.target = i.currentTarget = r[0], t.close(i, !0), e("#" + n).remove(), r.data("ui-tooltip-title") && (r.attr("title", r.data("ui-tooltip-title")), r.removeData("ui-tooltip-title"));
      });
    }
  });
}(jQuery);

/***/ }),

/***/ "./resources/js/flipbook/jquery.js":
/*!*****************************************!*\
  !*** ./resources/js/flipbook/jquery.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * jQuery JavaScript Library v1.8.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
 */
(function (window, undefined) {
  var // A central reference to the root jQuery(document)
  rootjQuery,
      // The deferred used on DOM ready
  readyList,
      // Use the correct document accordingly with window argument (sandbox)
  document = window.document,
      location = window.location,
      navigator = window.navigator,
      // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$,
      // Save a reference to some core methods
  core_push = Array.prototype.push,
      core_slice = Array.prototype.slice,
      core_indexOf = Array.prototype.indexOf,
      core_toString = Object.prototype.toString,
      core_hasOwn = Object.prototype.hasOwnProperty,
      core_trim = String.prototype.trim,
      // Define a local copy of jQuery
  jQuery = function jQuery(selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    return new jQuery.fn.init(selector, context, rootjQuery);
  },
      // Used for matching numbers
  core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,
      // Used for detecting and trimming whitespace
  core_rnotwhite = /\S/,
      core_rspace = /\s+/,
      // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
      // Match a standalone tag
  rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      // JSON RegExp
  rvalidchars = /^[\],:{}\s]*$/,
      rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
      rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
      rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,
      // Matches dashed string for camelizing
  rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      // Used by jQuery.camelCase as callback to replace()
  fcamelCase = function fcamelCase(all, letter) {
    return (letter + "").toUpperCase();
  },
      // The ready event handler and self cleanup method
  DOMContentLoaded = function DOMContentLoaded() {
    if (document.addEventListener) {
      document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
      jQuery.ready();
    } else if (document.readyState === "complete") {
      // we're here because readyState === "complete" in oldIE
      // which is good enough for us to call the dom ready!
      document.detachEvent("onreadystatechange", DOMContentLoaded);
      jQuery.ready();
    }
  },
      // [[Class]] -> type pairs
  class2type = {};

  jQuery.fn = jQuery.prototype = {
    constructor: jQuery,
    init: function init(selector, context, rootjQuery) {
      var match, elem, ret, doc; // Handle $(""), $(null), $(undefined), $(false)

      if (!selector) {
        return this;
      } // Handle $(DOMElement)


      if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } // Handle HTML strings


      if (typeof selector === "string") {
        if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        } // Match html or make sure no context is specified for #id


        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            doc = context && context.nodeType ? context.ownerDocument || context : document; // scripts is true for back-compat

            selector = jQuery.parseHTML(match[1], doc, true);

            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              this.attr.call(selector, context, true);
            }

            return jQuery.merge(this, selector); // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]); // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963

            if (elem && elem.parentNode) {
              // Handle the case where IE and Opera return items
              // by name instead of ID
              if (elem.id !== match[2]) {
                return rootjQuery.find(selector);
              } // Otherwise, we inject the element directly into the jQuery object


              this.length = 1;
              this[0] = elem;
            }

            this.context = document;
            this.selector = selector;
            return this;
          } // HANDLE: $(expr, $(...))

        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector); // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        } // HANDLE: $(function)
        // Shortcut for document ready

      } else if (jQuery.isFunction(selector)) {
        return rootjQuery.ready(selector);
      }

      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }

      return jQuery.makeArray(selector, this);
    },
    // Start with an empty selector
    selector: "",
    // The current version of jQuery being used
    jquery: "1.8.3",
    // The default length of a jQuery object is 0
    length: 0,
    // The number of elements contained in the matched element set
    size: function size() {
      return this.length;
    },
    toArray: function toArray() {
      return core_slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function get(num) {
      return num == null ? // Return a 'clean' array
      this.toArray() : // Return just the object
      num < 0 ? this[this.length + num] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function pushStack(elems, name, selector) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this;
      ret.context = this.context;

      if (name === "find") {
        ret.selector = this.selector + (this.selector ? " " : "") + selector;
      } else if (name) {
        ret.selector = this.selector + "." + name + "(" + selector + ")";
      } // Return the newly-formed element set


      return ret;
    },
    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function each(callback, args) {
      return jQuery.each(this, callback, args);
    },
    ready: function ready(fn) {
      // Add the callback
      jQuery.ready.promise().done(fn);
      return this;
    },
    eq: function eq(i) {
      i = +i;
      return i === -1 ? this.slice(i) : this.slice(i, i + 1);
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    slice: function slice() {
      return this.pushStack(core_slice.apply(this, arguments), "slice", core_slice.call(arguments).join(","));
    },
    map: function map(callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    end: function end() {
      return this.prevObject || this.constructor(null);
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: core_push,
    sort: [].sort,
    splice: [].splice
  }; // Give the init function the jQuery prototype for later instantiation

  jQuery.fn.init.prototype = jQuery.fn;

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {}; // skip the boolean and the target

      i = 2;
    } // Handle case when target is a string or something (possible in deep copy)


    if (_typeof(target) !== "object" && !jQuery.isFunction(target)) {
      target = {};
    } // extend jQuery itself if only one argument is passed


    if (length === i) {
      target = this;
      --i;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name]; // Prevent never-ending loop

          if (target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            } // Never move original objects, clone them


            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    noConflict: function noConflict(deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }

      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }

      return jQuery;
    },
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Hold (or release) the ready event
    holdReady: function holdReady(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    // Handle when the DOM is ready
    ready: function ready(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).


      if (!document.body) {
        return setTimeout(jQuery.ready, 1);
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]); // Trigger any bound ready events

      if (jQuery.fn.trigger) {
        jQuery(document).trigger("ready").off("ready");
      }
    },
    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function isFunction(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray || function (obj) {
      return jQuery.type(obj) === "array";
    },
    isWindow: function isWindow(obj) {
      return obj != null && obj == obj.window;
    },
    isNumeric: function isNumeric(obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },
    type: function type(obj) {
      return obj == null ? String(obj) : class2type[core_toString.call(obj)] || "object";
    },
    isPlainObject: function isPlainObject(obj) {
      // Must be an Object.
      // Because of IE, we also have to check the presence of the constructor property.
      // Make sure that DOM nodes and window objects don't pass through, as well
      if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }

      try {
        // Not own constructor property must be Object
        if (obj.constructor && !core_hasOwn.call(obj, "constructor") && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
          return false;
        }
      } catch (e) {
        // IE8,9 Will throw exceptions on certain host objects #9897
        return false;
      } // Own properties are enumerated firstly, so to speed up,
      // if last one is own, then all properties are own.


      var key;

      for (key in obj) {}

      return key === undefined || core_hasOwn.call(obj, key);
    },
    isEmptyObject: function isEmptyObject(obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    error: function error(msg) {
      throw new Error(msg);
    },
    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // scripts (optional): If true, will include scripts passed in the html string
    parseHTML: function parseHTML(data, context, scripts) {
      var parsed;

      if (!data || typeof data !== "string") {
        return null;
      }

      if (typeof context === "boolean") {
        scripts = context;
        context = 0;
      }

      context = context || document; // Single tag

      if (parsed = rsingleTag.exec(data)) {
        return [context.createElement(parsed[1])];
      }

      parsed = jQuery.buildFragment([data], context, scripts ? null : []);
      return jQuery.merge([], (parsed.cacheable ? jQuery.clone(parsed.fragment) : parsed.fragment).childNodes);
    },
    parseJSON: function parseJSON(data) {
      if (!data || typeof data !== "string") {
        return null;
      } // Make sure leading/trailing whitespace is removed (IE can't handle it)


      data = jQuery.trim(data); // Attempt to parse using the native JSON parser first

      if (window.JSON && window.JSON.parse) {
        return window.JSON.parse(data);
      } // Make sure the incoming data is actual JSON
      // Logic borrowed from http://json.org/json2.js


      if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {
        return new Function("return " + data)();
      }

      jQuery.error("Invalid JSON: " + data);
    },
    // Cross-browser xml parsing
    parseXML: function parseXML(data) {
      var xml, tmp;

      if (!data || typeof data !== "string") {
        return null;
      }

      try {
        if (window.DOMParser) {
          // Standard
          tmp = new DOMParser();
          xml = tmp.parseFromString(data, "text/xml");
        } else {
          // IE
          xml = new ActiveXObject("Microsoft.XMLDOM");
          xml.async = "false";
          xml.loadXML(data);
        }
      } catch (e) {
        xml = undefined;
      }

      if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
        jQuery.error("Invalid XML: " + data);
      }

      return xml;
    },
    noop: function noop() {},
    // Evaluates a script in a global context
    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function globalEval(data) {
      if (data && core_rnotwhite.test(data)) {
        // We use execScript on Internet Explorer
        // We use an anonymous function so that context is window
        // rather than jQuery in Firefox
        (window.execScript || function (data) {
          window["eval"].call(window, data);
        })(data);
      }
    },
    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    // args is for internal usage only
    each: function each(obj, callback, args) {
      var name,
          i = 0,
          length = obj.length,
          isObj = length === undefined || jQuery.isFunction(obj);

      if (args) {
        if (isObj) {
          for (name in obj) {
            if (callback.apply(obj[name], args) === false) {
              break;
            }
          }
        } else {
          for (; i < length;) {
            if (callback.apply(obj[i++], args) === false) {
              break;
            }
          }
        } // A special, fast, case for the most common use of each

      } else {
        if (isObj) {
          for (name in obj) {
            if (callback.call(obj[name], name, obj[name]) === false) {
              break;
            }
          }
        } else {
          for (; i < length;) {
            if (callback.call(obj[i], i, obj[i++]) === false) {
              break;
            }
          }
        }
      }

      return obj;
    },
    // Use native String.trim function wherever possible
    trim: core_trim && !core_trim.call("\uFEFF\xA0") ? function (text) {
      return text == null ? "" : core_trim.call(text);
    } : // Otherwise use our own trimming functionality
    function (text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    // results is for internal usage only
    makeArray: function makeArray(arr, results) {
      var type,
          ret = results || [];

      if (arr != null) {
        // The window, strings (and functions) also have 'length'
        // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
        type = jQuery.type(arr);

        if (arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(arr)) {
          core_push.call(ret, arr);
        } else {
          jQuery.merge(ret, arr);
        }
      }

      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      var len;

      if (arr) {
        if (core_indexOf) {
          return core_indexOf.call(arr, elem, i);
        }

        len = arr.length;
        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

        for (; i < len; i++) {
          // Skip accessing in sparse arrays
          if (i in arr && arr[i] === elem) {
            return i;
          }
        }
      }

      return -1;
    },
    merge: function merge(first, second) {
      var l = second.length,
          i = first.length,
          j = 0;

      if (typeof l === "number") {
        for (; j < l; j++) {
          first[i++] = second[j];
        }
      } else {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }

      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, inv) {
      var retVal,
          ret = [],
          i = 0,
          length = elems.length;
      inv = !!inv; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        retVal = !!callback(elems[i], i);

        if (inv !== retVal) {
          ret.push(elems[i]);
        }
      }

      return ret;
    },
    // arg is for internal usage only
    map: function map(elems, callback, arg) {
      var value,
          key,
          ret = [],
          i = 0,
          length = elems.length,
          // jquery objects are treated as arrays
      isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && (length > 0 && elems[0] && elems[length - 1] || length === 0 || jQuery.isArray(elems)); // Go through the array, translating each of the items to their

      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret[ret.length] = value;
          }
        } // Go through every key on the object,

      } else {
        for (key in elems) {
          value = callback(elems[key], key, arg);

          if (value != null) {
            ret[ret.length] = value;
          }
        }
      } // Flatten any nested arrays


      return ret.concat.apply([], ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function proxy(fn, context) {
      var tmp, args, proxy;

      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      } // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.


      if (!jQuery.isFunction(fn)) {
        return undefined;
      } // Simulated bind


      args = core_slice.call(arguments, 2);

      proxy = function proxy() {
        return fn.apply(context, args.concat(core_slice.call(arguments)));
      }; // Set the guid of unique handler to the same of original handler, so it can be removed


      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    access: function access(elems, fn, key, value, chainable, emptyGet, pass) {
      var exec,
          bulk = key == null,
          i = 0,
          length = elems.length; // Sets many values

      if (key && _typeof(key) === "object") {
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], 1, emptyGet, value);
        }

        chainable = 1; // Sets one value
      } else if (value !== undefined) {
        // Optionally, function values get executed if exec is true
        exec = pass === undefined && jQuery.isFunction(value);

        if (bulk) {
          // Bulk operations only iterate when executing function values
          if (exec) {
            exec = fn;

            fn = function fn(elem, key, value) {
              return exec.call(jQuery(elem), value);
            }; // Otherwise they run against the entire set

          } else {
            fn.call(elems, value);
            fn = null;
          }
        }

        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
          }
        }

        chainable = 1;
      }

      return chainable ? elems : // Gets
      bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    },
    now: function now() {
      return new Date().getTime();
    }
  });

  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred.
      // we once tried to use readyState "interactive" here, but it caused issues like the one
      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15

      if (document.readyState === "complete") {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        setTimeout(jQuery.ready, 1); // Standards-based browsers support DOMContentLoaded
      } else if (document.addEventListener) {
        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", DOMContentLoaded, false); // A fallback to window.onload, that will always work

        window.addEventListener("load", jQuery.ready, false); // If IE event model is used
      } else {
        // Ensure firing before onload, maybe late but safe also for iframes
        document.attachEvent("onreadystatechange", DOMContentLoaded); // A fallback to window.onload, that will always work

        window.attachEvent("onload", jQuery.ready); // If IE and not a frame
        // continually check to see if the document is ready

        var top = false;

        try {
          top = window.frameElement == null && document.documentElement;
        } catch (e) {}

        if (top && top.doScroll) {
          (function doScrollCheck() {
            if (!jQuery.isReady) {
              try {
                // Use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                top.doScroll("left");
              } catch (e) {
                return setTimeout(doScrollCheck, 50);
              } // and execute any waiting functions


              jQuery.ready();
            }
          })();
        }
      }
    }

    return readyList.promise(obj);
  }; // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  }); // All jQuery objects should point back to these

  rootjQuery = jQuery(document); // String to Object options format cache

  var optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache

  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.split(core_rspace), function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);

    var // Last fire value (for non-forgettable lists)
    memory,
        // Flag to know if list was already fired
    _fired,
        // Flag to know if list is currently firing
    firing,
        // First callback to fire (used internally by add and fireWith)
    firingStart,
        // End of the loop when firing
    firingLength,
        // Index of currently firing callback (modified by remove if needed)
    firingIndex,
        // Actual callback list
    list = [],
        // Stack of fire calls for repeatable lists
    stack = !options.once && [],
        // Fire callbacks
    fire = function fire(data) {
      memory = options.memory && data;
      _fired = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      firing = true;

      for (; list && firingIndex < firingLength; firingIndex++) {
        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
          memory = false; // To prevent further calls using add

          break;
        }
      }

      firing = false;

      if (list) {
        if (stack) {
          if (stack.length) {
            fire(stack.shift());
          }
        } else if (memory) {
          list = [];
        } else {
          self.disable();
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function add() {
        if (list) {
          // First, we save the current length
          var start = list.length;

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              var type = jQuery.type(arg);

              if (type === "function") {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && type !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments); // Do we need to add the callbacks to the
          // current firing batch?


          if (firing) {
            firingLength = list.length; // With memory, if we're not firing then
            // we should call right away
          } else if (memory) {
            firingStart = start;
            fire(memory);
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function remove() {
        if (list) {
          jQuery.each(arguments, function (_, arg) {
            var index;

            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1); // Handle firing indexes

              if (firing) {
                if (index <= firingLength) {
                  firingLength--;
                }

                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            }
          });
        }

        return this;
      },
      // Control if a given callback is in the list
      has: function has(fn) {
        return jQuery.inArray(fn, list) > -1;
      },
      // Remove all callbacks from the list
      empty: function empty() {
        list = [];
        return this;
      },
      // Have the list do nothing anymore
      disable: function disable() {
        list = stack = memory = undefined;
        return this;
      },
      // Is it disabled?
      disabled: function disabled() {
        return !list;
      },
      // Lock the list in its current state
      lock: function lock() {
        stack = undefined;

        if (!memory) {
          self.disable();
        }

        return this;
      },
      // Is it locked?
      locked: function locked() {
        return !stack;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function fireWith(context, args) {
        args = args || [];
        args = [context, args.slice ? args.slice() : args];

        if (list && (!_fired || stack)) {
          if (firing) {
            stack.push(args);
          } else {
            fire(args);
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function fire() {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function fired() {
        return !!_fired;
      }
    };

    return self;
  };

  jQuery.extend({
    Deferred: function Deferred(func) {
      var tuples = [// action, add listener, listener list, final state
      ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          _state = "pending",
          _promise = {
        state: function state() {
          return _state;
        },
        always: function always() {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        then: function then()
        /* fnDone, fnFail, fnProgress */
        {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (i, tuple) {
              var action = tuple[0],
                  fn = fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer

              deferred[tuple[1]](jQuery.isFunction(fn) ? function () {
                var returned = fn.apply(this, arguments);

                if (returned && jQuery.isFunction(returned.promise)) {
                  returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                } else {
                  newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
                }
              } : newDefer[action]);
            });
            fns = null;
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function promise(obj) {
          return obj != null ? jQuery.extend(obj, _promise) : _promise;
        }
      },
          deferred = {}; // Keep pipe for back-compat

      _promise.pipe = _promise.then; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[3]; // promise[ done | fail | progress ] = list.add

        _promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = [ resolved | rejected ]
            _state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        } // deferred[ resolve | reject | notify ] = list.fire


        deferred[tuple[0]] = list.fire;
        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      _promise.promise(deferred); // Call given func if any


      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function when(subordinate
    /* , ..., subordinateN */
    ) {
      var i = 0,
          resolveValues = core_slice.call(arguments),
          length = resolveValues.length,
          // the count of uncompleted subordinates
      remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
          // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          // Update function for both resolve and progress values
      updateFunc = function updateFunc(i, contexts, values) {
        return function (value) {
          contexts[i] = this;
          values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;

          if (values === progressValues) {
            deferred.notifyWith(contexts, values);
          } else if (! --remaining) {
            deferred.resolveWith(contexts, values);
          }
        };
      },
          progressValues,
          progressContexts,
          resolveContexts; // add listeners to Deferred subordinates; treat others as resolved


      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);

        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      } // if we're not waiting on anything, resolve the master


      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }

      return deferred.promise();
    }
  });

  jQuery.support = function () {
    var support,
        all,
        a,
        select,
        opt,
        input,
        fragment,
        eventName,
        i,
        isSupported,
        clickFn,
        div = document.createElement("div"); // Setup

    div.setAttribute("className", "t");
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>"; // Support tests won't run in some limited or non-browser environments

    all = div.getElementsByTagName("*");
    a = div.getElementsByTagName("a")[0];

    if (!all || !a || !all.length) {
      return {};
    } // First batch of tests


    select = document.createElement("select");
    opt = select.appendChild(document.createElement("option"));
    input = div.getElementsByTagName("input")[0];
    a.style.cssText = "top:1px;float:left;opacity:.5";
    support = {
      // IE strips leading whitespace when .innerHTML is used
      leadingWhitespace: div.firstChild.nodeType === 3,
      // Make sure that tbody elements aren't automatically inserted
      // IE will insert them into empty tables
      tbody: !div.getElementsByTagName("tbody").length,
      // Make sure that link elements get serialized correctly by innerHTML
      // This requires a wrapper element in IE
      htmlSerialize: !!div.getElementsByTagName("link").length,
      // Get the style information from getAttribute
      // (IE uses .cssText instead)
      style: /top/.test(a.getAttribute("style")),
      // Make sure that URLs aren't manipulated
      // (IE normalizes it by default)
      hrefNormalized: a.getAttribute("href") === "/a",
      // Make sure that element opacity exists
      // (IE uses filter instead)
      // Use a regex to work around a WebKit issue. See #5145
      opacity: /^0.5/.test(a.style.opacity),
      // Verify style float existence
      // (IE uses styleFloat instead of cssFloat)
      cssFloat: !!a.style.cssFloat,
      // Make sure that if no value is specified for a checkbox
      // that it defaults to "on".
      // (WebKit defaults to "" instead)
      checkOn: input.value === "on",
      // Make sure that a selected-by-default option has a working selected property.
      // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
      optSelected: opt.selected,
      // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
      getSetAttribute: div.className !== "t",
      // Tests for enctype support on a form (#6743)
      enctype: !!document.createElement("form").enctype,
      // Makes sure cloning an html5 element does not cause problems
      // Where outerHTML is undefined, this still works
      html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",
      // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
      boxModel: document.compatMode === "CSS1Compat",
      // Will be defined later
      submitBubbles: true,
      changeBubbles: true,
      focusinBubbles: false,
      deleteExpando: true,
      noCloneEvent: true,
      inlineBlockNeedsLayout: false,
      shrinkWrapBlocks: false,
      reliableMarginRight: true,
      boxSizingReliable: true,
      pixelPosition: false
    }; // Make sure checked status is properly cloned

    input.checked = true;
    support.noCloneChecked = input.cloneNode(true).checked; // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)

    select.disabled = true;
    support.optDisabled = !opt.disabled; // Test to see if it's possible to delete an expando from an element
    // Fails in Internet Explorer

    try {
      delete div.test;
    } catch (e) {
      support.deleteExpando = false;
    }

    if (!div.addEventListener && div.attachEvent && div.fireEvent) {
      div.attachEvent("onclick", clickFn = function clickFn() {
        // Cloning a node shouldn't copy over any
        // bound event handlers (IE does this)
        support.noCloneEvent = false;
      });
      div.cloneNode(true).fireEvent("onclick");
      div.detachEvent("onclick", clickFn);
    } // Check if a radio maintains its value
    // after being appended to the DOM


    input = document.createElement("input");
    input.value = "t";
    input.setAttribute("type", "radio");
    support.radioValue = input.value === "t";
    input.setAttribute("checked", "checked"); // #11217 - WebKit loses check when the name is after the checked attribute

    input.setAttribute("name", "t");
    div.appendChild(input);
    fragment = document.createDocumentFragment();
    fragment.appendChild(div.lastChild); // WebKit doesn't clone checked state correctly in fragments

    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked; // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)

    support.appendChecked = input.checked;
    fragment.removeChild(input);
    fragment.appendChild(div); // Technique from Juriy Zaytsev
    // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
    // We only care about the case where non-standard event systems
    // are used, namely in IE. Short-circuiting here helps us to
    // avoid an eval call (in setAttribute) which can cause CSP
    // to go haywire. See: https://developer.mozilla.org/en/Security/CSP

    if (div.attachEvent) {
      for (i in {
        submit: true,
        change: true,
        focusin: true
      }) {
        eventName = "on" + i;
        isSupported = eventName in div;

        if (!isSupported) {
          div.setAttribute(eventName, "return;");
          isSupported = typeof div[eventName] === "function";
        }

        support[i + "Bubbles"] = isSupported;
      }
    } // Run tests that need a body at doc ready


    jQuery(function () {
      var container,
          div,
          tds,
          marginDiv,
          divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
          body = document.getElementsByTagName("body")[0];

      if (!body) {
        // Return for frameset docs that don't have a body
        return;
      }

      container = document.createElement("div");
      container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
      body.insertBefore(container, body.firstChild); // Construct the test element

      div = document.createElement("div");
      container.appendChild(div); // Check if table cells still have offsetWidth/Height when they are set
      // to display:none and there are still other visible table cells in a
      // table row; if so, offsetWidth/Height are not reliable for use when
      // determining if an element has been hidden directly using
      // display:none (it is still safe to use offsets if a parent element is
      // hidden; don safety goggles and see bug #4512 for more information).
      // (only IE 8 fails this test)

      div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
      tds = div.getElementsByTagName("td");
      tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
      isSupported = tds[0].offsetHeight === 0;
      tds[0].style.display = "";
      tds[1].style.display = "none"; // Check if empty table cells still have offsetWidth/Height
      // (IE <= 8 fail this test)

      support.reliableHiddenOffsets = isSupported && tds[0].offsetHeight === 0; // Check box-sizing and margin behavior

      div.innerHTML = "";
      div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
      support.boxSizing = div.offsetWidth === 4;
      support.doesNotIncludeMarginInBodyOffset = body.offsetTop !== 1; // NOTE: To any future maintainer, we've window.getComputedStyle
      // because jsdom on node.js will break without it.

      if (window.getComputedStyle) {
        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
        support.boxSizingReliable = (window.getComputedStyle(div, null) || {
          width: "4px"
        }).width === "4px"; // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. For more
        // info see bug #3333
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right

        marginDiv = document.createElement("div");
        marginDiv.style.cssText = div.style.cssText = divReset;
        marginDiv.style.marginRight = marginDiv.style.width = "0";
        div.style.width = "1px";
        div.appendChild(marginDiv);
        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
      }

      if (typeof div.style.zoom !== "undefined") {
        // Check if natively block-level elements act like inline-block
        // elements when setting their display to 'inline' and giving
        // them layout
        // (IE < 8 does this)
        div.innerHTML = "";
        div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
        support.inlineBlockNeedsLayout = div.offsetWidth === 3; // Check if elements with layout shrink-wrap their children
        // (IE 6 does this)

        div.style.display = "block";
        div.style.overflow = "visible";
        div.innerHTML = "<div></div>";
        div.firstChild.style.width = "5px";
        support.shrinkWrapBlocks = div.offsetWidth !== 3;
        container.style.zoom = 1;
      } // Null elements to avoid leaks in IE


      body.removeChild(container);
      container = div = tds = marginDiv = null;
    }); // Null elements to avoid leaks in IE

    fragment.removeChild(div);
    all = a = select = opt = input = fragment = div = null;
    return support;
  }();

  var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
      rmultiDash = /([A-Z])/g;
  jQuery.extend({
    cache: {},
    deletedIds: [],
    // Remove at next major release (1.9/2.0)
    uuid: 0,
    // Unique for each copy of jQuery on the page
    // Non-digits removed to match rinlinejQuery
    expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),
    // The following elements throw uncatchable exceptions if you
    // attempt to add expando properties to them.
    noData: {
      "embed": true,
      // Ban all objects except for Flash (which handle expandos)
      "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
      "applet": true
    },
    hasData: function hasData(elem) {
      elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
      return !!elem && !isEmptyDataObject(elem);
    },
    data: function data(elem, name, _data, pvt
    /* Internal Use Only */
    ) {
      if (!jQuery.acceptData(elem)) {
        return;
      }

      var thisCache,
          ret,
          internalKey = jQuery.expando,
          getByName = typeof name === "string",
          // We have to handle DOM nodes and JS objects differently because IE6-7
      // can't GC object references properly across the DOM-JS boundary
      isNode = elem.nodeType,
          // Only DOM nodes need the global jQuery cache; JS object data is
      // attached directly to the object so GC can occur automatically
      cache = isNode ? jQuery.cache : elem,
          // Only defining an ID for JS objects if its cache already exists allows
      // the code to shortcut on the same path as a DOM node with no cache
      id = isNode ? elem[internalKey] : elem[internalKey] && internalKey; // Avoid doing any more work than we need to when trying to get data on an
      // object that has no data at all

      if ((!id || !cache[id] || !pvt && !cache[id].data) && getByName && _data === undefined) {
        return;
      }

      if (!id) {
        // Only DOM nodes need a new unique ID for each element since their data
        // ends up in the global cache
        if (isNode) {
          elem[internalKey] = id = jQuery.deletedIds.pop() || jQuery.guid++;
        } else {
          id = internalKey;
        }
      }

      if (!cache[id]) {
        cache[id] = {}; // Avoids exposing jQuery metadata on plain JS objects when the object
        // is serialized using JSON.stringify

        if (!isNode) {
          cache[id].toJSON = jQuery.noop;
        }
      } // An object can be passed to jQuery.data instead of a key/value pair; this gets
      // shallow copied over onto the existing cache


      if (_typeof(name) === "object" || typeof name === "function") {
        if (pvt) {
          cache[id] = jQuery.extend(cache[id], name);
        } else {
          cache[id].data = jQuery.extend(cache[id].data, name);
        }
      }

      thisCache = cache[id]; // jQuery data() is stored in a separate object inside the object's internal data
      // cache in order to avoid key collisions between internal data and user-defined
      // data.

      if (!pvt) {
        if (!thisCache.data) {
          thisCache.data = {};
        }

        thisCache = thisCache.data;
      }

      if (_data !== undefined) {
        thisCache[jQuery.camelCase(name)] = _data;
      } // Check for both converted-to-camel and non-converted data property names
      // If a data property was specified


      if (getByName) {
        // First Try to find as-is property data
        ret = thisCache[name]; // Test for null|undefined property data

        if (ret == null) {
          // Try to find the camelCased property
          ret = thisCache[jQuery.camelCase(name)];
        }
      } else {
        ret = thisCache;
      }

      return ret;
    },
    removeData: function removeData(elem, name, pvt
    /* Internal Use Only */
    ) {
      if (!jQuery.acceptData(elem)) {
        return;
      }

      var thisCache,
          i,
          l,
          isNode = elem.nodeType,
          // See jQuery.data for more information
      cache = isNode ? jQuery.cache : elem,
          id = isNode ? elem[jQuery.expando] : jQuery.expando; // If there is already no cache entry for this object, there is no
      // purpose in continuing

      if (!cache[id]) {
        return;
      }

      if (name) {
        thisCache = pvt ? cache[id] : cache[id].data;

        if (thisCache) {
          // Support array or space separated string names for data keys
          if (!jQuery.isArray(name)) {
            // try the string as a key before any manipulation
            if (name in thisCache) {
              name = [name];
            } else {
              // split the camel cased version by spaces unless a key with the spaces exists
              name = jQuery.camelCase(name);

              if (name in thisCache) {
                name = [name];
              } else {
                name = name.split(" ");
              }
            }
          }

          for (i = 0, l = name.length; i < l; i++) {
            delete thisCache[name[i]];
          } // If there is no data left in the cache, we want to continue
          // and let the cache object itself get destroyed


          if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {
            return;
          }
        }
      } // See jQuery.data for more information


      if (!pvt) {
        delete cache[id].data; // Don't destroy the parent cache unless the internal data object
        // had been the only thing left in it

        if (!isEmptyDataObject(cache[id])) {
          return;
        }
      } // Destroy the cache


      if (isNode) {
        jQuery.cleanData([elem], true); // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
      } else if (jQuery.support.deleteExpando || cache != cache.window) {
        delete cache[id]; // When all else fails, null
      } else {
        cache[id] = null;
      }
    },
    // For internal use only.
    _data: function _data(elem, name, data) {
      return jQuery.data(elem, name, data, true);
    },
    // A method for determining if a DOM node can handle the data expando
    acceptData: function acceptData(elem) {
      var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]; // nodes accept data unless otherwise specified; rejection can be conditional

      return !noData || noData !== true && elem.getAttribute("classid") === noData;
    }
  });
  jQuery.fn.extend({
    data: function data(key, value) {
      var parts,
          part,
          attr,
          name,
          l,
          elem = this[0],
          i = 0,
          data = null; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = jQuery.data(elem);

          if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
            attr = elem.attributes;

            for (l = attr.length; i < l; i++) {
              name = attr[i].name;

              if (!name.indexOf("data-")) {
                name = jQuery.camelCase(name.substring(5));
                dataAttr(elem, name, data[name]);
              }
            }

            jQuery._data(elem, "parsedAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (_typeof(key) === "object") {
        return this.each(function () {
          jQuery.data(this, key);
        });
      }

      parts = key.split(".", 2);
      parts[1] = parts[1] ? "." + parts[1] : "";
      part = parts[1] + "!";
      return jQuery.access(this, function (value) {
        if (value === undefined) {
          data = this.triggerHandler("getData" + part, [parts[0]]); // Try to fetch any internally stored data first

          if (data === undefined && elem) {
            data = jQuery.data(elem, key);
            data = dataAttr(elem, key, data);
          }

          return data === undefined && parts[1] ? this.data(parts[0]) : data;
        }

        parts[1] = value;
        this.each(function () {
          var self = jQuery(this);
          self.triggerHandler("setData" + part, parts);
          jQuery.data(this, key, value);
          self.triggerHandler("changeData" + part, parts);
        });
      }, null, value, arguments.length > 1, null, false);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        jQuery.removeData(this, key);
      });
    }
  });

  function dataAttr(elem, key, data) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if (data === undefined && elem.nodeType === 1) {
      var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : // Only convert to a number if it doesn't change the string
          +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {} // Make sure we set the data so it isn't changed later


        jQuery.data(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  } // checks a cache object for emptiness


  function isEmptyDataObject(obj) {
    var name;

    for (name in obj) {
      // if the public data object is empty, the private is still empty
      if (name === "data" && jQuery.isEmptyObject(obj[name])) {
        continue;
      }

      if (name !== "toJSON") {
        return false;
      }
    }

    return true;
  }

  jQuery.extend({
    queue: function queue(elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = jQuery._data(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = jQuery._data(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function next() {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return jQuery._data(elem, key) || jQuery._data(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          jQuery.removeData(elem, type + "queue", true);
          jQuery.removeData(elem, key, true);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function delay(time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function (next, hooks) {
        var timeout = setTimeout(next, time);

        hooks.stop = function () {
          clearTimeout(timeout);
        };
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function promise(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function resolve() {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = jQuery._data(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var nodeHook,
      boolHook,
      fixSpecified,
      rclass = /[\t\r\n]/g,
      rreturn = /\r/g,
      rtype = /^(?:button|input)$/i,
      rfocusable = /^(?:button|input|object|select|textarea)$/i,
      rclickable = /^a(?:rea|)$/i,
      rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
      getSetAttribute = jQuery.support.getSetAttribute;
  jQuery.fn.extend({
    attr: function attr(name, value) {
      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
    prop: function prop(name, value) {
      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      name = jQuery.propFix[name] || name;
      return this.each(function () {
        // try/catch handles cases where IE balks (such as removing a property on window)
        try {
          this[name] = undefined;
          delete this[name];
        } catch (e) {}
      });
    },
    addClass: function addClass(value) {
      var classNames, i, l, elem, setClass, c, cl;

      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }

      if (value && typeof value === "string") {
        classNames = value.split(core_rspace);

        for (i = 0, l = this.length; i < l; i++) {
          elem = this[i];

          if (elem.nodeType === 1) {
            if (!elem.className && classNames.length === 1) {
              elem.className = value;
            } else {
              setClass = " " + elem.className + " ";

              for (c = 0, cl = classNames.length; c < cl; c++) {
                if (setClass.indexOf(" " + classNames[c] + " ") < 0) {
                  setClass += classNames[c] + " ";
                }
              }

              elem.className = jQuery.trim(setClass);
            }
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(value) {
      var removes, className, elem, c, cl, i, l;

      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }

      if (value && typeof value === "string" || value === undefined) {
        removes = (value || "").split(core_rspace);

        for (i = 0, l = this.length; i < l; i++) {
          elem = this[i];

          if (elem.nodeType === 1 && elem.className) {
            className = (" " + elem.className + " ").replace(rclass, " "); // loop over each item in the removal list

            for (c = 0, cl = removes.length; c < cl; c++) {
              // Remove until there is nothing to remove,
              while (className.indexOf(" " + removes[c] + " ") >= 0) {
                className = className.replace(" " + removes[c] + " ", " ");
              }
            }

            elem.className = value ? jQuery.trim(className) : "";
          }
        }
      }

      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var type = _typeof(value),
          isBool = typeof stateVal === "boolean";

      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }

      return this.each(function () {
        if (type === "string") {
          // toggle individual class names
          var className,
              i = 0,
              self = jQuery(this),
              state = stateVal,
              classNames = value.split(core_rspace);

          while (className = classNames[i++]) {
            // check each className given, space separated list
            state = isBool ? state : !self.hasClass(className);
            self[state ? "addClass" : "removeClass"](className);
          }
        } else if (type === "undefined" || type === "boolean") {
          if (this.className) {
            // store className if set
            jQuery._data(this, "__className__", this.className);
          } // toggle whole className


          this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className = " " + selector + " ",
          i = 0,
          l = this.length;

      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }

      return false;
    },
    val: function val(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value;
          return typeof ret === "string" ? // handle most common string cases
          ret.replace(rreturn, "") : // handle cases where value is null/undef or number
          ret == null ? "" : ret;
        }

        return;
      }

      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val,
            self = jQuery(this);

        if (this.nodeType !== 1) {
          return;
        }

        if (isFunction) {
          val = value.call(this, i, self.val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          // attributes.value is undefined in Blackberry 4.7 but
          // uses .value. See #6932
          var val = elem.attributes.value;
          return !val || val.specified ? elem.value : elem.text;
        }
      },
      select: {
        get: function get(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0; // Loop through all the selected options

          for (; i < max; i++) {
            option = options[i]; // oldIE doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && ( // Don't return options that are disabled or in a disabled optgroup
            jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function set(elem, value) {
          var values = jQuery.makeArray(value);
          jQuery(elem).find("option").each(function () {
            this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
          });

          if (!values.length) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    },
    // Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
    attrFn: {},
    attr: function attr(elem, name, value, pass) {
      var ret,
          hooks,
          notxml,
          nType = elem.nodeType; // don't get/set attributes on text, comment and attribute nodes

      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (pass && jQuery.isFunction(jQuery.fn[name])) {
        return jQuery(elem)[name](value);
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }

      notxml = nType !== 1 || !jQuery.isXMLDoc(elem); // All attributes are lowercase
      // Grab necessary hook if one is defined

      if (notxml) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = elem.getAttribute(name); // Non-existent attributes return null, we normalize to undefined

        return ret === null ? undefined : ret;
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var propName,
          attrNames,
          name,
          isBool,
          i = 0;

      if (value && elem.nodeType === 1) {
        attrNames = value.split(core_rspace);

        for (; i < attrNames.length; i++) {
          name = attrNames[i];

          if (name) {
            propName = jQuery.propFix[name] || name;
            isBool = rboolean.test(name); // See #9699 for explanation of this approach (setting first, then removal)
            // Do not do this for boolean attributes (see #10870)

            if (!isBool) {
              jQuery.attr(elem, name, "");
            }

            elem.removeAttribute(getSetAttribute ? name : propName); // Set corresponding property to false for boolean attributes

            if (isBool && propName in elem) {
              elem[propName] = false;
            }
          }
        }
      }
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          // We can't allow the type property to be changed (since it causes problems in IE)
          if (rtype.test(elem.nodeName) && elem.parentNode) {
            jQuery.error("type property can't be changed");
          } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            // Setting the type on a radio button after the value resets the value in IE6-9
            // Reset value to it's default in case type is set after value
            // This is for element creation
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      },
      // Use the value property for back compat
      // Use the nodeHook for button elements in IE6/7 (#1954)
      value: {
        get: function get(elem, name) {
          if (nodeHook && jQuery.nodeName(elem, "button")) {
            return nodeHook.get(elem, name);
          }

          return name in elem ? elem.value : null;
        },
        set: function set(elem, value, name) {
          if (nodeHook && jQuery.nodeName(elem, "button")) {
            return nodeHook.set(elem, value, name);
          } // Does not return so that setAttribute is also used


          elem.value = value;
        }
      }
    },
    propFix: {
      tabindex: "tabIndex",
      readonly: "readOnly",
      "for": "htmlFor",
      "class": "className",
      maxlength: "maxLength",
      cellspacing: "cellSpacing",
      cellpadding: "cellPadding",
      rowspan: "rowSpan",
      colspan: "colSpan",
      usemap: "useMap",
      frameborder: "frameBorder",
      contenteditable: "contentEditable"
    },
    prop: function prop(elem, name, value) {
      var ret,
          hooks,
          notxml,
          nType = elem.nodeType; // don't get/set properties on text, comment and attribute nodes

      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

      if (notxml) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          return elem[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        } else {
          return elem[name];
        }
      }
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          var attributeNode = elem.getAttributeNode("tabindex");
          return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : undefined;
        }
      }
    }
  }); // Hook for boolean attributes

  boolHook = {
    get: function get(elem, name) {
      // Align boolean attributes with corresponding properties
      // Fall back to attribute presence where some booleans are not supported
      var attrNode,
          property = jQuery.prop(elem, name);
      return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ? name.toLowerCase() : undefined;
    },
    set: function set(elem, value, name) {
      var propName;

      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        // value is true since we know at this point it's type boolean and not false
        // Set boolean attributes to the same name and set the DOM property
        propName = jQuery.propFix[name] || name;

        if (propName in elem) {
          // Only set the IDL specifically if it already exists on the element
          elem[propName] = true;
        }

        elem.setAttribute(name, name.toLowerCase());
      }

      return name;
    }
  }; // IE6/7 do not support getting/setting some attributes with get/setAttribute

  if (!getSetAttribute) {
    fixSpecified = {
      name: true,
      id: true,
      coords: true
    }; // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue

    nodeHook = jQuery.valHooks.button = {
      get: function get(elem, name) {
        var ret;
        ret = elem.getAttributeNode(name);
        return ret && (fixSpecified[name] ? ret.value !== "" : ret.specified) ? ret.value : undefined;
      },
      set: function set(elem, value, name) {
        // Set the existing or create a new attribute node
        var ret = elem.getAttributeNode(name);

        if (!ret) {
          ret = document.createAttribute(name);
          elem.setAttributeNode(ret);
        }

        return ret.value = value + "";
      }
    }; // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals

    jQuery.each(["width", "height"], function (i, name) {
      jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
        set: function set(elem, value) {
          if (value === "") {
            elem.setAttribute(name, "auto");
            return value;
          }
        }
      });
    }); // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value

    jQuery.attrHooks.contenteditable = {
      get: nodeHook.get,
      set: function set(elem, value, name) {
        if (value === "") {
          value = "false";
        }

        nodeHook.set(elem, value, name);
      }
    };
  } // Some attributes require a special call on IE


  if (!jQuery.support.hrefNormalized) {
    jQuery.each(["href", "src", "width", "height"], function (i, name) {
      jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
        get: function get(elem) {
          var ret = elem.getAttribute(name, 2);
          return ret === null ? undefined : ret;
        }
      });
    });
  }

  if (!jQuery.support.style) {
    jQuery.attrHooks.style = {
      get: function get(elem) {
        // Return undefined in the case of empty string
        // Normalize to lowercase since IE uppercases css property names
        return elem.style.cssText.toLowerCase() || undefined;
      },
      set: function set(elem, value) {
        return elem.style.cssText = value + "";
      }
    };
  } // Safari mis-reports the default selected property of an option
  // Accessing the parent's selectedIndex property fixes it


  if (!jQuery.support.optSelected) {
    jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
      get: function get(elem) {
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex; // Make sure that it also works with optgroups, see #5701

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }

        return null;
      }
    });
  } // IE6/7 call enctype encoding


  if (!jQuery.support.enctype) {
    jQuery.propFix.enctype = "encoding";
  } // Radios and checkboxes getter/setter


  if (!jQuery.support.checkOn) {
    jQuery.each(["radio", "checkbox"], function () {
      jQuery.valHooks[this] = {
        get: function get(elem) {
          // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
          return elem.getAttribute("value") === null ? "on" : elem.value;
        }
      };
    });
  }

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
      set: function set(elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    });
  });

  var rformElems = /^(?:textarea|input|select)$/i,
      rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
      rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
      rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|contextmenu)|click/,
      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      hoverHack = function hoverHack(events) {
    return jQuery.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
  };
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    add: function add(elem, types, handler, data, selector) {
      var elemData, _eventHandle, events, t, tns, type, namespaces, handleObj, handleObjIn, handlers, special; // Don't attach events to noData or text/comment nodes (allow plain objects tho)


      if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      events = elemData.events;

      if (!events) {
        elemData.events = events = {};
      }

      _eventHandle = elemData.handle;

      if (!_eventHandle) {
        elemData.handle = _eventHandle = function eventHandle(e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(_eventHandle.elem, arguments) : undefined;
        }; // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events


        _eventHandle.elem = elem;
      } // Handle multiple events separated by a space
      // jQuery(...).bind("mouseover mouseout", fn);


      types = jQuery.trim(hoverHack(types)).split(" ");

      for (t = 0; t < types.length; t++) {
        tns = rtypenamespace.exec(types[t]) || [];
        type = tns[1];
        namespaces = (tns[2] || "").split(".").sort(); // If event changes its type, use the special event handlers for the changed type

        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: tns[1],
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        handlers = events[type];

        if (!handlers) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener/attachEvent if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, _eventHandle) === false) {
            // Bind the global event handler to the element
            if (elem.addEventListener) {
              elem.addEventListener(type, _eventHandle, false);
            } else if (elem.attachEvent) {
              elem.attachEvent("on" + type, _eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      } // Nullify elem to prevent memory leaks in IE


      elem = null;
    },
    global: {},
    // Detach an event or set of events from an element
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var t,
          tns,
          type,
          origType,
          namespaces,
          origCount,
          j,
          events,
          special,
          eventType,
          handleObj,
          elemData = jQuery.hasData(elem) && jQuery._data(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = jQuery.trim(hoverHack(types || "")).split(" ");

      for (t = 0; t < types.length; t++) {
        tns = rtypenamespace.exec(types[t]) || [];
        type = origType = tns[1];
        namespaces = tns[2]; // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        eventType = events[type] || [];
        origCount = eventType.length;
        namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Remove matching events

        for (j = 0; j < eventType.length; j++) {
          handleObj = eventType[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!namespaces || namespaces.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            eventType.splice(j--, 1);

            if (handleObj.selector) {
              eventType.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (eventType.length === 0 && origCount !== eventType.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle; // removeData also checks for emptiness and clears the expando if empty
        // so use it instead of delete

        jQuery.removeData(elem, "events", true);
      }
    },
    // Events that are safe to short-circuit if no handlers are attached.
    // Native DOM events should not be added, they may have inline handlers.
    customEvent: {
      "getData": true,
      "setData": true,
      "changeData": true
    },
    trigger: function trigger(event, data, elem, onlyHandlers) {
      // Don't do events on text and comment nodes
      if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
        return;
      } // Event object or event type


      var cache,
          exclusive,
          i,
          cur,
          old,
          ontype,
          special,
          handle,
          eventPath,
          bubbleType,
          type = event.type || event,
          namespaces = []; // focus/blur morphs to focusin/out; ensure we're not firing them right now

      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf("!") >= 0) {
        // Exclusive events trigger only for the exact event (no namespaces)
        type = type.slice(0, -1);
        exclusive = true;
      }

      if (type.indexOf(".") >= 0) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
        // No jQuery handlers for this event type, and it can't have inline handlers
        return;
      } // Caller can pass in an Event, Object, or just an event type string


      event = _typeof(event) === "object" ? // jQuery.Event object
      event[jQuery.expando] ? event : // Object literal
      new jQuery.Event(type, event) : // Just the event type (string)
      new jQuery.Event(type);
      event.type = type;
      event.isTrigger = true;
      event.exclusive = exclusive;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      ontype = type.indexOf(":") < 0 ? "on" + type : ""; // Handle a global trigger

      if (!elem) {
        // TODO: Stop taunting the data cache; remove global events and always attach to document
        cache = jQuery.cache;

        for (i in cache) {
          if (cache[i].events && cache[i].events[type]) {
            jQuery.event.trigger(event, data, cache[i].handle.elem, true);
          }
        }

        return;
      } // Clean up the event in case it is being reused


      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data != null ? jQuery.makeArray(data) : [];
      data.unshift(event); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      eventPath = [[elem, special.bindType || type]];

      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;

        for (old = elem; cur; cur = cur.parentNode) {
          eventPath.push([cur, bubbleType]);
          old = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (old === (elem.ownerDocument || document)) {
          eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);
        }
      } // Fire handlers on the event path


      for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {
        cur = eventPath[i][0];
        event.type = eventPath[i][1];
        handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Note that this is a bare JS function and not a jQuery handler


        handle = ontype && cur[ontype];

        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
          event.preventDefault();
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) && !(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {
          // Call a native DOM method on the target with the same name name as the event.
          // Can't use an .isFunction() check here because IE6/7 fails that test.
          // Don't do default actions on window, that's where global variables be (#6170)
          // IE<9 dies on focus/blur to hidden element (#1486)
          if (ontype && elem[type] && (type !== "focus" && type !== "blur" || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            old = elem[ontype];

            if (old) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;

            if (old) {
              elem[ontype] = old;
            }
          }
        }
      }

      return event.result;
    },
    dispatch: function dispatch(event) {
      // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(event || window.event);
      var i,
          j,
          cur,
          ret,
          selMatch,
          matched,
          matches,
          handleObj,
          sel,
          related,
          handlers = (jQuery._data(this, "events") || {})[event.type] || [],
          delegateCount = handlers.delegateCount,
          args = core_slice.call(arguments),
          run_all = !event.exclusive && !event.namespace,
          special = jQuery.event.special[event.type] || {},
          handlerQueue = []; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;
      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers that should run if there are delegated events
      // Avoid non-left-click bubbling in Firefox (#3861)


      if (delegateCount && !(event.button && event.type === "click")) {
        for (cur = event.target; cur != this; cur = cur.parentNode || this) {
          // Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.disabled !== true || event.type !== "click") {
            selMatch = {};
            matches = [];

            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector;

              if (selMatch[sel] === undefined) {
                selMatch[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (selMatch[sel]) {
                matches.push(handleObj);
              }
            }

            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                matches: matches
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      if (handlers.length > delegateCount) {
        handlerQueue.push({
          elem: this,
          matches: handlers.slice(delegateCount)
        });
      } // Run delegates first; they may want to stop propagation beneath us


      for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
        matched = handlerQueue[i];
        event.currentTarget = matched.elem;

        for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
          handleObj = matched.matches[j]; // Triggered event must either 1) be non-exclusive and have no namespace, or
          // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).

          if (run_all || !event.namespace && !handleObj.namespace || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {
            event.data = handleObj.data;
            event.handleObj = handleObj;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              event.result = ret;

              if (ret === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    // Includes some event props shared by KeyEvent and MouseEvent
    // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
    props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function filter(event, original) {
        // Add which for key events
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }

        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function filter(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button,
            fromElement = original.fromElement; // Calculate pageX/Y if missing and clientX/Y available

        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        } // Add relatedTarget, if necessary


        if (!event.relatedTarget && fromElement) {
          event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
        } // Add which for click: 1 === left; 2 === middle; 3 === right
        // Note: button is not normalized, so don't use it


        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }

        return event;
      }
    },
    fix: function fix(event) {
      if (event[jQuery.expando]) {
        return event;
      } // Create a writable copy of the event object and normalize some properties


      var i,
          prop,
          originalEvent = event,
          fixHook = jQuery.event.fixHooks[event.type] || {},
          copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = jQuery.Event(originalEvent);

      for (i = copy.length; i;) {
        prop = copy[--i];
        event[prop] = originalEvent[prop];
      } // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)


      if (!event.target) {
        event.target = originalEvent.srcElement || document;
      } // Target should not be a text node (#504, Safari)


      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      } // For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)


      event.metaKey = !!event.metaKey;
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      focus: {
        delegateType: "focusin"
      },
      blur: {
        delegateType: "focusout"
      },
      beforeunload: {
        setup: function setup(data, namespaces, eventHandle) {
          // We only want to do this special case on windows
          if (jQuery.isWindow(this)) {
            this.onbeforeunload = eventHandle;
          }
        },
        teardown: function teardown(namespaces, eventHandle) {
          if (this.onbeforeunload === eventHandle) {
            this.onbeforeunload = null;
          }
        }
      }
    },
    simulate: function simulate(type, elem, event, bubble) {
      // Piggyback on a donor event to simulate a different one.
      // Fake originalEvent to avoid donor's stopPropagation, but if the
      // simulated event prevents default then we do the same on the donor.
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,
        originalEvent: {}
      });

      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }

      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  }; // Some plugins are using, but it's undocumented/deprecated and will be removed.
  // The 1.7 special event interface should provide all the hooks needed now.

  jQuery.event.handle = jQuery.event.dispatch;
  jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  } : function (elem, type, handle) {
    var name = "on" + type;

    if (elem.detachEvent) {
      // #8545, #7054, preventing memory leaks for custom events in IE6-8
      // detachEvent needed property on element, by name of that event, to properly expose it to GC
      if (typeof elem[name] === "undefined") {
        elem[name] = null;
      }

      elem.detachEvent(name, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  };

  function returnFalse() {
    return false;
  }

  function returnTrue() {
    return true;
  } // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    preventDefault: function preventDefault() {
      this.isDefaultPrevented = returnTrue;
      var e = this.originalEvent;

      if (!e) {
        return;
      } // if preventDefault exists run it on the original event


      if (e.preventDefault) {
        e.preventDefault(); // otherwise set the returnValue property of the original event to false (IE)
      } else {
        e.returnValue = false;
      }
    },
    stopPropagation: function stopPropagation() {
      this.isPropagationStopped = returnTrue;
      var e = this.originalEvent;

      if (!e) {
        return;
      } // if stopPropagation exists run it on the original event


      if (e.stopPropagation) {
        e.stopPropagation();
      } // otherwise set the cancelBubble property of the original event to true (IE)


      e.cancelBubble = true;
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
  }; // Create mouseenter/leave events using mouseover/out and event-time checks

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj,
            selector = handleObj.selector; // For mousenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  }); // IE submit delegation

  if (!jQuery.support.submitBubbles) {
    jQuery.event.special.submit = {
      setup: function setup() {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, "form")) {
          return false;
        } // Lazy-add a submit handler when a descendant form may potentially be submitted


        jQuery.event.add(this, "click._submit keypress._submit", function (e) {
          // Node name check avoids a VML-related crash in IE (#9807)
          var elem = e.target,
              form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;

          if (form && !jQuery._data(form, "_submit_attached")) {
            jQuery.event.add(form, "submit._submit", function (event) {
              event._submit_bubble = true;
            });

            jQuery._data(form, "_submit_attached", true);
          }
        }); // return undefined since we don't need an event listener
      },
      postDispatch: function postDispatch(event) {
        // If form was submitted by the user, bubble the event up the tree
        if (event._submit_bubble) {
          delete event._submit_bubble;

          if (this.parentNode && !event.isTrigger) {
            jQuery.event.simulate("submit", this.parentNode, event, true);
          }
        }
      },
      teardown: function teardown() {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, "form")) {
          return false;
        } // Remove delegated handlers; cleanData eventually reaps submit handlers attached above


        jQuery.event.remove(this, "._submit");
      }
    };
  } // IE change delegation and checkbox/radio fix


  if (!jQuery.support.changeBubbles) {
    jQuery.event.special.change = {
      setup: function setup() {
        if (rformElems.test(this.nodeName)) {
          // IE doesn't fire change on a check/radio until blur; trigger it on click
          // after a propertychange. Eat the blur-change in special.change.handle.
          // This still fires onchange a second time for check/radio after blur.
          if (this.type === "checkbox" || this.type === "radio") {
            jQuery.event.add(this, "propertychange._change", function (event) {
              if (event.originalEvent.propertyName === "checked") {
                this._just_changed = true;
              }
            });
            jQuery.event.add(this, "click._change", function (event) {
              if (this._just_changed && !event.isTrigger) {
                this._just_changed = false;
              } // Allow triggered, simulated change events (#11500)


              jQuery.event.simulate("change", this, event, true);
            });
          }

          return false;
        } // Delegated event; lazy-add a change handler on descendant inputs


        jQuery.event.add(this, "beforeactivate._change", function (e) {
          var elem = e.target;

          if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "_change_attached")) {
            jQuery.event.add(elem, "change._change", function (event) {
              if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                jQuery.event.simulate("change", this.parentNode, event, true);
              }
            });

            jQuery._data(elem, "_change_attached", true);
          }
        });
      },
      handle: function handle(event) {
        var elem = event.target; // Swallow native change events from checkbox/radio, we already triggered them above

        if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== "radio" && elem.type !== "checkbox") {
          return event.handleObj.handler.apply(this, arguments);
        }
      },
      teardown: function teardown() {
        jQuery.event.remove(this, "._change");
        return !rformElems.test(this.nodeName);
      }
    };
  } // Create "bubbling" focus and blur events


  if (!jQuery.support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler while someone wants focusin/focusout
      var attaches = 0,
          handler = function handler(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };

      jQuery.event.special[fix] = {
        setup: function setup() {
          if (attaches++ === 0) {
            document.addEventListener(orig, handler, true);
          }
        },
        teardown: function teardown() {
          if (--attaches === 0) {
            document.removeEventListener(orig, handler, true);
          }
        }
      };
    });
  }

  jQuery.fn.extend({
    on: function on(types, selector, data, fn,
    /*INTERNAL*/
    one) {
      var origFn, type; // Types can be a map of types/handlers

      if (_typeof(types) === "object") {
        // ( types-Object, selector, data )
        if (typeof selector !== "string") {
          // && selector != null
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }

        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }

        return this;
      }

      if (data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }

      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }

      if (one === 1) {
        origFn = fn;

        fn = function fn(event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        }; // Use same guid so caller can remove using origFn


        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }

      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function one(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (_typeof(types) === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    live: function live(types, data, fn) {
      jQuery(this.context).on(types, this.selector, data, fn);
      return this;
    },
    die: function die(types, fn) {
      jQuery(this.context).off(types, this.selector || "**", fn);
      return this;
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    trigger: function trigger(type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      if (this[0]) {
        return jQuery.event.trigger(type, data, this[0], true);
      }
    },
    toggle: function toggle(fn) {
      // Save reference to arguments for access in closure
      var args = arguments,
          guid = fn.guid || jQuery.guid++,
          i = 0,
          toggler = function toggler(event) {
        // Figure out which function to execute
        var lastToggle = (jQuery._data(this, "lastToggle" + fn.guid) || 0) % i;

        jQuery._data(this, "lastToggle" + fn.guid, lastToggle + 1); // Make sure that clicks stop


        event.preventDefault(); // and execute the function

        return args[lastToggle].apply(this, arguments) || false;
      }; // link all the functions, so any of them can unbind this click handler


      toggler.guid = guid;

      while (i < args.length) {
        args[i++].guid = guid;
      }

      return this.click(toggler);
    },
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      if (fn == null) {
        fn = data;
        data = null;
      }

      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };

    if (rkeyEvent.test(name)) {
      jQuery.event.fixHooks[name] = jQuery.event.keyHooks;
    }

    if (rmouseEvent.test(name)) {
      jQuery.event.fixHooks[name] = jQuery.event.mouseHooks;
    }
  });
  /*!
   * Sizzle CSS Selector Engine
   * Copyright 2012 jQuery Foundation and other contributors
   * Released under the MIT license
   * http://sizzlejs.com/
   */

  (function (window, undefined) {
    var cachedruns,
        assertGetIdNotName,
        Expr,
        getText,
        isXML,
        contains,
        compile,
        sortOrder,
        hasDuplicate,
        outermostContext,
        baseHasDuplicate = true,
        strundefined = "undefined",
        expando = ("sizcache" + Math.random()).replace(".", ""),
        Token = String,
        document = window.document,
        docElem = document.documentElement,
        dirruns = 0,
        done = 0,
        pop = [].pop,
        push = [].push,
        slice = [].slice,
        // Use a stripped-down indexOf if a native one is unavailable
    indexOf = [].indexOf || function (elem) {
      var i = 0,
          len = this.length;

      for (; i < len; i++) {
        if (this[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        // Augment a function for special use by Sizzle
    markFunction = function markFunction(fn, value) {
      fn[expando] = value == null || value;
      return fn;
    },
        createCache = function createCache() {
      var cache = {},
          keys = [];
      return markFunction(function (key, value) {
        // Only keep the most recent entries
        if (keys.push(key) > Expr.cacheLength) {
          delete cache[keys.shift()];
        } // Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)


        return cache[key + " "] = value;
      }, cache);
    },
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        // Regex
    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",
        // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding.replace("w", "w#"),
        // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
    operators = "([*^$|!~]?=)",
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
        // Prefer arguments not in parens/brackets,
    //   then attribute selectors and non-pseudos (denoted by :),
    //   then anything else
    // These preferences are here to reduce the number of selectors
    //   needing tokenize in the PSEUDO preFilter
    pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",
        // For matchExpr.POS and matchExpr.needsContext
    pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"),
        rpseudo = new RegExp(pseudos),
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,
        rnot = /^:not/,
        rsibling = /[\x20\t\r\n\f]*[+~]/,
        rendsWithNot = /:not\($/,
        rheader = /h\d/i,
        rinputs = /input|select|textarea|button/i,
        rbackslash = /\\(?!\\)/g,
        matchExpr = {
      "ID": new RegExp("^#(" + characterEncoding + ")"),
      "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
      "NAME": new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"),
      "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "POS": new RegExp(pos, "i"),
      "CHILD": new RegExp("^:(only|nth|first|last)-child(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      // For use in libraries implementing .is()
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|" + pos, "i")
    },
        // Support
    // Used for testing something on an element
    assert = function assert(fn) {
      var div = document.createElement("div");

      try {
        return fn(div);
      } catch (e) {
        return false;
      } finally {
        // release memory in IE
        div = null;
      }
    },
        // Check if getElementsByTagName("*") returns only elements
    assertTagNameNoComments = assert(function (div) {
      div.appendChild(document.createComment(""));
      return !div.getElementsByTagName("*").length;
    }),
        // Check if getAttribute returns normalized href attributes
    assertHrefNotNormalized = assert(function (div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild && _typeof(div.firstChild.getAttribute) !== strundefined && div.firstChild.getAttribute("href") === "#";
    }),
        // Check if attributes should be retrieved by attribute nodes
    assertAttributes = assert(function (div) {
      div.innerHTML = "<select></select>";

      var type = _typeof(div.lastChild.getAttribute("multiple")); // IE8 returns a string for some attributes even when not present


      return type !== "boolean" && type !== "string";
    }),
        // Check if getElementsByClassName can be trusted
    assertUsableClassName = assert(function (div) {
      // Opera can't find a second classname (in 9.6)
      div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";

      if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) {
        return false;
      } // Safari 3.2 caches class attributes and doesn't catch changes


      div.lastChild.className = "e";
      return div.getElementsByClassName("e").length === 2;
    }),
        // Check if getElementById returns elements by name
    // Check if getElementsByName privileges form controls or returns elements by ID
    assertUsableName = assert(function (div) {
      // Inject content
      div.id = expando + 0;
      div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
      docElem.insertBefore(div, docElem.firstChild); // Test

      var pass = document.getElementsByName && // buggy browsers will return fewer than the correct 2
      document.getElementsByName(expando).length === 2 + // buggy browsers will return more than the correct 0
      document.getElementsByName(expando + 0).length;
      assertGetIdNotName = !document.getElementById(expando); // Cleanup

      docElem.removeChild(div);
      return pass;
    }); // If slice is not available, provide a backup


    try {
      slice.call(docElem.childNodes, 0)[0].nodeType;
    } catch (e) {
      slice = function slice(i) {
        var elem,
            results = [];

        for (; elem = this[i]; i++) {
          results.push(elem);
        }

        return results;
      };
    }

    function Sizzle(selector, context, results, seed) {
      results = results || [];
      context = context || document;
      var match,
          elem,
          xml,
          m,
          nodeType = context.nodeType;

      if (!selector || typeof selector !== "string") {
        return results;
      }

      if (nodeType !== 1 && nodeType !== 9) {
        return [];
      }

      xml = isXML(context);

      if (!xml && !seed) {
        if (match = rquickExpr.exec(selector)) {
          // Speed-up: Sizzle("#ID")
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m); // Check parentNode to catch when Blackberry 4.6 returns
              // nodes that are no longer in the document #6963

              if (elem && elem.parentNode) {
                // Handle the case where IE, Opera, and Webkit return items
                // by name instead of ID
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              // Context is not a document
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            } // Speed-up: Sizzle("TAG")

          } else if (match[2]) {
            push.apply(results, slice.call(context.getElementsByTagName(selector), 0));
            return results; // Speed-up: Sizzle(".CLASS")
          } else if ((m = match[3]) && assertUsableClassName && context.getElementsByClassName) {
            push.apply(results, slice.call(context.getElementsByClassName(m), 0));
            return results;
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed, xml);
    }

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      return Sizzle(expr, null, null, [elem]).length > 0;
    }; // Returns a function to use in pseudos for input types


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    } // Returns a function to use in pseudos for buttons


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    } // Returns a function to use in pseudos for positionals


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (nodeType) {
        if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (see #11153)
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        } // Do not include comment or processing instruction nodes

      } else {
        // If no nodeType, this is expected to be an array
        for (; node = elem[i]; i++) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      }

      return ret;
    };

    isXML = Sizzle.isXML = function (elem) {
      // documentElement is verified for cases where it doesn't yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    }; // Element contains another


    contains = Sizzle.contains = docElem.contains ? function (a, b) {
      var adown = a.nodeType === 9 ? a.documentElement : a,
          bup = b && b.parentNode;
      return a === bup || !!(bup && bup.nodeType === 1 && adown.contains && adown.contains(bup));
    } : docElem.compareDocumentPosition ? function (a, b) {
      return b && !!(a.compareDocumentPosition(b) & 16);
    } : function (a, b) {
      while (b = b.parentNode) {
        if (b === a) {
          return true;
        }
      }

      return false;
    };

    Sizzle.attr = function (elem, name) {
      var val,
          xml = isXML(elem);

      if (!xml) {
        name = name.toLowerCase();
      }

      if (val = Expr.attrHandle[name]) {
        return val(elem);
      }

      if (xml || assertAttributes) {
        return elem.getAttribute(name);
      }

      val = elem.getAttributeNode(name);
      return val ? typeof elem[name] === "boolean" ? elem[name] ? name : null : val.specified ? val.value : null : null;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      // IE6/7 return a modified href
      attrHandle: assertHrefNotNormalized ? {} : {
        "href": function href(elem) {
          return elem.getAttribute("href", 2);
        },
        "type": function type(elem) {
          return elem.getAttribute("type");
        }
      },
      find: {
        "ID": assertGetIdNotName ? function (id, context, xml) {
          if (_typeof(context.getElementById) !== strundefined && !xml) {
            var m = context.getElementById(id); // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963

            return m && m.parentNode ? [m] : [];
          }
        } : function (id, context, xml) {
          if (_typeof(context.getElementById) !== strundefined && !xml) {
            var m = context.getElementById(id);
            return m ? m.id === id || _typeof(m.getAttributeNode) !== strundefined && m.getAttributeNode("id").value === id ? [m] : undefined : [];
          }
        },
        "TAG": assertTagNameNoComments ? function (tag, context) {
          if (_typeof(context.getElementsByTagName) !== strundefined) {
            return context.getElementsByTagName(tag);
          }
        } : function (tag, context) {
          var results = context.getElementsByTagName(tag); // Filter out possible comments

          if (tag === "*") {
            var elem,
                tmp = [],
                i = 0;

            for (; elem = results[i]; i++) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }

            return tmp;
          }

          return results;
        },
        "NAME": assertUsableName && function (tag, context) {
          if (_typeof(context.getElementsByName) !== strundefined) {
            return context.getElementsByName(name);
          }
        },
        "CLASS": assertUsableClassName && function (className, context, xml) {
          if (_typeof(context.getElementsByClassName) !== strundefined && !xml) {
            return context.getElementsByClassName(className);
          }
        }
      },
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function ATTR(match) {
          match[1] = match[1].replace(rbackslash, ""); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[4] || match[5] || "").replace(rbackslash, "");

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function CHILD(match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	3 xn-component of xn+y argument ([+-]?\d*n|)
          	4 sign of xn-component
          	5 x of xn-component
          	6 sign of y-component
          	7 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1] === "nth") {
            // nth-child requires argument
            if (!match[2]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[3] = +(match[3] ? match[4] + (match[5] || 1) : 2 * (match[2] === "even" || match[2] === "odd"));
            match[4] = +(match[6] + match[7] || match[2] === "odd"); // other types prohibit arguments
          } else if (match[2]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function PSEUDO(match) {
          var unquoted, excess;

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }

          if (match[3]) {
            match[2] = match[3];
          } else if (unquoted = match[4]) {
            // Only check arguments that contain a pseudo
            if (rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
            excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              // excess is a negative index
              unquoted = unquoted.slice(0, excess);
              match[0] = match[0].slice(0, excess);
            }

            match[2] = unquoted;
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "ID": assertGetIdNotName ? function (id) {
          id = id.replace(rbackslash, "");
          return function (elem) {
            return elem.getAttribute("id") === id;
          };
        } : function (id) {
          id = id.replace(rbackslash, "");
          return function (elem) {
            var node = _typeof(elem.getAttributeNode) !== strundefined && elem.getAttributeNode("id");
            return node && node.value === id;
          };
        },
        "TAG": function TAG(nodeName) {
          if (nodeName === "*") {
            return function () {
              return true;
            };
          }

          nodeName = nodeName.replace(rbackslash, "").toLowerCase();
          return function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function CLASS(className) {
          var pattern = classCache[expando][className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(elem.className || _typeof(elem.getAttribute) !== strundefined && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function ATTR(name, operator, check) {
          return function (elem, context) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.substr(result.length - check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.substr(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function CHILD(type, argument, first, last) {
          if (type === "nth") {
            return function (elem) {
              var node,
                  diff,
                  parent = elem.parentNode;

              if (first === 1 && last === 0) {
                return true;
              }

              if (parent) {
                diff = 0;

                for (node = parent.firstChild; node; node = node.nextSibling) {
                  if (node.nodeType === 1) {
                    diff++;

                    if (elem === node) {
                      break;
                    }
                  }
                }
              } // Incorporate the offset (or cast to NaN), then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            };
          }

          return function (elem) {
            var node = elem;

            switch (type) {
              case "only":
              case "first":
                while (node = node.previousSibling) {
                  if (node.nodeType === 1) {
                    return false;
                  }
                }

                if (type === "first") {
                  return true;
                }

                node = elem;

              /* falls through */

              case "last":
                while (node = node.nextSibling) {
                  if (node.nodeType === 1) {
                    return false;
                  }
                }

                return true;
            }
          };
        },
        "PSEUDO": function PSEUDO(pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "enabled": function enabled(elem) {
          return elem.disabled === false;
        },
        "disabled": function disabled(elem) {
          return elem.disabled === true;
        },
        "checked": function checked(elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function selected(elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        "parent": function parent(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "empty": function empty(elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
          //   not comment, processing instructions, or others
          // Thanks to Diego Perini for the nodeName shortcut
          //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
          var nodeType;
          elem = elem.firstChild;

          while (elem) {
            if (elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4) {
              return false;
            }

            elem = elem.nextSibling;
          }

          return true;
        },
        "header": function header(elem) {
          return rheader.test(elem.nodeName);
        },
        "text": function text(elem) {
          var type, attr; // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
          // use getAttribute instead to test this case

          return elem.nodeName.toLowerCase() === "input" && (type = elem.type) === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type);
        },
        // Input types
        "radio": createInputPseudo("radio"),
        "checkbox": createInputPseudo("checkbox"),
        "file": createInputPseudo("file"),
        "password": createInputPseudo("password"),
        "image": createInputPseudo("image"),
        "submit": createButtonPseudo("submit"),
        "reset": createButtonPseudo("reset"),
        "button": function button(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "input": function input(elem) {
          return rinputs.test(elem.nodeName);
        },
        "focus": function focus(elem) {
          var doc = elem.ownerDocument;
          return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "active": function active(elem) {
          return elem === elem.ownerDocument.activeElement;
        },
        // Positional types
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          for (var i = 0; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          for (var i = 1; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          for (var i = argument < 0 ? argument + length : argument; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          for (var i = argument < 0 ? argument + length : argument; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };

    function siblingCheck(a, b, ret) {
      if (a === b) {
        return ret;
      }

      var cur = a.nextSibling;

      while (cur) {
        if (cur === b) {
          return -1;
        }

        cur = cur.nextSibling;
      }

      return 1;
    }

    sortOrder = docElem.compareDocumentPosition ? function (a, b) {
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }

      return (!a.compareDocumentPosition || !b.compareDocumentPosition ? a.compareDocumentPosition : a.compareDocumentPosition(b) & 4) ? -1 : 1;
    } : function (a, b) {
      // The nodes are identical, we can exit early
      if (a === b) {
        hasDuplicate = true;
        return 0; // Fallback to using sourceIndex (in IE) if it's available on both nodes
      } else if (a.sourceIndex && b.sourceIndex) {
        return a.sourceIndex - b.sourceIndex;
      }

      var al,
          bl,
          ap = [],
          bp = [],
          aup = a.parentNode,
          bup = b.parentNode,
          cur = aup; // If the nodes are siblings (or identical) we can do a quick check

      if (aup === bup) {
        return siblingCheck(a, b); // If no parents were found then the nodes are disconnected
      } else if (!aup) {
        return -1;
      } else if (!bup) {
        return 1;
      } // Otherwise they're somewhere else in the tree so we need
      // to build up a full list of the parentNodes for comparison


      while (cur) {
        ap.unshift(cur);
        cur = cur.parentNode;
      }

      cur = bup;

      while (cur) {
        bp.unshift(cur);
        cur = cur.parentNode;
      }

      al = ap.length;
      bl = bp.length; // Start walking down the tree looking for a discrepancy

      for (var i = 0; i < al && i < bl; i++) {
        if (ap[i] !== bp[i]) {
          return siblingCheck(ap[i], bp[i]);
        }
      } // We ended someplace up the tree so do a sibling check


      return i === al ? siblingCheck(a, bp[i], -1) : siblingCheck(ap[i], b, 1);
    }; // Always assume the presence of duplicates if sort doesn't
    // pass them to our comparison function (as in Google Chrome).

    [0, 0].sort(sortOrder);
    baseHasDuplicate = !hasDuplicate; // Document sorting and removing duplicates

    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          i = 1,
          j = 0;
      hasDuplicate = baseHasDuplicate;
      results.sort(sortOrder);

      if (hasDuplicate) {
        for (; elem = results[i]; i++) {
          if (elem === results[i - 1]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }

      return results;
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };

    function tokenize(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[expando][selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          tokens.push(matched = new Token(match.shift()));
          soFar = soFar.slice(matched.length); // Cast descendant combinators to space

          matched.type = match[0].replace(rtrim, " ");
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            tokens.push(matched = new Token(match.shift()));
            soFar = soFar.slice(matched.length);
            matched.type = type;
            matched.matches = match;
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && combinator.dir === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (checkNonElements || elem.nodeType === 1) {
            return matcher(elem, context, xml);
          }
        }
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
        if (!xml) {
          var cache,
              dirkey = dirruns + " " + doneName + " ",
              cachedkey = dirkey + cachedruns;

          while (elem = elem[dir]) {
            if (checkNonElements || elem.nodeType === 1) {
              if ((cache = elem[expando]) === cachedkey) {
                return elem.sizset;
              } else if (typeof cache === "string" && cache.indexOf(dirkey) === 0) {
                if (elem.sizset) {
                  return elem;
                }
              } else {
                elem[expando] = cachedkey;

                if (matcher(elem, context, xml)) {
                  elem.sizset = true;
                  return elem;
                }

                elem.sizset = false;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (checkNonElements || elem.nodeType === 1) {
              if (matcher(elem, context, xml)) {
                return elem;
              }
            }
          }
        }
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf.call(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && tokens.slice(0, i - 1).join("").replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && tokens.join(""));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function superMatcher(seed, context, xml, results, expandContext) {
        var elem,
            j,
            matcher,
            setMatched = [],
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            outermost = expandContext != null,
            contextBackup = outermostContext,
            // We must always have either seed elements or context
        elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
            // Nested matchers should use non-integer dirruns
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.E;

        if (outermost) {
          outermostContext = context !== document && context;
          cachedruns = superMatcher.el;
        } // Add elements passing elementMatchers directly to results


        for (; (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            for (j = 0; matcher = elementMatchers[j]; j++) {
              if (matcher(elem, context, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
              cachedruns = ++superMatcher.el;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // Apply set filters to unmatched elements


        matchedCount += i;

        if (bySet && i !== matchedCount) {
          for (j = 0; matcher = setMatchers[j]; j++) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      superMatcher.el = 0;
      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, group
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[expando][selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!group) {
          group = tokenize(selector);
        }

        i = group.length;

        while (i--) {
          cached = matcherFromTokens(group[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }

      return cached;
    };

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function select(selector, context, results, seed, xml) {
      var i,
          tokens,
          token,
          type,
          find,
          match = tokenize(selector),
          j = match.length;

      if (!seed) {
        // Try to minimize operations if there is only one group
        if (match.length === 1) {
          // Take a shortcut and set the context if the root selector is an ID
          tokens = match[0] = match[0].slice(0);

          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && !xml && Expr.relative[tokens[1].type]) {
            context = Expr.find["ID"](token.matches[0].replace(rbackslash, ""), context, xml)[0];

            if (!context) {
              return results;
            }

            selector = selector.slice(tokens.shift().length);
          } // Fetch a seed set for right-to-left matching


          for (i = matchExpr["POS"].test(selector) ? -1 : tokens.length - 1; i >= 0; i--) {
            token = tokens[i]; // Abort if we hit a combinator

            if (Expr.relative[type = token.type]) {
              break;
            }

            if (find = Expr.find[type]) {
              // Search, expanding context for leading sibling combinators
              if (seed = find(token.matches[0].replace(rbackslash, ""), rsibling.test(tokens[0].type) && context.parentNode || context, xml)) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && tokens.join("");

                if (!selector) {
                  push.apply(results, slice.call(seed, 0));
                  return results;
                }

                break;
              }
            }
          }
        }
      } // Compile and execute a filtering function
      // Provide `match` to avoid retokenization if we modified the selector above


      compile(selector, match)(seed, context, xml, results, rsibling.test(selector));
      return results;
    }

    if (document.querySelectorAll) {
      (function () {
        var disconnectedMatch,
            oldSelect = select,
            rescape = /'|\\/g,
            rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,
            // qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
        // A support test would require too much code (would include document ready)
        rbuggyQSA = [":focus"],
            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        // A support test would require too much code (would include document ready)
        // just skip matchesSelector for :active
        rbuggyMatches = [":active"],
            matches = docElem.matchesSelector || docElem.mozMatchesSelector || docElem.webkitMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector; // Build QSA regex
        // Regex strategy adopted from Diego Perini

        assert(function (div) {
          // Select is set to empty string on purpose
          // This is to test IE's treatment of not explictly
          // setting a boolean content attribute,
          // since its presence should be enough
          // http://bugs.jquery.com/ticket/12359
          div.innerHTML = "<select><option selected=''></option></select>"; // IE8 - Some boolean attributes are not treated correctly

          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here (do not put tests after this one)


          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
        });
        assert(function (div) {
          // Opera 10-12/IE9 - ^= $= *= and empty values
          // Should not select anything
          div.innerHTML = "<p test=''></p>";

          if (div.querySelectorAll("[test^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here (do not put tests after this one)


          div.innerHTML = "<input type='hidden'/>";

          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
        }); // rbuggyQSA always contains :focus, so no need for a length check

        rbuggyQSA =
        /* rbuggyQSA.length && */
        new RegExp(rbuggyQSA.join("|"));

        select = function select(selector, context, results, seed, xml) {
          // Only use querySelectorAll when not filtering,
          // when this is not xml,
          // and when no QSA bugs apply
          if (!seed && !xml && !rbuggyQSA.test(selector)) {
            var groups,
                i,
                old = true,
                nid = expando,
                newContext = context,
                newSelector = context.nodeType === 9 && selector; // qSA works strangely on Element-rooted queries
            // We can work around this by specifying an extra ID on the root
            // and working up from there (Thanks to Andrew Dupont for the technique)
            // IE 8 doesn't work on object elements

            if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
              groups = tokenize(selector);

              if (old = context.getAttribute("id")) {
                nid = old.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", nid);
              }

              nid = "[id='" + nid + "'] ";
              i = groups.length;

              while (i--) {
                groups[i] = nid + groups[i].join("");
              }

              newContext = rsibling.test(selector) && context.parentNode || context;
              newSelector = groups.join(",");
            }

            if (newSelector) {
              try {
                push.apply(results, slice.call(newContext.querySelectorAll(newSelector), 0));
                return results;
              } catch (qsaError) {} finally {
                if (!old) {
                  context.removeAttribute("id");
                }
              }
            }
          }

          return oldSelect(selector, context, results, seed, xml);
        };

        if (matches) {
          assert(function (div) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            disconnectedMatch = matches.call(div, "div"); // This should fail with an exception
            // Gecko does not error, returns false instead

            try {
              matches.call(div, "[test!='']:sizzle");
              rbuggyMatches.push("!=", pseudos);
            } catch (e) {}
          }); // rbuggyMatches always contains :active and :focus, so no need for a length check

          rbuggyMatches =
          /* rbuggyMatches.length && */
          new RegExp(rbuggyMatches.join("|"));

          Sizzle.matchesSelector = function (elem, expr) {
            // Make sure that attribute selectors are quoted
            expr = expr.replace(rattributeQuotes, "='$1']"); // rbuggyMatches always contains :active, so no need for an existence check

            if (!isXML(elem) && !rbuggyMatches.test(expr) && !rbuggyQSA.test(expr)) {
              try {
                var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

                if (ret || disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e) {}
            }

            return Sizzle(expr, null, null, [elem]).length > 0;
          };
        }
      })();
    } // Deprecated


    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Back-compat

    function setFilters() {}

    Expr.filters = setFilters.prototype = Expr.pseudos;
    Expr.setFilters = new setFilters(); // Override sizzle attribute retrieval

    Sizzle.attr = jQuery.attr;
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
  })(window);

  var runtil = /Until$/,
      rparentsprev = /^(?:parents|prev(?:Until|All))/,
      isSimple = /^.[^:#\[\.,]*$/,
      rneedsContext = jQuery.expr.match.needsContext,
      // methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    find: function find(selector) {
      var i,
          l,
          length,
          n,
          r,
          ret,
          self = this;

      if (typeof selector !== "string") {
        return jQuery(selector).filter(function () {
          for (i = 0, l = self.length; i < l; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        });
      }

      ret = this.pushStack("", "find", selector);

      for (i = 0, l = this.length; i < l; i++) {
        length = ret.length;
        jQuery.find(selector, this[i], ret);

        if (i > 0) {
          // Make sure that the results are unique
          for (n = length; n < ret.length; n++) {
            for (r = 0; r < length; r++) {
              if (ret[r] === ret[n]) {
                ret.splice(n--, 1);
                break;
              }
            }
          }
        }
      }

      return ret;
    },
    has: function has(target) {
      var i,
          targets = jQuery(target, this),
          len = targets.length;
      return this.filter(function () {
        for (i = 0; i < len; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector, false), "not", selector);
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector, true), "filter", selector);
    },
    is: function is(selector) {
      return !!selector && (typeof selector === "string" ? // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      rneedsContext.test(selector) ? jQuery(selector, this.context).index(this[0]) >= 0 : jQuery.filter(selector, this).length > 0 : this.filter(selector).length > 0);
    },
    closest: function closest(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          ret = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

      for (; i < l; i++) {
        cur = this[i];

        while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
          if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
            ret.push(cur);
            break;
          }

          cur = cur.parentNode;
        }
      }

      ret = ret.length > 1 ? jQuery.unique(ret) : ret;
      return this.pushStack(ret, "closest", selectors);
    },
    // Determine the position of an element within
    // the matched set of elements
    index: function index(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.prevAll().length : -1;
      } // index in selector


      if (typeof elem === "string") {
        return jQuery.inArray(this[0], jQuery(elem));
      } // Locate the position of the desired element


      return jQuery.inArray( // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem, this);
    },
    add: function add(selector, context) {
      var set = typeof selector === "string" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
          all = jQuery.merge(this.get(), set);
      return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ? all : jQuery.unique(all));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  jQuery.fn.andSelf = jQuery.fn.addBack; // A painfully simple check to see if an element is disconnected
  // from a document (should be improved, where feasible).

  function isDisconnected(node) {
    return !node || !node.parentNode || node.parentNode.nodeType === 11;
  }

  function sibling(cur, dir) {
    do {
      cur = cur[dir];
    } while (cur && cur.nodeType !== 1);

    return cur;
  }

  jQuery.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function contents(elem) {
      return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var ret = jQuery.map(this, fn, until);

      if (!runtil.test(name)) {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        ret = jQuery.filter(selector, ret);
      }

      ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

      if (this.length > 1 && rparentsprev.test(name)) {
        ret = ret.reverse();
      }

      return this.pushStack(ret, name, core_slice.call(arguments).join(","));
    };
  });
  jQuery.extend({
    filter: function filter(expr, elems, not) {
      if (not) {
        expr = ":not(" + expr + ")";
      }

      return elems.length === 1 ? jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] : jQuery.find.matches(expr, elems);
    },
    dir: function dir(elem, _dir, until) {
      var matched = [],
          cur = elem[_dir];

      while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
        if (cur.nodeType === 1) {
          matched.push(cur);
        }

        cur = cur[_dir];
      }

      return matched;
    },
    sibling: function sibling(n, elem) {
      var r = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          r.push(n);
        }
      }

      return r;
    }
  }); // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, keep) {
    // Can't pass null or undefined to indexOf in Firefox 4
    // Set to 0 to skip string check
    qualifier = qualifier || 0;

    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        var retVal = !!qualifier.call(elem, i, elem);
        return retVal === keep;
      });
    } else if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem, i) {
        return elem === qualifier === keep;
      });
    } else if (typeof qualifier === "string") {
      var filtered = jQuery.grep(elements, function (elem) {
        return elem.nodeType === 1;
      });

      if (isSimple.test(qualifier)) {
        return jQuery.filter(qualifier, filtered, !keep);
      } else {
        qualifier = jQuery.filter(qualifier, filtered);
      }
    }

    return jQuery.grep(elements, function (elem, i) {
      return jQuery.inArray(elem, qualifier) >= 0 === keep;
    });
  }

  function createSafeFragment(document) {
    var list = nodeNames.split("|"),
        safeFrag = document.createDocumentFragment();

    if (safeFrag.createElement) {
      while (list.length) {
        safeFrag.createElement(list.pop());
      }
    }

    return safeFrag;
  }

  var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" + "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
      rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
      rleadingWhitespace = /^\s+/,
      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rtagName = /<([\w:]+)/,
      rtbody = /<tbody/i,
      rhtml = /<|&#?\w+;/,
      rnoInnerhtml = /<(?:script|style|link)/i,
      rnocache = /<(?:script|object|embed|option|style)/i,
      rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
      rcheckableType = /^(?:checkbox|radio)$/,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptType = /\/(java|ecma)script/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
      wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    legend: [1, "<fieldset>", "</fieldset>"],
    thead: [1, "<table>", "</table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
    area: [1, "<map>", "</map>"],
    _default: [0, "", ""]
  },
      safeFragment = createSafeFragment(document),
      fragmentDiv = safeFragment.appendChild(document.createElement("div"));
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td; // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
  // unless wrapped in a div with non-breaking characters in front of it.

  if (!jQuery.support.htmlSerialize) {
    wrapMap._default = [1, "X<div>", "</div>"];
  }

  jQuery.fn.extend({
    text: function text(value) {
      return jQuery.access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    wrapAll: function wrapAll(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }

      if (this[0]) {
        // The elements to wrap the target around
        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstChild && elem.firstChild.nodeType === 1) {
            elem = elem.firstChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function wrapInner(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap() {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    },
    append: function append() {
      return this.domManip(arguments, true, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11) {
          this.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return this.domManip(arguments, true, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11) {
          this.insertBefore(elem, this.firstChild);
        }
      });
    },
    before: function before() {
      if (!isDisconnected(this[0])) {
        return this.domManip(arguments, false, function (elem) {
          this.parentNode.insertBefore(elem, this);
        });
      }

      if (arguments.length) {
        var set = jQuery.clean(arguments);
        return this.pushStack(jQuery.merge(set, this), "before", this.selector);
      }
    },
    after: function after() {
      if (!isDisconnected(this[0])) {
        return this.domManip(arguments, false, function (elem) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        });
      }

      if (arguments.length) {
        var set = jQuery.clean(arguments);
        return this.pushStack(jQuery.merge(this, set), "after", this.selector);
      }
    },
    // keepData is for internal use only--do not document
    remove: function remove(selector, keepData) {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (!selector || jQuery.filter(selector, [elem]).length) {
          if (!keepData && elem.nodeType === 1) {
            jQuery.cleanData(elem.getElementsByTagName("*"));
            jQuery.cleanData([elem]);
          }

          if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
          }
        }
      }

      return this;
    },
    empty: function empty() {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        // Remove element nodes and prevent memory leaks
        if (elem.nodeType === 1) {
          jQuery.cleanData(elem.getElementsByTagName("*"));
        } // Remove any remaining nodes


        while (elem.firstChild) {
          elem.removeChild(elem.firstChild);
        }
      }

      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return jQuery.access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined) {
          return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, "") : undefined;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && (jQuery.support.htmlSerialize || !rnoshimcache.test(value)) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "<$1></$2>");

          try {
            for (; i < l; i++) {
              // Remove element nodes and prevent memory leaks
              elem = this[i] || {};

              if (elem.nodeType === 1) {
                jQuery.cleanData(elem.getElementsByTagName("*"));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith(value) {
      if (!isDisconnected(this[0])) {
        // Make sure that the elements are removed from the DOM before they are inserted
        // this can help fix replacing a parent with child elements
        if (jQuery.isFunction(value)) {
          return this.each(function (i) {
            var self = jQuery(this),
                old = self.html();
            self.replaceWith(value.call(this, i, old));
          });
        }

        if (typeof value !== "string") {
          value = jQuery(value).detach();
        }

        return this.each(function () {
          var next = this.nextSibling,
              parent = this.parentNode;
          jQuery(this).remove();

          if (next) {
            jQuery(next).before(value);
          } else {
            jQuery(parent).append(value);
          }
        });
      }

      return this.length ? this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) : this;
    },
    detach: function detach(selector) {
      return this.remove(selector, true);
    },
    domManip: function domManip(args, table, callback) {
      // Flatten any nested arrays
      args = [].concat.apply([], args);
      var results,
          first,
          fragment,
          iNoClone,
          i = 0,
          value = args[0],
          scripts = [],
          l = this.length; // We can't cloneNode fragments that contain checked, in WebKit

      if (!jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test(value)) {
        return this.each(function () {
          jQuery(this).domManip(args, table, callback);
        });
      }

      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          var self = jQuery(this);
          args[0] = value.call(this, i, table ? self.html() : undefined);
          self.domManip(args, table, callback);
        });
      }

      if (this[0]) {
        results = jQuery.buildFragment(args, this, scripts);
        fragment = results.fragment;
        first = fragment.firstChild;

        if (fragment.childNodes.length === 1) {
          fragment = first;
        }

        if (first) {
          table = table && jQuery.nodeName(first, "tr"); // Use the original fragment for the last item instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).
          // Fragments from the fragment cache must always be cloned and never used in place.

          for (iNoClone = results.cacheable || l - 1; i < l; i++) {
            callback.call(table && jQuery.nodeName(this[i], "table") ? findOrAppend(this[i], "tbody") : this[i], i === iNoClone ? fragment : jQuery.clone(fragment, true, true));
          }
        } // Fix #11809: Avoid leaking memory


        fragment = first = null;

        if (scripts.length) {
          jQuery.each(scripts, function (i, elem) {
            if (elem.src) {
              if (jQuery.ajax) {
                jQuery.ajax({
                  url: elem.src,
                  type: "GET",
                  dataType: "script",
                  async: false,
                  global: false,
                  "throws": true
                });
              } else {
                jQuery.error("no ajax");
              }
            } else {
              jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, ""));
            }

            if (elem.parentNode) {
              elem.parentNode.removeChild(elem);
            }
          });
        }
      }

      return this;
    }
  });

  function findOrAppend(elem, tag) {
    return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));
  }

  function cloneCopyEvent(src, dest) {
    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
      return;
    }

    var type,
        i,
        l,
        oldData = jQuery._data(src),
        curData = jQuery._data(dest, oldData),
        events = oldData.events;

    if (events) {
      delete curData.handle;
      curData.events = {};

      for (type in events) {
        for (i = 0, l = events[type].length; i < l; i++) {
          jQuery.event.add(dest, type, events[type][i]);
        }
      }
    } // make the cloned public data object a copy from the original


    if (curData.data) {
      curData.data = jQuery.extend({}, curData.data);
    }
  }

  function cloneFixAttributes(src, dest) {
    var nodeName; // We do not need to do anything for non-Elements

    if (dest.nodeType !== 1) {
      return;
    } // clearAttributes removes the attributes, which we don't want,
    // but also removes the attachEvent events, which we *do* want


    if (dest.clearAttributes) {
      dest.clearAttributes();
    } // mergeAttributes, in contrast, only merges back on the
    // original attributes, not the events


    if (dest.mergeAttributes) {
      dest.mergeAttributes(src);
    }

    nodeName = dest.nodeName.toLowerCase();

    if (nodeName === "object") {
      // IE6-10 improperly clones children of object elements using classid.
      // IE10 throws NoModificationAllowedError if parent is null, #12132.
      if (dest.parentNode) {
        dest.outerHTML = src.outerHTML;
      } // This path appears unavoidable for IE9. When cloning an object
      // element in IE9, the outerHTML strategy above is not sufficient.
      // If the src has innerHTML and the destination does not,
      // copy the src.innerHTML into the dest.innerHTML. #10324


      if (jQuery.support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {
        dest.innerHTML = src.innerHTML;
      }
    } else if (nodeName === "input" && rcheckableType.test(src.type)) {
      // IE6-8 fails to persist the checked state of a cloned checkbox
      // or radio button. Worse, IE6-7 fail to give the cloned element
      // a checked appearance if the defaultChecked value isn't also set
      dest.defaultChecked = dest.checked = src.checked; // IE6-7 get confused and end up setting the value of a cloned
      // checkbox/radio button to an empty string instead of "on"

      if (dest.value !== src.value) {
        dest.value = src.value;
      } // IE6-8 fails to return the selected option to the default selected
      // state when cloning options

    } else if (nodeName === "option") {
      dest.selected = src.defaultSelected; // IE6-8 fails to set the defaultValue to the correct value when
      // cloning other types of input fields
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue; // IE blanks contents when cloning scripts
    } else if (nodeName === "script" && dest.text !== src.text) {
      dest.text = src.text;
    } // Event data gets referenced instead of copied if the expando
    // gets copied too


    dest.removeAttribute(jQuery.expando);
  }

  jQuery.buildFragment = function (args, context, scripts) {
    var fragment,
        cacheable,
        cachehit,
        first = args[0]; // Set context from what may come in as undefined or a jQuery collection or a node
    // Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
    // also doubles as fix for #8950 where plain objects caused createDocumentFragment exception

    context = context || document;
    context = !context.nodeType && context[0] || context;
    context = context.ownerDocument || context; // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
    // Cloning options loses the selected state, so don't cache them
    // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
    // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
    // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501

    if (args.length === 1 && typeof first === "string" && first.length < 512 && context === document && first.charAt(0) === "<" && !rnocache.test(first) && (jQuery.support.checkClone || !rchecked.test(first)) && (jQuery.support.html5Clone || !rnoshimcache.test(first))) {
      // Mark cacheable and look for a hit
      cacheable = true;
      fragment = jQuery.fragments[first];
      cachehit = fragment !== undefined;
    }

    if (!fragment) {
      fragment = context.createDocumentFragment();
      jQuery.clean(args, context, fragment, scripts); // Update the cache, but only store false
      // unless this is a second parsing of the same content

      if (cacheable) {
        jQuery.fragments[first] = cachehit && fragment;
      }
    }

    return {
      fragment: fragment,
      cacheable: cacheable
    };
  };

  jQuery.fragments = {};
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          i = 0,
          ret = [],
          insert = jQuery(selector),
          l = insert.length,
          parent = this.length === 1 && this[0].parentNode;

      if ((parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1) {
        insert[original](this[0]);
        return this;
      } else {
        for (; i < l; i++) {
          elems = (i > 0 ? this.clone(true) : this).get();
          jQuery(insert[i])[original](elems);
          ret = ret.concat(elems);
        }

        return this.pushStack(ret, name, insert.selector);
      }
    };
  });

  function getAll(elem) {
    if (typeof elem.getElementsByTagName !== "undefined") {
      return elem.getElementsByTagName("*");
    } else if (typeof elem.querySelectorAll !== "undefined") {
      return elem.querySelectorAll("*");
    } else {
      return [];
    }
  } // Used in clean, fixes the defaultChecked property


  function fixDefaultChecked(elem) {
    if (rcheckableType.test(elem.type)) {
      elem.defaultChecked = elem.checked;
    }
  }

  jQuery.extend({
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var srcElements, destElements, i, clone;

      if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
        clone = elem.cloneNode(true); // IE<=8 does not properly clone detached, unknown element nodes
      } else {
        fragmentDiv.innerHTML = elem.outerHTML;
        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
      }

      if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // IE copies events bound via attachEvent when using cloneNode.
        // Calling detachEvent on the clone will also remove the events
        // from the original. In order to get around this, we use some
        // proprietary methods to clear the events. Thanks to MooTools
        // guys for this hotness.
        cloneFixAttributes(elem, clone); // Using Sizzle here is crazy slow, so we use getElementsByTagName instead

        srcElements = getAll(elem);
        destElements = getAll(clone); // Weird iteration because IE will replace the length property
        // with an element if you are cloning the body and one of the
        // elements on the page has a name or id of "length"

        for (i = 0; srcElements[i]; ++i) {
          // Ensure that the destination node is not null; Fixes #9587
          if (destElements[i]) {
            cloneFixAttributes(srcElements[i], destElements[i]);
          }
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        cloneCopyEvent(elem, clone);

        if (deepDataAndEvents) {
          srcElements = getAll(elem);
          destElements = getAll(clone);

          for (i = 0; srcElements[i]; ++i) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        }
      }

      srcElements = destElements = null; // Return the cloned set

      return clone;
    },
    clean: function clean(elems, context, fragment, scripts) {
      var i,
          j,
          elem,
          tag,
          wrap,
          depth,
          div,
          hasBody,
          tbody,
          len,
          handleScript,
          jsTags,
          safe = context === document && safeFragment,
          ret = []; // Ensure that context is a document

      if (!context || typeof context.createDocumentFragment === "undefined") {
        context = document;
      } // Use the already-created safe fragment if context permits


      for (i = 0; (elem = elems[i]) != null; i++) {
        if (typeof elem === "number") {
          elem += "";
        }

        if (!elem) {
          continue;
        } // Convert html string into DOM nodes


        if (typeof elem === "string") {
          if (!rhtml.test(elem)) {
            elem = context.createTextNode(elem);
          } else {
            // Ensure a safe container in which to render the html
            safe = safe || createSafeFragment(context);
            div = context.createElement("div");
            safe.appendChild(div); // Fix "XHTML"-style tags in all browsers

            elem = elem.replace(rxhtmlTag, "<$1></$2>"); // Go to html and back, then peel off extra wrappers

            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            depth = wrap[0];
            div.innerHTML = wrap[1] + elem + wrap[2]; // Move to the right depth

            while (depth--) {
              div = div.lastChild;
            } // Remove IE's autoinserted <tbody> from table fragments


            if (!jQuery.support.tbody) {
              // String was a <table>, *may* have spurious <tbody>
              hasBody = rtbody.test(elem);
              tbody = tag === "table" && !hasBody ? div.firstChild && div.firstChild.childNodes : // String was a bare <thead> or <tfoot>
              wrap[1] === "<table>" && !hasBody ? div.childNodes : [];

              for (j = tbody.length - 1; j >= 0; --j) {
                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                  tbody[j].parentNode.removeChild(tbody[j]);
                }
              }
            } // IE completely kills leading whitespace when innerHTML is used


            if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
              div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
            }

            elem = div.childNodes; // Take out of fragment container (we need a fresh div each time)

            div.parentNode.removeChild(div);
          }
        }

        if (elem.nodeType) {
          ret.push(elem);
        } else {
          jQuery.merge(ret, elem);
        }
      } // Fix #11356: Clear elements from safeFragment


      if (div) {
        elem = div = safe = null;
      } // Reset defaultChecked for any radios and checkboxes
      // about to be appended to the DOM in IE 6/7 (#8060)


      if (!jQuery.support.appendChecked) {
        for (i = 0; (elem = ret[i]) != null; i++) {
          if (jQuery.nodeName(elem, "input")) {
            fixDefaultChecked(elem);
          } else if (typeof elem.getElementsByTagName !== "undefined") {
            jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
          }
        }
      } // Append elements to a provided document fragment


      if (fragment) {
        // Special handling of each script element
        handleScript = function handleScript(elem) {
          // Check if we consider it executable
          if (!elem.type || rscriptType.test(elem.type)) {
            // Detach the script and store it in the scripts array (if provided) or the fragment
            // Return truthy to indicate that it has been handled
            return scripts ? scripts.push(elem.parentNode ? elem.parentNode.removeChild(elem) : elem) : fragment.appendChild(elem);
          }
        };

        for (i = 0; (elem = ret[i]) != null; i++) {
          // Check if we're done after handling an executable script
          if (!(jQuery.nodeName(elem, "script") && handleScript(elem))) {
            // Append to fragment and handle embedded scripts
            fragment.appendChild(elem);

            if (typeof elem.getElementsByTagName !== "undefined") {
              // handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
              jsTags = jQuery.grep(jQuery.merge([], elem.getElementsByTagName("script")), handleScript); // Splice the scripts into ret after their former ancestor and advance our index beyond them

              ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
              i += jsTags.length;
            }
          }
        }
      }

      return ret;
    },
    cleanData: function cleanData(elems,
    /* internal */
    acceptData) {
      var data,
          id,
          elem,
          type,
          i = 0,
          internalKey = jQuery.expando,
          cache = jQuery.cache,
          deleteExpando = jQuery.support.deleteExpando,
          special = jQuery.event.special;

      for (; (elem = elems[i]) != null; i++) {
        if (acceptData || jQuery.acceptData(elem)) {
          id = elem[internalKey];
          data = id && cache[id];

          if (data) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Remove cache only if it was not already removed by jQuery.event.remove


            if (cache[id]) {
              delete cache[id]; // IE does not allow us to delete expando properties from nodes,
              // nor does it have a removeAttribute function on Document nodes;
              // we must handle all of these cases

              if (deleteExpando) {
                delete elem[internalKey];
              } else if (elem.removeAttribute) {
                elem.removeAttribute(internalKey);
              } else {
                elem[internalKey] = null;
              }

              jQuery.deletedIds.push(id);
            }
          }
        }
      }
    }
  }); // Limit scope pollution from any deprecated API

  (function () {
    var matched, browser; // Use of jQuery.browser is frowned upon.
    // More details: http://api.jquery.com/jQuery.browser
    // jQuery.uaMatch maintained for back-compat

    jQuery.uaMatch = function (ua) {
      ua = ua.toLowerCase();
      var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
      return {
        browser: match[1] || "",
        version: match[2] || "0"
      };
    };

    matched = jQuery.uaMatch(navigator.userAgent);
    browser = {};

    if (matched.browser) {
      browser[matched.browser] = true;
      browser.version = matched.version;
    } // Chrome is Webkit, but Webkit is also Safari.


    if (browser.chrome) {
      browser.webkit = true;
    } else if (browser.webkit) {
      browser.safari = true;
    }

    jQuery.browser = browser;

    jQuery.sub = function () {
      function jQuerySub(selector, context) {
        return new jQuerySub.fn.init(selector, context);
      }

      jQuery.extend(true, jQuerySub, this);
      jQuerySub.superclass = this;
      jQuerySub.fn = jQuerySub.prototype = this();
      jQuerySub.fn.constructor = jQuerySub;
      jQuerySub.sub = this.sub;

      jQuerySub.fn.init = function init(selector, context) {
        if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
          context = jQuerySub(context);
        }

        return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
      };

      jQuerySub.fn.init.prototype = jQuerySub.fn;
      var rootjQuerySub = jQuerySub(document);
      return jQuerySub;
    };
  })();

  var curCSS,
      iframe,
      iframeDoc,
      ralpha = /alpha\([^)]*\)/i,
      ropacity = /opacity=([^)]*)/,
      rposition = /^(top|right|bottom|left)$/,
      // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
  // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rmargin = /^margin/,
      rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
      rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
      rrelNum = new RegExp("^([-+])=(" + core_pnum + ")", "i"),
      elemdisplay = {
    BODY: "block"
  },
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: 0,
    fontWeight: 400
  },
      cssExpand = ["Top", "Right", "Bottom", "Left"],
      cssPrefixes = ["Webkit", "O", "Moz", "ms"],
      eventsToggle = jQuery.fn.toggle; // return a css property mapped to a potentially vendor prefixed property

  function vendorPropName(style, name) {
    // shortcut for names that are not vendor prefixed
    if (name in style) {
      return name;
    } // check for vendor prefixed names


    var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in style) {
        return name;
      }
    }

    return origName;
  }

  function isHidden(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  }

  function showHide(elements, show) {
    var elem,
        display,
        values = [],
        index = 0,
        length = elements.length;

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      values[index] = jQuery._data(elem, "olddisplay");

      if (show) {
        // Reset the inline display of this element to learn if it is
        // being hidden by cascaded rules or not
        if (!values[index] && elem.style.display === "none") {
          elem.style.display = "";
        } // Set elements which have been overridden with display: none
        // in a stylesheet to whatever the default browser style is
        // for such an element


        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = jQuery._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
        }
      } else {
        display = curCSS(elem, "display");

        if (!values[index] && display !== "none") {
          jQuery._data(elem, "olddisplay", display);
        }
      }
    } // Set the display of most of the elements in a second loop
    // to avoid the constant reflow


    for (index = 0; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    css: function css(name, value) {
      return jQuery.access(this, function (elem, name, value) {
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state, fn2) {
      var bool = typeof state === "boolean";

      if (jQuery.isFunction(state) && jQuery.isFunction(fn2)) {
        return eventsToggle.apply(this, arguments);
      }

      return this.each(function () {
        if (bool ? state : isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Exclude the following css properties to add px
    cssNumber: {
      "fillOpacity": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
      // normalize float css property
      "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
    },
    // Get and set the style property on a DOM Node
    style: function style(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)); // gets hook for the prefixed version
      // followed by the unprefixed version

      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = _typeof(value); // convert relative number strings (+= or -=) to relative numbers. #7345

        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)); // Fixes bug #9237

          type = "number";
        } // Make sure that NaN and null values aren't set. See: #7116


        if (value == null || type === "number" && isNaN(value)) {
          return;
        } // If a number was passed in, add 'px' to the (except for certain CSS properties)


        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
          // Fixes bug #5509
          try {
            style[name] = value;
          } catch (e) {}
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function css(elem, name, numeric, extra) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name); // Make sure that we're working with the right name

      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)); // gets hook for the prefixed version
      // followed by the unprefixed version

      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name);
      } //convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Return, converting to number if forced or a qualifier was provided and val looks numeric


      if (numeric || extra !== undefined) {
        num = parseFloat(val);
        return numeric || jQuery.isNumeric(num) ? num || 0 : val;
      }

      return val;
    },
    // A method for quickly swapping in/out CSS properties to get correct calculations
    swap: function swap(elem, options, callback) {
      var ret,
          name,
          old = {}; // Remember the old values, and insert the new ones

      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }

      ret = callback.call(elem); // Revert the old values

      for (name in options) {
        elem.style[name] = old[name];
      }

      return ret;
    }
  }); // NOTE: To any future maintainer, we've window.getComputedStyle
  // because jsdom on node.js will break without it.

  if (window.getComputedStyle) {
    curCSS = function curCSS(elem, name) {
      var ret,
          width,
          minWidth,
          maxWidth,
          computed = window.getComputedStyle(elem, null),
          style = elem.style;

      if (computed) {
        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
        ret = computed.getPropertyValue(name) || computed[name];

        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        } // A tribute to the "awesome hack by Dean Edwards"
        // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values


        if (rnumnonpx.test(ret) && rmargin.test(name)) {
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }

      return ret;
    };
  } else if (document.documentElement.currentStyle) {
    curCSS = function curCSS(elem, name) {
      var left,
          rsLeft,
          ret = elem.currentStyle && elem.currentStyle[name],
          style = elem.style; // Avoid setting ret to empty string here
      // so we don't default to auto

      if (ret == null && style && style[name]) {
        ret = style[name];
      } // From the awesome hack by Dean Edwards
      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
      // If we're not dealing with a regular pixel number
      // but a number that has a weird ending, we need to convert it to pixels
      // but not position css attributes, as those are proportional to the parent element instead
      // and we can't measure the parent instead because it might trigger a "stacking dolls" problem


      if (rnumnonpx.test(ret) && !rposition.test(name)) {
        // Remember the original values
        left = style.left;
        rsLeft = elem.runtimeStyle && elem.runtimeStyle.left; // Put in the new values to get a computed value out

        if (rsLeft) {
          elem.runtimeStyle.left = elem.currentStyle.left;
        }

        style.left = name === "fontSize" ? "1em" : ret;
        ret = style.pixelLeft + "px"; // Revert the changed values

        style.left = left;

        if (rsLeft) {
          elem.runtimeStyle.left = rsLeft;
        }
      }

      return ret === "" ? "auto" : ret;
    };
  }

  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
  }

  function augmentWidthOrHeight(elem, name, extra, isBorderBox) {
    var i = extra === (isBorderBox ? "border" : "content") ? // If we already have the right measurement, avoid augmentation
    4 : // Otherwise initialize for horizontal or vertical properties
    name === "width" ? 1 : 0,
        val = 0;

    for (; i < 4; i += 2) {
      // both box models exclude margin, so add it if we want it
      if (extra === "margin") {
        // we use jQuery.css instead of curCSS here
        // because of the reliableMarginRight CSS hook!
        val += jQuery.css(elem, extra + cssExpand[i], true);
      } // From this point on we use curCSS for maximum performance (relevant in animations)


      if (isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if (extra === "content") {
          val -= parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;
        } // at this point, extra isn't border nor margin, so remove border


        if (extra !== "margin") {
          val -= parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
        }
      } else {
        // at this point, extra isn't content, so add padding
        val += parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0; // at this point, extra isn't content nor padding, so add border

        if (extra !== "padding") {
          val += parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
        }
      }
    }

    return val;
  }

  function getWidthOrHeight(elem, name, extra) {
    // Start with offset property, which is equivalent to the border-box value
    var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        valueIsBorderBox = true,
        isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box"; // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668

    if (val <= 0 || val == null) {
      // Fall back to computed then uncomputed css if necessary
      val = curCSS(elem, name);

      if (val < 0 || val == null) {
        val = elem.style[name];
      } // Computed unit is not pixels. Stop here and return.


      if (rnumnonpx.test(val)) {
        return val;
      } // we need the check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style


      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]); // Normalize "", auto, and prepare for extra

      val = parseFloat(val) || 0;
    } // use the active box-sizing model to add/subtract irrelevant styles


    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox) + "px";
  } // Try to determine the default display value of an element


  function css_defaultDisplay(nodeName) {
    if (elemdisplay[nodeName]) {
      return elemdisplay[nodeName];
    }

    var elem = jQuery("<" + nodeName + ">").appendTo(document.body),
        display = elem.css("display");
    elem.remove(); // If the simple way fails,
    // get element's real default display by attaching it to a temp iframe

    if (display === "none" || display === "") {
      // Use the already-created iframe if possible
      iframe = document.body.appendChild(iframe || jQuery.extend(document.createElement("iframe"), {
        frameBorder: 0,
        width: 0,
        height: 0
      })); // Create a cacheable copy of the iframe document on first call.
      // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
      // document to it; WebKit & Firefox won't allow reusing the iframe document.

      if (!iframeDoc || !iframe.createElement) {
        iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
        iframeDoc.write("<!doctype html><html><body>");
        iframeDoc.close();
      }

      elem = iframeDoc.body.appendChild(iframeDoc.createElement(nodeName));
      display = curCSS(elem, "display");
      document.body.removeChild(iframe);
    } // Store the correct default display


    elemdisplay[nodeName] = display;
    return display;
  }

  jQuery.each(["height", "width"], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          // certain elements can have dimension info if we invisibly show them
          // however, it must have a current display style that would benefit from this
          if (elem.offsetWidth === 0 && rdisplayswap.test(curCSS(elem, "display"))) {
            return jQuery.swap(elem, cssShow, function () {
              return getWidthOrHeight(elem, name, extra);
            });
          } else {
            return getWidthOrHeight(elem, name, extra);
          }
        }
      },
      set: function set(elem, value, extra) {
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box") : 0);
      }
    };
  });

  if (!jQuery.support.opacity) {
    jQuery.cssHooks.opacity = {
      get: function get(elem, computed) {
        // IE uses filters for opacity
        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? 0.01 * parseFloat(RegExp.$1) + "" : computed ? "1" : "";
      },
      set: function set(elem, value) {
        var style = elem.style,
            currentStyle = elem.currentStyle,
            opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
            filter = currentStyle && currentStyle.filter || style.filter || ""; // IE has trouble with opacity if it does not have layout
        // Force it by setting the zoom level

        style.zoom = 1; // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652

        if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "" && style.removeAttribute) {
          // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
          // if "filter:" is present at all, clearType is disabled, we want to avoid this
          // style.removeAttribute is IE Only, but so apparently is this code path...
          style.removeAttribute("filter"); // if there there is no filter style applied in a css rule, we are done

          if (currentStyle && !currentStyle.filter) {
            return;
          }
        } // otherwise, set new filter values


        style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
      }
    };
  } // These hooks cannot be added until DOM ready because the support test
  // for it is not run until after DOM ready


  jQuery(function () {
    if (!jQuery.support.reliableMarginRight) {
      jQuery.cssHooks.marginRight = {
        get: function get(elem, computed) {
          // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
          // Work around by temporarily setting element display to inline-block
          return jQuery.swap(elem, {
            "display": "inline-block"
          }, function () {
            if (computed) {
              return curCSS(elem, "marginRight");
            }
          });
        }
      };
    } // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here


    if (!jQuery.support.pixelPosition && jQuery.fn.position) {
      jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = {
          get: function get(elem, computed) {
            if (computed) {
              var ret = curCSS(elem, prop); // if curCSS returns percentage, fallback to offset

              return rnumnonpx.test(ret) ? jQuery(elem).position()[prop] + "px" : ret;
            }
          }
        };
      });
    }
  });

  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.hidden = function (elem) {
      return elem.offsetWidth === 0 && elem.offsetHeight === 0 || !jQuery.support.reliableHiddenOffsets && (elem.style && elem.style.display || curCSS(elem, "display")) === "none";
    };

    jQuery.expr.filters.visible = function (elem) {
      return !jQuery.expr.filters.hidden(elem);
    };
  } // These hooks are used by animate to expand properties


  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i,
            // assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value],
            expanded = {};

        for (i = 0; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
      rselectTextarea = /^(?:select|textarea)/i;
  jQuery.fn.extend({
    serialize: function serialize() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        return this.elements ? jQuery.makeArray(this.elements) : this;
      }).filter(function () {
        return this.name && !this.disabled && (this.checked || rselectTextarea.test(this.nodeName) || rinput.test(this.type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val, i) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  }); //Serialize an array of form elements or a set of
  //key/values into a query string

  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function add(key, value) {
      // If value is a function, invoke it and return its value
      value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }; // Set traditional to true for jQuery <= 1.3.2 behavior.


    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    } // If an array was passed in, assume that it is an array of form elements.


    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&").replace(r20, "+");
  };

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (jQuery.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // If array item is non-scalar (array or object), encode its
          // numeric index to resolve deserialization ambiguity issues.
          // Note that rack (as of 1.0.0) can't currently deserialize
          // nested arrays properly, and attempting to do so may cause
          // a server error. Possible fixes are to modify rack's
          // deserialization algorithm or to provide an option or flag
          // to force array serialization to be shallow.
          buildParams(prefix + "[" + (_typeof(v) === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  }

  var // Document location
  ajaxLocParts,
      ajaxLocation,
      rhash = /#.*$/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
      // IE leaves an \r character at EOL
  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      rquery = /\?/,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      rts = /([?&])_=[^&]*/,
      rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
      // Keep a copy of the old load method
  _load = jQuery.fn.load,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = ["*/"] + ["*"]; // #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set

  try {
    ajaxLocation = location.href;
  } catch (e) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement("a");
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
  } // Segment location into parts


  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          list,
          placeBefore,
          dataTypes = dataTypeExpression.toLowerCase().split(core_rspace),
          i = 0,
          length = dataTypes.length;

      if (jQuery.isFunction(func)) {
        // For each dataType in the dataTypeExpression
        for (; i < length; i++) {
          dataType = dataTypes[i]; // We control if we're asked to add before
          // any existing element

          placeBefore = /^\+/.test(dataType);

          if (placeBefore) {
            dataType = dataType.substr(1) || "*";
          }

          list = structure[dataType] = structure[dataType] || []; // then we add to the structure accordingly

          list[placeBefore ? "unshift" : "push"](func);
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, dataType
  /* internal */
  , inspected
  /* internal */
  ) {
    dataType = dataType || options.dataTypes[0];
    inspected = inspected || {};
    inspected[dataType] = true;
    var selection,
        list = structure[dataType],
        i = 0,
        length = list ? list.length : 0,
        executeOnly = structure === prefilters;

    for (; i < length && (executeOnly || !selection); i++) {
      selection = list[i](options, originalOptions, jqXHR); // If we got redirected to another dataType
      // we try there if executing only and not done already

      if (typeof selection === "string") {
        if (!executeOnly || inspected[selection]) {
          selection = undefined;
        } else {
          options.dataTypes.unshift(selection);
          selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, selection, inspected);
        }
      }
    } // If we're only executing or nothing was selected
    // we try the catchall dataType if not done already


    if ((executeOnly || !selection) && !inspected["*"]) {
      selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, "*", inspected);
    } // unnecessary when only executing (prefilters)
    // but it'll be ignored by the caller in that case


    return selection;
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }
  }

  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    } // Don't do a request if no elements are being requested


    if (!this.length) {
      return this;
    }

    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off >= 0) {
      selector = url.slice(off, url.length);
      url = url.slice(0, off);
    } // If it's a function


    if (jQuery.isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && _typeof(params) === "object") {
      type = "POST";
    } // Request the remote document


    jQuery.ajax({
      url: url,
      // if "type" variable is undefined, then "GET" method will be used
      type: type,
      dataType: "html",
      data: params,
      complete: function complete(jqXHR, status) {
        if (callback) {
          self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
        }
      }
    }).done(function (responseText) {
      // Save response for use in complete callback
      response = arguments; // See if a selector was specified

      self.html(selector ? // Create a dummy div to hold the results
      jQuery("<div>") // inject the contents of the document in, removing the scripts
      // to avoid any 'Permission Denied' errors in IE
      .append(responseText.replace(rscript, "")) // Locate the specified elements
      .find(selector) : // If not, just inject the full result
      responseText);
    });
    return this;
  }; // Attach a bunch of functions for handling common AJAX events


  jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
    jQuery.fn[o] = function (f) {
      return this.on(o, f);
    };
  });
  jQuery.each(["get", "post"], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // shift arguments if data argument was omitted
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }

      return jQuery.ajax({
        type: method,
        url: url,
        data: data,
        success: callback,
        dataType: type
      });
    };
  });
  jQuery.extend({
    getScript: function getScript(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    },
    getJSON: function getJSON(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function ajaxSetup(target, settings) {
      if (settings) {
        // Building a settings object
        ajaxExtend(target, jQuery.ajaxSettings);
      } else {
        // Extending ajaxSettings
        settings = target;
        target = jQuery.ajaxSettings;
      }

      ajaxExtend(target, settings);
      return target;
    },
    ajaxSettings: {
      url: ajaxLocation,
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      type: "GET",
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      processData: true,
      async: true,

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        xml: "application/xml, text/xml",
        html: "text/html",
        text: "text/plain",
        json: "application/json, text/javascript",
        "*": allTypes
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText"
      },
      // List of data converters
      // 1) key format is "source_type destination_type" (a single space in-between)
      // 2) the catchall symbol "*" can be used for source_type
      converters: {
        // Convert anything to text
        "* text": window.String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": jQuery.parseJSON,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        context: true,
        url: true
      }
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function ajax(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (_typeof(url) === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};
      var // ifModified key
      ifModifiedKey,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // transport
      transport,
          // timeout handle
      timeoutTimer,
          // Cross-domain detection vars
      parts,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events
      // It's the callbackContext if one was provided in the options
      // and if it's a DOM node or a jQuery collection
      globalEventContext = callbackContext !== s && (callbackContext.nodeType || callbackContext instanceof jQuery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // The jqXHR state
      state = 0,
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Caches the header
        setRequestHeader: function setRequestHeader(name, value) {
          if (!state) {
            var lname = name.toLowerCase();
            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Raw string
        getAllResponseHeaders: function getAllResponseHeaders() {
          return state === 2 ? responseHeadersString : null;
        },
        // Builds headers hashtable if needed
        getResponseHeader: function getResponseHeader(key) {
          var match;

          if (state === 2) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase()] = match[2];
              }
            }

            match = responseHeaders[key.toLowerCase()];
          }

          return match === undefined ? null : match;
        },
        // Overrides response content-type header
        overrideMimeType: function overrideMimeType(type) {
          if (!state) {
            s.mimeType = type;
          }

          return this;
        },
        // Cancel the request
        abort: function abort(statusText) {
          statusText = statusText || strAbort;

          if (transport) {
            transport.abort(statusText);
          }

          done(0, statusText);
          return this;
        }
      }; // Callback for when everything is done
      // It is defined here because jslint complains if it is declared
      // at the end of the function (which would be more logical and readable)

      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Called once

        if (state === 2) {
          return;
        } // State is "done" now


        state = 2; // Clear timeout if it exists

        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // If successful, handle type chaining


        if (status >= 200 && status < 300 || status === 304) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[ifModifiedKey] = modified;
            }

            modified = jqXHR.getResponseHeader("Etag");

            if (modified) {
              jQuery.etag[ifModifiedKey] = modified;
            }
          } // If not modified


          if (status === 304) {
            statusText = "notmodified";
            isSuccess = true; // If we have data
          } else {
            isSuccess = ajaxConvert(s, response);
            statusText = isSuccess.state;
            success = isSuccess.data;
            error = isSuccess.error;
            isSuccess = !error;
          }
        } else {
          // We extract error from statusText
          // then normalize statusText and status for non-aborts
          error = statusText;

          if (!statusText || status) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"), [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      } // Attach deferreds


      deferred.promise(jqXHR);
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      jqXHR.complete = completeDeferred.add; // Status-dependent callbacks

      jqXHR.statusCode = function (map) {
        if (map) {
          var tmp;

          if (state < 2) {
            for (tmp in map) {
              statusCode[tmp] = [statusCode[tmp], map[tmp]];
            }
          } else {
            tmp = map[jqXHR.status];
            jqXHR.always(tmp);
          }
        }

        return this;
      }; // Remove hash character (#7531: and string promotion)
      // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
      // We also use the url parameter if available


      s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"); // Extract dataTypes list

      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(core_rspace); // A cross-domain request is in order when we have a protocol:host:port mismatch

      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))));
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (state === 2) {
        return jqXHR;
      } // We can fire global events as of now if asked to


      fireGlobals = s.global; // Uppercase the type

      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // More options handling for requests with no content


      if (!s.hasContent) {
        // If data is available, append data to url
        if (s.data) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Get ifModifiedKey before adding the anti-cache parameter


        ifModifiedKey = s.url; // Add anti-cache in url if needed

        if (s.cache === false) {
          var ts = jQuery.now(),
              // try replacing _= if it is there
          ret = s.url.replace(rts, "$1_=" + ts); // if nothing was replaced, add timestamp to the end

          s.url = ret + (ret === s.url ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        ifModifiedKey = ifModifiedKey || s.url;

        if (jQuery.lastModified[ifModifiedKey]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
        }

        if (jQuery.etag[ifModifiedKey]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
        }
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      } // Get transport


      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Propagate exception as error if not done
          if (state < 2) {
            done(-1, e); // Simply rethrow otherwise
          } else {
            throw e;
          }
        }
      }

      return jqXHR;
    },
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {}
  });
  /* Handles responses to an ajax request:
   * - sets all responseXXX fields accordingly
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */

  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes,
        responseFields = s.responseFields; // Fill responseXXX fields

    for (type in responseFields) {
      if (type in responses) {
        jqXHR[responseFields[type]] = responses[type];
      }
    } // Remove auto dataType and get content-type in the process


    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("content-type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  } // Chain conversions given the request and the original response


  function ajaxConvert(s, response) {
    var conv,
        conv2,
        current,
        tmp,
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(),
        prev = dataTypes[0],
        converters = {},
        i = 0; // Apply the dataFilter if provided

    if (s.dataFilter) {
      response = s.dataFilter(response, s.dataType);
    } // Create converters map with lowercased keys


    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    } // Convert to each sequential dataType, tolerating list modification


    for (; current = dataTypes[++i];) {
      // There's only work to do if current dataType is non-auto
      if (current !== "*") {
        // Convert response if prev dataType is non-auto and differs from current
        if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.splice(i--, 0, current);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        } // Update prev for next iteration


        prev = current;
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  var oldCallbacks = [],
      rquestion = /\?/,
      rjsonp = /(=)\?(?=&|$)|\?\?/,
      nonce = jQuery.now(); // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        data = s.data,
        url = s.url,
        hasCallback = s.jsonp !== false,
        replaceInUrl = hasCallback && rjsonp.test(url),
        replaceInData = hasCallback && !replaceInUrl && typeof data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(data); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (s.dataTypes[0] === "jsonp" || replaceInUrl || replaceInData) {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      overwritten = window[callbackName]; // Insert callback into url or form data

      if (replaceInUrl) {
        s.url = url.replace(rjsonp, "$1" + callbackName);
      } else if (replaceInData) {
        s.data = data.replace(rjsonp, "$1" + callbackName);
      } else if (hasCallback) {
        s.url += (rquestion.test(url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // force json dataType


      s.dataTypes[0] = "json"; // Install callback

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // Restore preexisting value
        window[callbackName] = overwritten; // Save back as free

        if (s[callbackName]) {
          // make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /javascript|ecmascript/
    },
    converters: {
      "text script": function textScript(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and global

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
      s.global = false;
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script,
          head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
      return {
        send: function send(_, callback) {
          script = document.createElement("script");
          script.async = "async";

          if (s.scriptCharset) {
            script.charset = s.scriptCharset;
          }

          script.src = s.url; // Attach handlers for all browsers

          script.onload = script.onreadystatechange = function (_, isAbort) {
            if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
              // Handle memory leak in IE
              script.onload = script.onreadystatechange = null; // Remove the script

              if (head && script.parentNode) {
                head.removeChild(script);
              } // Dereference the script


              script = undefined; // Callback if not abort

              if (!isAbort) {
                callback(200, "success");
              }
            }
          }; // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
          // This arises when a base node is used (#2709 and #4378).


          head.insertBefore(script, head.firstChild);
        },
        abort: function abort() {
          if (script) {
            script.onload(0, 1);
          }
        }
      };
    }
  });
  var xhrCallbacks,
      // #5280: Internet Explorer will keep connections alive if we don't abort on unload
  xhrOnUnloadAbort = window.ActiveXObject ? function () {
    // Abort all pending requests
    for (var key in xhrCallbacks) {
      xhrCallbacks[key](0, 1);
    }
  } : false,
      xhrId = 0; // Functions to create xhrs

  function createStandardXHR() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  }

  function createActiveXHR() {
    try {
      return new window.ActiveXObject("Microsoft.XMLHTTP");
    } catch (e) {}
  } // Create the request object
  // (This is still attached to ajaxSettings for backward compatibility)


  jQuery.ajaxSettings.xhr = window.ActiveXObject ?
  /* Microsoft failed to properly
   * implement the XMLHttpRequest in IE7 (can't request local files),
   * so we use the ActiveXObject when it is available
   * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
   * we need a fallback.
   */
  function () {
    return !this.isLocal && createStandardXHR() || createActiveXHR();
  } : // For all other browsers, use the standard XMLHttpRequest object
  createStandardXHR; // Determine support properties

  (function (xhr) {
    jQuery.extend(jQuery.support, {
      ajax: !!xhr,
      cors: !!xhr && "withCredentials" in xhr
    });
  })(jQuery.ajaxSettings.xhr()); // Create transport if the browser can provide an xhr


  if (jQuery.support.ajax) {
    jQuery.ajaxTransport(function (s) {
      // Cross domain only allowed if supported through XMLHttpRequest
      if (!s.crossDomain || jQuery.support.cors) {
        var _callback;

        return {
          send: function send(headers, complete) {
            // Get a new xhr
            var handle,
                i,
                xhr = s.xhr(); // Open the socket
            // Passing null username, generates a login popup on Opera (#2865)

            if (s.username) {
              xhr.open(s.type, s.url, s.async, s.username, s.password);
            } else {
              xhr.open(s.type, s.url, s.async);
            } // Apply custom fields if provided


            if (s.xhrFields) {
              for (i in s.xhrFields) {
                xhr[i] = s.xhrFields[i];
              }
            } // Override mime type if needed


            if (s.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(s.mimeType);
            } // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.


            if (!s.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            } // Need an extra try/catch for cross domain requests in Firefox 3


            try {
              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              }
            } catch (_) {} // Do send the request
            // This may raise an exception which is actually
            // handled in jQuery.ajax (so no try/catch here)


            xhr.send(s.hasContent && s.data || null); // Listener

            _callback = function callback(_, isAbort) {
              var status, statusText, responseHeaders, responses, xml; // Firefox throws exceptions when accessing properties
              // of an xhr when a network error occurred
              // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)

              try {
                // Was never called and is aborted or complete
                if (_callback && (isAbort || xhr.readyState === 4)) {
                  // Only called once
                  _callback = undefined; // Do not keep as active anymore

                  if (handle) {
                    xhr.onreadystatechange = jQuery.noop;

                    if (xhrOnUnloadAbort) {
                      delete xhrCallbacks[handle];
                    }
                  } // If it's an abort


                  if (isAbort) {
                    // Abort it manually if needed
                    if (xhr.readyState !== 4) {
                      xhr.abort();
                    }
                  } else {
                    status = xhr.status;
                    responseHeaders = xhr.getAllResponseHeaders();
                    responses = {};
                    xml = xhr.responseXML; // Construct response list

                    if (xml && xml.documentElement
                    /* #4958 */
                    ) {
                        responses.xml = xml;
                      } // When requesting binary data, IE6-9 will throw an exception
                    // on any attempt to access responseText (#11426)


                    try {
                      responses.text = xhr.responseText;
                    } catch (e) {} // Firefox throws an exception when accessing
                    // statusText for faulty cross-domain requests


                    try {
                      statusText = xhr.statusText;
                    } catch (e) {
                      // We normalize with Webkit giving an empty statusText
                      statusText = "";
                    } // Filter status for non standard behaviors
                    // If the request is local and we have data: assume a success
                    // (success with no data won't get notified, that's the best we
                    // can do given current implementations)


                    if (!status && s.isLocal && !s.crossDomain) {
                      status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204
                    } else if (status === 1223) {
                      status = 204;
                    }
                  }
                }
              } catch (firefoxAccessException) {
                if (!isAbort) {
                  complete(-1, firefoxAccessException);
                }
              } // Call complete if needed


              if (responses) {
                complete(status, statusText, responses, responseHeaders);
              }
            };

            if (!s.async) {
              // if we're in sync mode we fire the callback
              _callback();
            } else if (xhr.readyState === 4) {
              // (IE6 & IE7) if it's in cache and has been
              // retrieved directly we need to fire the callback
              setTimeout(_callback, 0);
            } else {
              handle = ++xhrId;

              if (xhrOnUnloadAbort) {
                // Create the active xhrs callbacks list if needed
                // and attach the unload handler
                if (!xhrCallbacks) {
                  xhrCallbacks = {};
                  jQuery(window).unload(xhrOnUnloadAbort);
                } // Add to list of active xhrs callbacks


                xhrCallbacks[handle] = _callback;
              }

              xhr.onreadystatechange = _callback;
            }
          },
          abort: function abort() {
            if (_callback) {
              _callback(0, 1);
            }
          }
        };
      }
    });
  }

  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rfxnum = new RegExp("^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
      rrun = /queueHooks$/,
      animationPrefilters = [defaultPrefilter],
      tweeners = {
    "*": [function (prop, value) {
      var end,
          unit,
          tween = this.createTween(prop, value),
          parts = rfxnum.exec(value),
          target = tween.cur(),
          start = +target || 0,
          scale = 1,
          maxIterations = 20;

      if (parts) {
        end = +parts[2];
        unit = parts[3] || (jQuery.cssNumber[prop] ? "" : "px"); // We need to compute starting value

        if (unit !== "px" && start) {
          // Iteratively approximate from a nonzero starting point
          // Prefer the current property, because this process will be trivial if it uses the same units
          // Fallback to end or a simple constant
          start = jQuery.css(tween.elem, prop, true) || end || 1;

          do {
            // If previous iteration zeroed out, double until we get *something*
            // Use a string for doubling factor so we don't accidentally see scale as unchanged below
            scale = scale || ".5"; // Adjust and apply

            start = start / scale;
            jQuery.style(tween.elem, prop, start + unit); // Update scale, tolerating zero or NaN from tween.cur()
            // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
          } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
        }

        tween.unit = unit;
        tween.start = start; // If a +=/-= token was provided, we're doing a relative animation

        tween.end = parts[1] ? start + (parts[1] + 1) * end : end;
      }

      return tween;
    }]
  }; // Animations created synchronously will run synchronously

  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    }, 0);
    return fxNow = jQuery.now();
  }

  function createTweens(animation, props) {
    jQuery.each(props, function (prop, value) {
      var collection = (tweeners[prop] || []).concat(tweeners["*"]),
          index = 0,
          length = collection.length;

      for (; index < length; index++) {
        if (collection[index].call(animation, prop, value)) {
          // we're done with this property
          return;
        }
      }
    });
  }

  function Animation(elem, properties, options) {
    var result,
        index = 0,
        tweenerIndex = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function tick() {
      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]);

      if (percent < 1 && length) {
        return remaining;
      } else {
        deferred.resolveWith(elem, [animation]);
        return false;
      }
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {}
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function createTween(prop, end, easing) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function stop(gotoEnd) {
        var index = 0,
            // if we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // resolve when we played the last frame
        // otherwise, reject


        if (gotoEnd) {
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        return result;
      }
    }

    createTweens(animation, props);

    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }

    jQuery.fx.timer(jQuery.extend(tick, {
      anim: animation,
      queue: animation.opts.queue,
      elem: elem
    })); // attach callbacks from options

    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // not quite $.extend, this wont overwrite keys already present.
        // also - reusing 'index' from above because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function tweener(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });

  function defaultPrefilter(elem, props, opts) {
    var index,
        prop,
        value,
        length,
        dataShow,
        toggle,
        tween,
        hooks,
        oldfire,
        anim = this,
        style = elem.style,
        orig = {},
        handled = [],
        hidden = elem.nodeType && isHidden(elem); // handle queue: false promises

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // doing this makes sure that the complete handler will be called
        // before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // height/width overflow pass


    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      // Make sure that nothing sneaks out
      // Record all 3 overflow attributes because IE does not
      // change the overflow attribute when overflowX and
      // overflowY are set to the same value
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Set display property to inline-block for height/width
      // animations on inline elements that are having width/height animated

      if (jQuery.css(elem, "display") === "inline" && jQuery.css(elem, "float") === "none") {
        // inline-level elements accept inline-block;
        // block-level elements need to be inline with layout
        if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") {
          style.display = "inline-block";
        } else {
          style.zoom = 1;
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";

      if (!jQuery.support.shrinkWrapBlocks) {
        anim.done(function () {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
    } // show/hide pass


    for (index in props) {
      value = props[index];

      if (rfxtypes.exec(value)) {
        delete props[index];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          continue;
        }

        handled.push(index);
      }
    }

    length = handled.length;

    if (length) {
      dataShow = jQuery._data(elem, "fxshow") || jQuery._data(elem, "fxshow", {});

      if ("hidden" in dataShow) {
        hidden = dataShow.hidden;
      } // store state if its toggle - enables .stop().toggle() to "reverse"


      if (toggle) {
        dataShow.hidden = !hidden;
      }

      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }

      anim.done(function () {
        var prop;
        jQuery.removeData(elem, "fxshow", true);

        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });

      for (index = 0; index < length; index++) {
        prop = handled[index];
        tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
        orig[prop] = dataShow[prop] || jQuery.style(elem, prop);

        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;

          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    }
  }

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result;

        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        } // passing any value as a 4th parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails
        // so, simple values such as "10px" are parsed to Float.
        // complex values such as "rotate(1rad)" are returned as is.


        result = jQuery.css(tween.elem, tween.prop, false, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        // use step hook for back compat - use cssHook if its there - use .style if its
        // available and use plain properties where available
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Remove in 2.0 - this supports IE8's panic based approach
  // to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" || // special check for .toggle( handler, handler, ... )
      !i && jQuery.isFunction(speed) && jQuery.isFunction(easing) ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      // show any hidden elements after setting opacity to 0
      return this.filter(isHidden).css("opacity", 0).show() // animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function doAnimation() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations resolve immediately

        if (empty) {
          anim.stop(true);
        }
      };

      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = jQuery._data(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // start the next in the queue if the last step wasn't forced
        // timers currently will call their complete callbacks, which will dequeue
        // but only if they were gotoEnd


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    }
  }); // Generate parameters to create a standard animation

  function genFx(type, includeWidth) {
    var which,
        attrs = {
      height: type
    },
        i = 0; // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  } // Generate shortcuts for custom animations


  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default; // normalize opt.queue - true/undefined/null -> "fx"

    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.timers = [];
  jQuery.fx = Tween.prototype.init;

  jQuery.fx.tick = function () {
    var timer,
        timers = jQuery.timers,
        i = 0;
    fxNow = jQuery.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Checks the timer has not already been removed

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    if (timer() && jQuery.timers.push(timer) && !timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };

  jQuery.fx.interval = 13;

  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Back Compat <1.8 extension point

  jQuery.fx.step = {};

  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
  }

  var rroot = /^(?:body|html)$/i;

  jQuery.fn.offset = function (options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function (i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }

    var docElem,
        body,
        win,
        clientTop,
        clientLeft,
        scrollTop,
        scrollLeft,
        box = {
      top: 0,
      left: 0
    },
        elem = this[0],
        doc = elem && elem.ownerDocument;

    if (!doc) {
      return;
    }

    if ((body = doc.body) === elem) {
      return jQuery.offset.bodyOffset(elem);
    }

    docElem = doc.documentElement; // Make sure it's not a disconnected DOM node

    if (!jQuery.contains(docElem, elem)) {
      return box;
    } // If we don't have gBCR, just use 0,0 rather than error
    // BlackBerry 5, iOS 3 (original iPhone)


    if (typeof elem.getBoundingClientRect !== "undefined") {
      box = elem.getBoundingClientRect();
    }

    win = getWindow(doc);
    clientTop = docElem.clientTop || body.clientTop || 0;
    clientLeft = docElem.clientLeft || body.clientLeft || 0;
    scrollTop = win.pageYOffset || docElem.scrollTop;
    scrollLeft = win.pageXOffset || docElem.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  };

  jQuery.offset = {
    bodyOffset: function bodyOffset(body) {
      var top = body.offsetTop,
          left = body.offsetLeft;

      if (jQuery.support.doesNotIncludeMarginInBodyOffset) {
        top += parseFloat(jQuery.css(body, "marginTop")) || 0;
        left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
      }

      return {
        top: top,
        left: left
      };
    },
    setOffset: function setOffset(elem, options, i) {
      var position = jQuery.css(elem, "position"); // set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      var curElem = jQuery(elem),
          curOffset = curElem.offset(),
          curCSSTop = jQuery.css(elem, "top"),
          curCSSLeft = jQuery.css(elem, "left"),
          calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
          props = {},
          curPosition = {},
          curTop,
          curLeft; // need to be able to calculate position if either top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    position: function position() {
      if (!this[0]) {
        return;
      }

      var elem = this[0],
          // Get *real* offsetParent
      offsetParent = this.offsetParent(),
          // Get correct offsets
      offset = this.offset(),
          parentOffset = rroot.test(offsetParent[0].nodeName) ? {
        top: 0,
        left: 0
      } : offsetParent.offset(); // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0

      offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
      offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0; // Add offsetParent borders

      parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
      parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0; // Subtract the two offsets

      return {
        top: offset.top - parentOffset.top,
        left: offset.left - parentOffset.left
      };
    },
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent || document.body;

        while (offsetParent && !rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || document.body;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = /Y/.test(prop);

    jQuery.fn[method] = function (val) {
      return jQuery.access(this, function (elem, method, val) {
        var win = getWindow(elem);

        if (val === undefined) {
          return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });

  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
  } // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods


  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return jQuery.access(this, function (elem, type, value) {
          var doc;

          if (jQuery.isWindow(elem)) {
            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
            // isn't a whole lot we can do. See pull request at this URL for discussion:
            // https://github.com/jquery/jquery/pull/764
            return elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
            // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, value, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  }); // Expose jQuery to the global object

  window.jQuery = window.$ = jQuery; // Expose jQuery as an AMD module, but only for AMD loaders that
  // understand the issues with loading multiple versions of jQuery
  // in a page that all might call define(). The loader will indicate
  // they have special allowances for multiple jQuery versions by
  // specifying define.amd.jQuery = true. Register as a named module,
  // since jQuery can be concatenated with other files that may use define,
  // but not use a proper concatenation script that understands anonymous
  // AMD modules. A named AMD is safest and most robust way to register.
  // Lowercase jquery is used because AMD module names are derived from
  // file names, and jQuery is normally delivered in a lowercase file name.
  // Do this after creating the global so that if an AMD module wants to call
  // noConflict to hide this version of jQuery, it will work.

  if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js").jQuery) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})(window);

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 0:
/*!*************************************************************!*\
  !*** multi ./resources/js/app.js ./resources/sass/app.scss ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! D:\project\dungthinhnew\core\resources\js\app.js */"./resources/js/app.js");
module.exports = __webpack_require__(/*! D:\project\dungthinhnew\core\resources\sass\app.scss */"./resources/sass/app.scss");


/***/ })

/******/ });